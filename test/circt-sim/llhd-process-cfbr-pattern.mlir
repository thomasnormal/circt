// RUN: circt-sim %s --top=test_cfbr_pattern --sim-stats --max-time=100000000 2>&1 | FileCheck %s
// REQUIRES: circt-sim

// Test that circt-sim handles the cf.br pattern generated by circt-verilog.
// This pattern has cf.br as the first instruction in the entry block,
// which then branches to the actual body block containing llhd.wait.

// CHECK: [circt-sim] Found 2 LLHD processes
// CHECK: [circt-sim] Starting simulation
// CHECK: [circt-sim] Simulation finished at time 50000000 fs
// CHECK: [circt-sim] Simulation completed

hw.module @test_cfbr_pattern() {
  %c0_i1 = hw.constant 0 : i1
  %c1_i1 = hw.constant 1 : i1
  %delay5ns = llhd.constant_time <5ns, 0d, 0e>
  %delay50ns = llhd.constant_time <50ns, 0d, 0e>
  %delta = llhd.constant_time <0ns, 1d, 0e>

  %clk = llhd.sig "clk" %c0_i1 : i1

  // This is the pattern generated by circt-verilog for "always #5 clk = ~clk"
  // The entry block starts with cf.br (cannot branch back to entry block in MLIR)
  llhd.process {
    cf.br ^body
  ^body:
    llhd.wait delay %delay5ns, ^after_wait
  ^after_wait:
    %clk_val = llhd.prb %clk : !llhd.ref<i1>
    %not_clk = comb.xor %clk_val, %c1_i1 : i1
    llhd.drv %clk, %not_clk after %delta : i1
    cf.br ^body  // Loop back
  }

  // This is the pattern generated by circt-verilog for "initial #50 $finish"
  llhd.process {
    cf.br ^init_body
  ^init_body:
    llhd.wait delay %delay50ns, ^finish
  ^finish:
    // Terminate the simulation - this is generated from $finish
    sim.terminate success, verbose
    llhd.halt
  }

  hw.output
}
