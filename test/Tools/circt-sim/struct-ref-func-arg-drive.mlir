// RUN: circt-sim %s --top TestStructRefFuncArg 2>&1 | FileCheck %s
// Tests that llhd.drv and llhd.prb on struct fields extracted from an
// !llhd.ref function argument backed by llvm.alloca work correctly.
// This is the pattern generated by MooreToCore for local struct variables
// passed by reference (e.g., uvm_resource_debug::init_access_record).

// CHECK: a=42 b=99

module {
  // A function that receives an !llhd.ref to a struct and drives its fields.
  // This mirrors init_access_record which receives a struct ref from its caller.
  func.func private @init_fields(%arg0: !llhd.ref<!hw.struct<a: i32, b: i32>>) {
    %time = llhd.constant_time <0ns, 0d, 1e>
    %c42_i32 = hw.constant 42 : i32
    %c99_i32 = hw.constant 99 : i32
    %0 = llhd.sig.struct_extract %arg0["a"] : <!hw.struct<a: i32, b: i32>>
    llhd.drv %0, %c42_i32 after %time : i32
    %1 = llhd.sig.struct_extract %arg0["b"] : <!hw.struct<a: i32, b: i32>>
    llhd.drv %1, %c99_i32 after %time : i32
    return
  }

  hw.module @TestStructRefFuncArg() {
    %time = llhd.constant_time <0ns, 0d, 1e>
    %one = llvm.mlir.constant(1 : i64) : i64

    %fmt_a = sim.fmt.literal "a="
    %fmt_sep = sim.fmt.literal " b="
    %fmt_nl = sim.fmt.literal "\0A"

    llhd.process {
      // Allocate a local struct (like record_write_access does)
      %alloca = llvm.alloca %one x !llvm.struct<(i32, i32)> : (i64) -> !llvm.ptr

      // Initialize to zero
      %zero_struct = llvm.mlir.undef : !llvm.struct<(i32, i32)>
      %c0_i32 = llvm.mlir.constant(0 : i32) : i32
      %s1 = llvm.insertvalue %c0_i32, %zero_struct[0] : !llvm.struct<(i32, i32)>
      %s2 = llvm.insertvalue %c0_i32, %s1[1] : !llvm.struct<(i32, i32)>
      llvm.store %s2, %alloca : !llvm.struct<(i32, i32)>, !llvm.ptr

      // Cast to !llhd.ref (as MooreToCore generates)
      %ref = builtin.unrealized_conversion_cast %alloca : !llvm.ptr to !llhd.ref<!hw.struct<a: i32, b: i32>>

      // Call the function that drives fields via the ref argument
      func.call @init_fields(%ref) : (!llhd.ref<!hw.struct<a: i32, b: i32>>) -> ()

      // Probe the fields to verify the drive worked
      %a_ref = llhd.sig.struct_extract %ref["a"] : <!hw.struct<a: i32, b: i32>>
      %a_val = llhd.prb %a_ref : i32
      %b_ref = llhd.sig.struct_extract %ref["b"] : <!hw.struct<a: i32, b: i32>>
      %b_val = llhd.prb %b_ref : i32

      // Format and print results
      %fmt_a_val = sim.fmt.dec %a_val : i32
      %fmt_b_val = sim.fmt.dec %b_val : i32
      %fmt = sim.fmt.concat (%fmt_a, %fmt_a_val, %fmt_sep, %fmt_b_val, %fmt_nl)
      sim.proc.print %fmt

      llhd.halt
    }
    hw.output
  }
}
