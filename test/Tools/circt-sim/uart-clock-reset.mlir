// RUN: circt-sim %s --max-time=2000000000 --sim-stats | FileCheck %s

// Test UART AVIP-style clock generation and reset sequence.
// This mirrors the pattern generated by circt-verilog for UART AVIP.
// UART uses a faster clock (100ps period = 0.1ns half-period) compared to APB.

// CHECK: [circt-sim] Found 2 LLHD processes
// CHECK: [circt-sim] Starting simulation
// CHECK: [circt-sim] Simulation completed at time 2000000000 fs
// CHECK: Processes executed:
// CHECK-SAME: {{[0-9]+}}
// CHECK: Delta cycles:
// CHECK-SAME: {{[0-9]+}}
// CHECK: Signal updates:
// CHECK-SAME: {{[0-9]+}}
// CHECK: Edges detected:
// CHECK-SAME: {{[0-9]+}}
// CHECK: [circt-sim] Simulation completed

hw.module @UartClockReset() {
  %true = hw.constant true
  %false = hw.constant false
  %c0_i32 = hw.constant 0 : i32
  %c1_i32 = hw.constant 1 : i32
  %c-1_i32 = hw.constant -1 : i32
  %c100000_i64 = hw.constant 100000 : i64      // 100ps clock period (half) - UART 500MHz
  %c1000000_i64 = hw.constant 1000000 : i64    // 1ns reset delay
  %eps = llhd.constant_time <0ns, 0d, 1e>

  // Clock signal (UART clk)
  %clk = llhd.sig %false : i1

  // Reset signal (active high reset)
  %reset = llhd.sig %true : i1

  // Clock generation process - toggles every 100ps (500MHz)
  // Equivalent to: forever #0.1 clk = ~clk;
  %0 = llhd.process -> i1 {
    cf.br ^bb1(%false : i1)
  ^bb1(%clk_val: i1):
    %delay = llhd.int_to_time %c100000_i64
    llhd.wait yield (%clk_val : i1), delay %delay, ^bb2
  ^bb2:
    %clk_inv = comb.xor %clk_val, %true : i1
    cf.br ^bb1(%clk_inv : i1)
  }
  llhd.drv %clk, %0 after %eps : i1

  // Reset sequence process
  // Equivalent to:
  //   reset = 1'b1;
  //   #1 reset = 1'b0;
  //   repeat(1) @(posedge clk);
  //   reset = 1'b1;
  %1:2 = llhd.process -> i1, i1 {
    // Start with reset = 1
    %reset_delay = llhd.int_to_time %c1000000_i64
    llhd.wait yield (%true, %true : i1, i1), delay %reset_delay, ^bb1
  ^bb1:
    // After 1ns, reset = 0
    %old_clk = llhd.prb %clk : i1
    cf.br ^bb2(%c1_i32, %false, %true, %old_clk : i32, i1, i1, i1)
  ^bb2(%cnt: i32, %rst_drv: i1, %rst_yield: i1, %last_clk: i1):
    %done = comb.icmp eq %cnt, %c0_i32 : i32
    cf.cond_br %done, ^bb_done, ^wait_edge(%rst_drv, %rst_yield, %last_clk : i1, i1, i1)
  ^wait_edge(%rst_val: i1, %rst_y: i1, %prev_clk: i1):
    %current_clk = llhd.prb %clk : i1
    llhd.wait yield (%rst_val, %rst_y : i1, i1), (%current_clk : i1), ^bb3(%prev_clk : i1)
  ^bb3(%old_clk2: i1):
    %new_clk = llhd.prb %clk : i1
    %old_inv = comb.xor %old_clk2, %true : i1
    %posedge = comb.and %old_inv, %new_clk : i1
    cf.cond_br %posedge, ^dec_cnt, ^wait_edge(%false, %false, %new_clk : i1, i1, i1)
  ^dec_cnt:
    %new_cnt = comb.add %cnt, %c-1_i32 : i32
    cf.br ^bb2(%new_cnt, %false, %false, %new_clk : i32, i1, i1, i1)
  ^bb_done:
    // After posedge, reset = 1 and halt
    llhd.halt %true, %true : i1, i1
  }
  llhd.drv %reset, %1#0 after %eps : i1

  hw.output
}
