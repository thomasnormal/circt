//===- LLHDProcessInterpreter.cpp - LLHD process interpretation -*- C++ -*-===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//
//
// This file implements the LLHDProcessInterpreter class for interpreting
// LLHD process bodies during event-driven simulation.
//
//===----------------------------------------------------------------------===//

#include "LLHDProcessInterpreter.h"
#include "JITCompileManager.h"

// Global crash diagnostic — last LLVM callee name
const char *g_lastLLVMCallCallee = nullptr;
// Global crash diagnostic — last MLIR op name being interpreted
const char *g_lastOpName = nullptr;
unsigned g_lastProcId = 0;
// Global crash diagnostic — last func being interpreted (static buffer)
char g_lastFuncName[256] = {};
unsigned g_lastFuncProcId = 0;
#include "circt/Dialect/Comb/CombOps.h"
#include "circt/Dialect/HW/HWOps.h"
#include "circt/Dialect/Moore/MooreOps.h"
#include "circt/Dialect/Seq/SeqOps.h"
#include "circt/Dialect/Sim/SimOps.h"
#include "circt/Dialect/Verif/VerifOps.h"
#include "circt/Runtime/MooreRuntime.h"
#include "mlir/Dialect/Arith/IR/Arith.h"
#include "mlir/Dialect/ControlFlow/IR/ControlFlowOps.h"
#include "mlir/Dialect/Func/IR/FuncOps.h"
#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
#include "mlir/Dialect/SCF/IR/SCF.h"
#include "mlir/Interfaces/CallInterfaces.h"
#include "mlir/Interfaces/SideEffectInterfaces.h"
#include "llvm/ADT/ScopeExit.h"
#include "llvm/ADT/STLExtras.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/Format.h"
#include "llvm/Support/raw_ostream.h"
#include <cerrno>
#include <cmath>
#include <cstdlib>
#include <cstring>
#include <fstream>
#include <sstream>

#define DEBUG_TYPE "llhd-interpreter"

using namespace mlir;
using namespace circt;
using namespace circt::sim;

static bool getSignalInitValue(Value initValue, unsigned width,
                               llvm::APInt &outValue);
static size_t countRegionOps(mlir::Region &region);
static bool isProcessCacheableBody(Operation *op);
static bool isPureResumableWaitPreludeOp(Operation *op) {
  if (!op || op->getNumResults() == 0)
    return false;
  if (op->getNumRegions() != 0 || op->hasTrait<OpTrait::IsTerminator>())
    return false;
  if (isa<llhd::DriveOp, llhd::WaitOp, llhd::HaltOp, mlir::cf::BranchOp,
          mlir::cf::CondBranchOp, mlir::func::CallOp,
          mlir::func::CallIndirectOp, LLVM::CallOp,
          sim::PrintFormattedProcOp>(op))
    return false;
  // Probe reads are intentionally allowed for event sensitivity setup.
  if (isa<llhd::ProbeOp>(op))
    return true;
  return mlir::isMemoryEffectFree(op);
}

static Type unwrapSignalType(Type type) {
  if (auto refType = dyn_cast<llhd::RefType>(type))
    return refType.getNestedType();
  return type;
}

namespace circt::sim {

struct ScopedInstanceContext {
  ScopedInstanceContext(LLHDProcessInterpreter &interpreter, InstanceId instance)
      : interpreter(interpreter),
        previous(interpreter.activeInstanceId) {
    interpreter.activeInstanceId = instance;
  }

  ~ScopedInstanceContext() { interpreter.activeInstanceId = previous; }

  ScopedInstanceContext(const ScopedInstanceContext &) = delete;
  ScopedInstanceContext &operator=(const ScopedInstanceContext &) = delete;

private:
  LLHDProcessInterpreter &interpreter;
  InstanceId previous = 0;
};

struct ScopedInputValueMap {
  explicit ScopedInputValueMap(
      LLHDProcessInterpreter &interpreter,
      const InstanceInputMapping &mapping)
      : interpreter(interpreter) {
    for (const auto &entry : mapping) {
      auto it = interpreter.inputValueMap.find(entry.arg);
      if (it != interpreter.inputValueMap.end())
        previous.emplace_back(entry.arg, it->second);
      else
        added.push_back(entry.arg);
      interpreter.inputValueMap[entry.arg] = entry.value;

      auto instIt = interpreter.inputValueInstanceMap.find(entry.arg);
      if (instIt != interpreter.inputValueInstanceMap.end())
        previousInstances.emplace_back(entry.arg, instIt->second);
      else
        addedInstances.push_back(entry.arg);
      interpreter.inputValueInstanceMap[entry.arg] = entry.instanceId;
    }
  }

  ~ScopedInputValueMap() {
    for (const auto &entry : previous)
      interpreter.inputValueMap[entry.first] = entry.second;
    for (const auto &key : added)
      interpreter.inputValueMap.erase(key);
    for (const auto &entry : previousInstances)
      interpreter.inputValueInstanceMap[entry.first] = entry.second;
    for (const auto &key : addedInstances)
      interpreter.inputValueInstanceMap.erase(key);
  }

  ScopedInputValueMap(const ScopedInputValueMap &) = delete;
  ScopedInputValueMap &operator=(const ScopedInputValueMap &) = delete;

private:
  LLHDProcessInterpreter &interpreter;
  llvm::SmallVector<std::pair<mlir::Value, mlir::Value>, 8> previous;
  llvm::SmallVector<mlir::Value, 8> added;
  llvm::SmallVector<std::pair<mlir::Value, InstanceId>, 8> previousInstances;
  llvm::SmallVector<mlir::Value, 8> addedInstances;
};

} // namespace circt::sim

static bool getMaskedUInt64(const InterpretedValue &value,
                            unsigned targetWidth, uint64_t &out) {
  if (value.isX() || targetWidth > 64)
    return false;
  uint64_t v = value.getUInt64();
  unsigned width = value.getWidth();
  if (width < 64) {
    uint64_t mask = (width == 64) ? ~0ULL : ((1ULL << width) - 1);
    v &= mask;
  }
  if (targetWidth < 64) {
    uint64_t mask = (targetWidth == 64) ? ~0ULL : ((1ULL << targetWidth) - 1);
    v &= mask;
  }
  out = v;
  return true;
}

static unsigned writeConfigDbBytesToNativeMemory(
    uint64_t addr, uint64_t nativeOffset, size_t nativeSize,
    const std::vector<uint8_t> &valueData, unsigned requestedBytes,
    bool zeroFillMissing) {
  if (requestedBytes == 0 || nativeOffset >= nativeSize)
    return 0;

  size_t availableBytes = nativeSize - static_cast<size_t>(nativeOffset);
  unsigned maxWritable =
      static_cast<unsigned>(std::min<size_t>(requestedBytes, availableBytes));
  unsigned copyBytes =
      std::min(maxWritable, static_cast<unsigned>(valueData.size()));

  if (copyBytes > 0)
    std::memcpy(reinterpret_cast<void *>(addr), valueData.data(), copyBytes);
  if (zeroFillMissing && maxWritable > copyBytes)
    std::memset(reinterpret_cast<void *>(addr + copyBytes), 0,
                maxWritable - copyBytes);
  return maxWritable;
}

static unsigned writeConfigDbBytesToMemoryBlock(
    MemoryBlock *block, uint64_t offset, const std::vector<uint8_t> &valueData,
    unsigned requestedBytes, bool zeroFillMissing) {
  if (!block || requestedBytes == 0)
    return 0;

  size_t start = static_cast<size_t>(offset);
  if (start >= block->data.size())
    return 0;

  size_t availableBytes = block->data.size() - start;
  unsigned maxWritable =
      static_cast<unsigned>(std::min<size_t>(requestedBytes, availableBytes));
  unsigned copyBytes =
      std::min(maxWritable, static_cast<unsigned>(valueData.size()));

  if (copyBytes > 0)
    std::memcpy(block->data.data() + start, valueData.data(), copyBytes);
  if (zeroFillMissing && maxWritable > copyBytes)
    std::memset(block->data.data() + start + copyBytes, 0,
                maxWritable - copyBytes);
  if (maxWritable > 0)
    block->initialized = true;
  return maxWritable;
}

// Compute a native UVM port connection count by traversing the interpreter's
// port connection graph and counting terminal providers.
static int32_t getNativeUvmPortSize(
    const llvm::DenseMap<uint64_t, llvm::SmallVector<uint64_t, 2>>
        &analysisPortConnections,
    uint64_t portAddr) {
  if (portAddr == 0)
    return 0;

  auto seedIt = analysisPortConnections.find(portAddr);
  if (seedIt == analysisPortConnections.end() || seedIt->second.empty())
    return 0;

  llvm::SmallVector<uint64_t, 8> worklist(seedIt->second.begin(),
                                          seedIt->second.end());
  llvm::DenseSet<uint64_t> visited;
  llvm::DenseSet<uint64_t> terminalProviders;

  while (!worklist.empty()) {
    uint64_t addr = worklist.pop_back_val();
    if (addr == 0 || !visited.insert(addr).second)
      continue;

    auto it = analysisPortConnections.find(addr);
    if (it != analysisPortConnections.end() && !it->second.empty()) {
      for (uint64_t next : it->second)
        worklist.push_back(next);
      continue;
    }
    terminalProviders.insert(addr);
  }

  if (!terminalProviders.empty())
    return static_cast<int32_t>(terminalProviders.size());
  // Fallback: preserve "connected means non-zero" even if graph is cyclic.
  return static_cast<int32_t>(seedIt->second.size());
}

//===----------------------------------------------------------------------===//
// LLHDProcessInterpreter Implementation
//===----------------------------------------------------------------------===//

LLHDProcessInterpreter::LLHDProcessInterpreter(ProcessScheduler &scheduler)
    : scheduler(scheduler), forkJoinManager(scheduler),
      syncPrimitivesManager(scheduler) {
  auto envFlagEnabled = [](const char *name) {
    if (const char *env = std::getenv(name)) {
      char c = env[0];
      return c == '1' || c == 'y' || c == 'Y' || c == 't' || c == 'T';
    }
    return false;
  };
  auto envUint64Value = [](const char *name, uint64_t defaultValue) {
    if (const char *env = std::getenv(name)) {
      char *end = nullptr;
      errno = 0;
      unsigned long long parsed = std::strtoull(env, &end, 10);
      if (errno == 0 && end != env)
        return static_cast<uint64_t>(parsed);
    }
    return defaultValue;
  };
  auto envInt64Value = [](const char *name, int64_t defaultValue) {
    if (const char *env = std::getenv(name)) {
      char *end = nullptr;
      errno = 0;
      long long parsed = std::strtoll(env, &end, 10);
      if (errno == 0 && end != env)
        return static_cast<int64_t>(parsed);
    }
    return defaultValue;
  };
  profilingEnabled = std::getenv("CIRCT_SIM_PROFILE_FUNCS") != nullptr;
  traceSeqEnabled = std::getenv("CIRCT_SIM_TRACE_SEQ") != nullptr;
  traceAnalysisEnabled = std::getenv("CIRCT_SIM_TRACE_ANALYSIS") != nullptr;
  fastPathUvmReportInfo = envFlagEnabled("CIRCT_SIM_FASTPATH_UVM_REPORT_INFO");
  fastPathUvmReportWarning =
      envFlagEnabled("CIRCT_SIM_FASTPATH_UVM_REPORT_WARNING");
  fastPathUvmGetReportObject =
      envFlagEnabled("CIRCT_SIM_FASTPATH_UVM_GET_REPORT_OBJECT");
  uvmJitHotThreshold = envUint64Value("CIRCT_SIM_UVM_JIT_HOT_THRESHOLD", 0);
  uvmJitPromotionBudget =
      envInt64Value("CIRCT_SIM_UVM_JIT_PROMOTION_BUDGET", 0);
  uvmJitTracePromotions =
      envFlagEnabled("CIRCT_SIM_UVM_JIT_TRACE_PROMOTIONS");
  profileSummaryAtExitEnabled =
      std::getenv("CIRCT_SIM_PROFILE_SUMMARY_AT_EXIT") != nullptr;
  forceJitThunkDeoptRequests =
      envFlagEnabled("CIRCT_SIM_JIT_FORCE_DEOPT_REQUEST");
  memorySampleIntervalSteps = envUint64Value(
      "CIRCT_SIM_PROFILE_MEMORY_SAMPLE_INTERVAL",
      profileSummaryAtExitEnabled ? 65536 : 0);
  memoryDeltaWindowSamples = envUint64Value(
      "CIRCT_SIM_PROFILE_MEMORY_DELTA_WINDOW_SAMPLES",
      profileSummaryAtExitEnabled ? 16 : 0);
  if (memoryDeltaWindowSamples < 2)
    memoryDeltaWindowSamples = 0;
  memorySummaryTopProcesses = envUint64Value(
      "CIRCT_SIM_PROFILE_MEMORY_TOP_PROCESSES",
      profileSummaryAtExitEnabled ? 3 : 0);
  if (memorySampleIntervalSteps > 0)
    memorySampleNextStep = memorySampleIntervalSteps;
  uvmSeqQueueCacheMaxEntries =
      envUint64Value("CIRCT_SIM_UVM_SEQ_QUEUE_CACHE_MAX_ENTRIES", 0);
  uvmSeqQueueCacheEvictOnCap =
      envFlagEnabled("CIRCT_SIM_UVM_SEQ_QUEUE_CACHE_EVICT_ON_CAP");
}

bool LLHDProcessInterpreter::lookupUvmSequencerQueueCache(
    uint64_t portAddr, uint64_t &queueAddr) {
  if (portAddr == 0)
    return false;
  auto it = portToSequencerQueue.find(portAddr);
  if (it == portToSequencerQueue.end()) {
    ++uvmSeqQueueCacheMisses;
    return false;
  }
  ++uvmSeqQueueCacheHits;
  queueAddr = it->second;
  return true;
}

void LLHDProcessInterpreter::cacheUvmSequencerQueueAddress(uint64_t portAddr,
                                                           uint64_t queueAddr) {
  if (portAddr == 0 || queueAddr == 0)
    return;

  auto it = portToSequencerQueue.find(portAddr);
  if (it != portToSequencerQueue.end()) {
    it->second = queueAddr;
    return;
  }

  if (uvmSeqQueueCacheMaxEntries &&
      portToSequencerQueue.size() >= uvmSeqQueueCacheMaxEntries) {
    if (!uvmSeqQueueCacheEvictOnCap) {
      ++uvmSeqQueueCacheCapacitySkips;
      return;
    }
    if (!portToSequencerQueue.empty()) {
      portToSequencerQueue.erase(portToSequencerQueue.begin());
      ++uvmSeqQueueCacheEvictions;
    }
  }

  portToSequencerQueue.try_emplace(portAddr, queueAddr);
  ++uvmSeqQueueCacheInstalls;
}

void LLHDProcessInterpreter::invalidateUvmSequencerQueueCache(
    uint64_t portAddr) {
  if (portAddr == 0)
    return;
  portToSequencerQueue.erase(portAddr);
}

void LLHDProcessInterpreter::recordUvmSequencerItemOwner(uint64_t itemAddr,
                                                         uint64_t sqrAddr) {
  if (itemAddr == 0 || sqrAddr == 0)
    return;
  auto [it, inserted] = itemToSequencer.try_emplace(itemAddr, sqrAddr);
  if (!inserted) {
    it->second = sqrAddr;
    return;
  }
  ++uvmSeqItemOwnerStores;
  uvmSeqItemOwnerPeak =
      std::max<uint64_t>(uvmSeqItemOwnerPeak, itemToSequencer.size());
}

uint64_t LLHDProcessInterpreter::takeUvmSequencerItemOwner(uint64_t itemAddr) {
  if (itemAddr == 0)
    return 0;
  auto it = itemToSequencer.find(itemAddr);
  if (it == itemToSequencer.end())
    return 0;
  uint64_t sqrAddr = it->second;
  itemToSequencer.erase(it);
  ++uvmSeqItemOwnerErases;
  return sqrAddr;
}

LLHDProcessInterpreter::MemoryStateSnapshot
LLHDProcessInterpreter::collectMemoryStateSnapshot() const {
  MemoryStateSnapshot snapshot;
  snapshot.globalBlocks = globalMemoryBlocks.size();
  for (const auto &entry : globalMemoryBlocks)
    snapshot.globalBytes += entry.second.size;

  snapshot.mallocBlocks = mallocBlocks.size();
  for (const auto &entry : mallocBlocks)
    snapshot.mallocBytes += entry.second.size;

  snapshot.nativeBlocks = nativeMemoryBlocks.size();
  for (const auto &entry : nativeMemoryBlocks)
    snapshot.nativeBytes += entry.second;

  for (const auto &procEntry : processStates) {
    uint64_t procBytes = 0;
    for (const auto &blockEntry : procEntry.second.memoryBlocks) {
      ++snapshot.processBlocks;
      snapshot.processBytes += blockEntry.second.size;
      procBytes += blockEntry.second.size;
    }
    if (procBytes >= snapshot.largestProcessBytes) {
      snapshot.largestProcessBytes = procBytes;
      snapshot.largestProcessId = procEntry.first;
    }
  }

  snapshot.dynamicStrings = dynamicStrings.size();
  for (const auto &entry : dynamicStrings) {
    if (entry.second.second > 0)
      snapshot.dynamicStringBytes +=
          static_cast<uint64_t>(entry.second.second);
  }

  snapshot.configDbEntries = configDbEntries.size();
  for (const auto &entry : configDbEntries)
    snapshot.configDbBytes += entry.second.size();

  snapshot.analysisConnPorts = analysisPortConnections.size();
  for (const auto &entry : analysisPortConnections)
    snapshot.analysisConnEdges += entry.second.size();

  snapshot.seqFifoMaps = sequencerItemFifo.size();
  for (const auto &entry : sequencerItemFifo)
    snapshot.seqFifoItems += entry.second.size();

  return snapshot;
}

void LLHDProcessInterpreter::maybeSampleMemoryState(uint64_t totalSteps) {
  if (!profileSummaryAtExitEnabled || memorySampleIntervalSteps == 0)
    return;
  if (totalSteps < memorySampleNextStep)
    return;

  MemoryStateSnapshot snapshot = collectMemoryStateSnapshot();
  ++memorySampleCount;
  uint64_t trackedBytes = snapshot.totalTrackedBytes();
  if (trackedBytes >= memorySamplePeakTotalBytes) {
    memorySamplePeakTotalBytes = trackedBytes;
    memorySamplePeakStep = totalSteps;
    memoryPeakSnapshot = snapshot;
    memoryPeakLargestProcessFunc.clear();
    if (snapshot.largestProcessId != InvalidProcessId) {
      auto procIt = processStates.find(snapshot.largestProcessId);
      if (procIt != processStates.end())
        memoryPeakLargestProcessFunc = procIt->second.currentFuncName;
    }
  }

  if (memoryDeltaWindowSamples > 0) {
    memorySampleHistory.push_back({totalSteps, snapshot});
    while (memorySampleHistory.size() > memoryDeltaWindowSamples)
      memorySampleHistory.pop_front();
  }

  while (memorySampleNextStep <= totalSteps) {
    if (memorySampleNextStep > UINT64_MAX - memorySampleIntervalSteps) {
      memorySampleNextStep = UINT64_MAX;
      break;
    }
    memorySampleNextStep += memorySampleIntervalSteps;
  }
}

void LLHDProcessInterpreter::noteUvmFastPathActionHit(llvm::StringRef actionKey) {
  if (profilingEnabled)
    ++uvmFastPathProfile[actionKey];

  auto &hitCount = uvmFastPathHitCount[actionKey];
  ++hitCount;

  if (uvmJitHotThreshold == 0 || hitCount < uvmJitHotThreshold)
    return;

  if (uvmJitPromotionBudget == 0)
    return;

  auto storageIt = uvmJitPromotedStorage.find(actionKey);
  llvm::StringRef stableKey;
  if (storageIt == uvmJitPromotedStorage.end())
    stableKey = uvmJitPromotedStorage.try_emplace(actionKey, 0).first->getKey();
  else
    stableKey = storageIt->getKey();

  if (!uvmJitPromotedFastPaths.insert(stableKey).second)
    return;

  if (uvmJitPromotionBudget > 0)
    --uvmJitPromotionBudget;

  if (uvmJitTracePromotions) {
    llvm::errs() << "[circt-sim] UVM JIT promotion candidate: " << stableKey
                 << " hits=" << hitCount
                 << " threshold=" << uvmJitHotThreshold
                 << " budget_remaining=" << uvmJitPromotionBudget << "\n";
  }
}

void LLHDProcessInterpreter::raisePhaseObjection(int64_t handle, int64_t count) {
  if (handle == MOORE_OBJECTION_INVALID_HANDLE || count <= 0)
    return;
  __moore_objection_raise(handle, "", 0, "", 0, count);
}

void LLHDProcessInterpreter::dropPhaseObjection(int64_t handle, int64_t count) {
  if (handle == MOORE_OBJECTION_INVALID_HANDLE || count <= 0)
    return;
  __moore_objection_drop(handle, "", 0, "", 0, count);
  wakeObjectionZeroWaitersIfReady(handle);
}

void LLHDProcessInterpreter::enqueueObjectionZeroWaiter(int64_t handle,
                                                        ProcessId procId,
                                                        Operation *retryOp) {
  if (handle == MOORE_OBJECTION_INVALID_HANDLE || !retryOp)
    return;

  auto &waiters = objectionZeroWaiters[handle];
  for (auto &waiter : waiters) {
    if (waiter.procId != procId)
      continue;
    waiter.retryOp = retryOp;
    return;
  }
  waiters.push_back({procId, retryOp});
}

void LLHDProcessInterpreter::wakeObjectionZeroWaitersIfReady(int64_t handle) {
  if (handle == MOORE_OBJECTION_INVALID_HANDLE)
    return;
  if (__moore_objection_get_count(handle) > 0)
    return;

  auto waitIt = objectionZeroWaiters.find(handle);
  if (waitIt == objectionZeroWaiters.end())
    return;

  auto waiters = std::move(waitIt->second);
  objectionZeroWaiters.erase(waitIt);
  for (const auto &waiter : waiters) {
    auto stateIt = processStates.find(waiter.procId);
    if (stateIt == processStates.end())
      continue;
    auto &state = stateIt->second;
    state.waiting = false;
    if (waiter.retryOp)
      state.currentOp = mlir::Block::iterator(waiter.retryOp);
    scheduler.scheduleProcess(waiter.procId, SchedulingRegion::Active);
  }
}

void LLHDProcessInterpreter::dumpProcessStates(llvm::raw_ostream &os) const {
  os << "[circt-sim] Process states:\n";
  for (const auto &entry : processStates) {
    ProcessId procId = entry.first;
    const ProcessExecutionState &state = entry.second;
    const Process *proc = scheduler.getProcess(procId);
    os << "  proc " << procId;
    if (proc)
      os << " '" << proc->getName() << "'";
    os << " type=" << (state.isInitialBlock ? "initial" : "process");
    if (proc)
      os << " state=" << getProcessStateName(proc->getState());
    os << " waiting=" << (state.waiting ? "1" : "0")
       << " halted=" << (state.halted ? "1" : "0")
       << " steps=" << state.totalSteps;
    if (state.lastOp)
      os << " lastOp=" << state.lastOp->getName().getStringRef();
    if (!state.currentFuncName.empty())
      os << " func=" << state.currentFuncName;
    if (!state.callStack.empty()) {
      const auto &top = state.callStack.back();
      os << " callStack=" << state.callStack.size()
         << " topFrame=" << (top.isLLVM() ? "llvm.call" : "func.call");
    }
    if (state.sequencerGetRetryCallOp)
      os << " seqRetry="
         << state.sequencerGetRetryCallOp->getName().getStringRef();
    os << "\n";
  }

  // Print function call profile (top 30 by call count)
  if (profilingEnabled && !funcCallProfile.empty()) {
    os << "[circt-sim] Function call profile (top 30):\n";
    llvm::SmallVector<std::pair<llvm::StringRef, uint64_t>> sorted;
    for (const auto &entry : funcCallProfile)
      sorted.push_back({entry.getKey(), entry.getValue()});
    llvm::sort(sorted, [](const auto &a, const auto &b) {
      return a.second > b.second;
    });
    for (size_t i = 0; i < std::min(sorted.size(), (size_t)30); ++i)
      os << "  " << sorted[i].second << "x " << sorted[i].first << "\n";
  }

  if (profilingEnabled && !uvmFastPathProfile.empty()) {
    os << "[circt-sim] UVM fast-path profile (top 20):\n";
    llvm::SmallVector<std::pair<llvm::StringRef, uint64_t>> sorted;
    for (const auto &entry : uvmFastPathProfile)
      sorted.push_back({entry.getKey(), entry.getValue()});
    llvm::sort(sorted, [](const auto &a, const auto &b) {
      return a.second > b.second;
    });
    for (size_t i = 0; i < std::min(sorted.size(), (size_t)20); ++i)
      os << "  " << sorted[i].second << "x " << sorted[i].first << "\n";
  }

  if (!uvmJitPromotedFastPaths.empty()) {
    os << "[circt-sim] UVM JIT promotion candidates ("
       << uvmJitPromotedFastPaths.size() << "):\n";
    for (llvm::StringRef key : uvmJitPromotedFastPaths)
      os << "  " << key << "\n";
    os << "[circt-sim] UVM JIT budget remaining: " << uvmJitPromotionBudget
       << "\n";
  }

  uint64_t fifoItems = 0;
  for (const auto &entry : sequencerItemFifo)
    fifoItems += entry.second.size();

  if (uvmSeqItemOwnerStores || uvmSeqItemOwnerErases || !itemToSequencer.empty() ||
      !sequencerItemFifo.empty() || !finishItemWaiters.empty() ||
      !itemDoneReceived.empty() || !lastDequeuedItem.empty()) {
    os << "[circt-sim] UVM sequencer native state: item_map_live="
       << itemToSequencer.size() << " item_map_peak=" << uvmSeqItemOwnerPeak
       << " item_map_stores=" << uvmSeqItemOwnerStores
       << " item_map_erases=" << uvmSeqItemOwnerErases
       << " fifo_maps=" << sequencerItemFifo.size()
       << " fifo_items=" << fifoItems
       << " waiters=" << finishItemWaiters.size()
       << " done_pending=" << itemDoneReceived.size()
       << " last_dequeued=" << lastDequeuedItem.size() << "\n";
  }

  if (uvmSeqQueueCacheHits || uvmSeqQueueCacheMisses || uvmSeqQueueCacheInstalls ||
      uvmSeqQueueCacheCapacitySkips || uvmSeqQueueCacheEvictions ||
      !portToSequencerQueue.empty()) {
    os << "[circt-sim] UVM sequencer queue cache: hits=" << uvmSeqQueueCacheHits
       << " misses=" << uvmSeqQueueCacheMisses
       << " installs=" << uvmSeqQueueCacheInstalls
       << " entries=" << portToSequencerQueue.size()
       << " capacity_skips=" << uvmSeqQueueCacheCapacitySkips
       << " evictions=" << uvmSeqQueueCacheEvictions << "\n";
  }

  if (uvmSeqQueueCacheMaxEntries || uvmSeqQueueCacheCapacitySkips ||
      uvmSeqQueueCacheEvictions || uvmSeqQueueCacheEvictOnCap) {
    os << "[circt-sim] UVM sequencer queue cache limits: max_entries="
       << uvmSeqQueueCacheMaxEntries
       << " capacity_skips=" << uvmSeqQueueCacheCapacitySkips
       << " evictions=" << uvmSeqQueueCacheEvictions
       << " evict_on_cap=" << (uvmSeqQueueCacheEvictOnCap ? 1 : 0) << "\n";
  }

  if (profileSummaryAtExitEnabled) {
    MemoryStateSnapshot snapshot = collectMemoryStateSnapshot();
    os << "[circt-sim] Memory state: global_blocks=" << snapshot.globalBlocks
       << " global_bytes=" << snapshot.globalBytes
       << " malloc_blocks=" << snapshot.mallocBlocks
       << " malloc_bytes=" << snapshot.mallocBytes
       << " native_blocks=" << snapshot.nativeBlocks
       << " native_bytes=" << snapshot.nativeBytes
       << " process_blocks=" << snapshot.processBlocks
       << " process_bytes=" << snapshot.processBytes
       << " dynamic_strings=" << snapshot.dynamicStrings
       << " dynamic_string_bytes=" << snapshot.dynamicStringBytes
       << " config_db_entries=" << snapshot.configDbEntries
       << " config_db_bytes=" << snapshot.configDbBytes
       << " analysis_conn_ports=" << snapshot.analysisConnPorts
       << " analysis_conn_edges=" << snapshot.analysisConnEdges
       << " seq_fifo_maps=" << snapshot.seqFifoMaps
       << " seq_fifo_items=" << snapshot.seqFifoItems
       << " largest_process=" << snapshot.largestProcessId
       << " largest_process_bytes=" << snapshot.largestProcessBytes << "\n";

    if (memorySampleIntervalSteps > 0) {
      const MemoryStateSnapshot &peakSnapshot =
          (memorySampleCount > 0) ? memoryPeakSnapshot : snapshot;
      uint64_t peakStep = (memorySampleCount > 0) ? memorySamplePeakStep : 0;
      uint64_t peakTotalBytes = (memorySampleCount > 0)
                                    ? memorySamplePeakTotalBytes
                                    : snapshot.totalTrackedBytes();
      llvm::StringRef peakLargestFunc =
          (memorySampleCount > 0 && !memoryPeakLargestProcessFunc.empty())
              ? llvm::StringRef(memoryPeakLargestProcessFunc)
              : llvm::StringRef("-");
      os << "[circt-sim] Memory peak: samples=" << memorySampleCount
         << " sample_interval_steps=" << memorySampleIntervalSteps
         << " peak_step=" << peakStep
         << " peak_total_bytes=" << peakTotalBytes
         << " global_bytes=" << peakSnapshot.globalBytes
         << " malloc_bytes=" << peakSnapshot.mallocBytes
         << " native_bytes=" << peakSnapshot.nativeBytes
         << " process_bytes=" << peakSnapshot.processBytes
         << " dynamic_string_bytes=" << peakSnapshot.dynamicStringBytes
         << " config_db_bytes=" << peakSnapshot.configDbBytes
         << " analysis_conn_edges=" << peakSnapshot.analysisConnEdges
         << " seq_fifo_items=" << peakSnapshot.seqFifoItems
         << " largest_process=" << peakSnapshot.largestProcessId
         << " largest_process_bytes=" << peakSnapshot.largestProcessBytes
         << " largest_process_func=" << peakLargestFunc << "\n";
    }

    if (memorySampleHistory.size() >= 2) {
      const auto &start = memorySampleHistory.front();
      const auto &end = memorySampleHistory.back();
      auto delta = [](uint64_t from, uint64_t to) -> int64_t {
        if (to >= from)
          return static_cast<int64_t>(to - from);
        return -static_cast<int64_t>(from - to);
      };

      os << "[circt-sim] Memory delta window: samples="
         << memorySampleHistory.size()
         << " configured_window=" << memoryDeltaWindowSamples
         << " start_step=" << start.step
         << " end_step=" << end.step
         << " delta_total_bytes="
         << delta(start.snapshot.totalTrackedBytes(),
                  end.snapshot.totalTrackedBytes())
         << " delta_malloc_bytes="
         << delta(start.snapshot.mallocBytes, end.snapshot.mallocBytes)
         << " delta_native_bytes="
         << delta(start.snapshot.nativeBytes, end.snapshot.nativeBytes)
         << " delta_process_bytes="
         << delta(start.snapshot.processBytes, end.snapshot.processBytes)
         << " delta_dynamic_string_bytes="
         << delta(start.snapshot.dynamicStringBytes,
                  end.snapshot.dynamicStringBytes)
         << " delta_config_db_bytes="
         << delta(start.snapshot.configDbBytes, end.snapshot.configDbBytes)
         << " delta_analysis_conn_edges="
         << delta(start.snapshot.analysisConnEdges,
                  end.snapshot.analysisConnEdges)
         << " delta_seq_fifo_items="
         << delta(start.snapshot.seqFifoItems, end.snapshot.seqFifoItems)
         << " delta_global_blocks="
         << delta(start.snapshot.globalBlocks, end.snapshot.globalBlocks)
         << " delta_malloc_blocks="
         << delta(start.snapshot.mallocBlocks, end.snapshot.mallocBlocks)
         << " delta_native_blocks="
         << delta(start.snapshot.nativeBlocks, end.snapshot.nativeBlocks)
         << " delta_process_blocks="
         << delta(start.snapshot.processBlocks, end.snapshot.processBlocks)
         << " delta_dynamic_strings="
         << delta(start.snapshot.dynamicStrings, end.snapshot.dynamicStrings)
         << " delta_config_db_entries="
         << delta(start.snapshot.configDbEntries, end.snapshot.configDbEntries)
         << " delta_analysis_conn_ports="
         << delta(start.snapshot.analysisConnPorts,
                  end.snapshot.analysisConnPorts)
         << " delta_seq_fifo_maps="
         << delta(start.snapshot.seqFifoMaps, end.snapshot.seqFifoMaps)
         << "\n";
    }

    if (memorySummaryTopProcesses > 0 && !processStates.empty()) {
      llvm::SmallVector<std::pair<ProcessId, uint64_t>, 16> ranked;
      ranked.reserve(processStates.size());
      for (const auto &entry : processStates) {
        uint64_t bytes = 0;
        for (const auto &block : entry.second.memoryBlocks)
          bytes += block.second.size;
        ranked.push_back({entry.first, bytes});
      }
      llvm::sort(ranked, [](const auto &lhs, const auto &rhs) {
        if (lhs.second != rhs.second)
          return lhs.second > rhs.second;
        return lhs.first < rhs.first;
      });
      size_t limit = std::min<size_t>(memorySummaryTopProcesses, ranked.size());
      for (size_t i = 0; i < limit; ++i) {
        ProcessId pid = ranked[i].first;
        uint64_t bytes = ranked[i].second;
        llvm::StringRef procName = "-";
        if (const Process *proc = scheduler.getProcess(pid)) {
          if (!proc->getName().empty())
            procName = proc->getName();
        }
        llvm::StringRef funcName = "-";
        auto procIt = processStates.find(pid);
        if (procIt != processStates.end() &&
            !procIt->second.currentFuncName.empty())
          funcName = procIt->second.currentFuncName;

        os << "[circt-sim] Memory process top[" << i
           << "]: proc=" << pid
           << " bytes=" << bytes
           << " name=" << procName
           << " func=" << funcName << "\n";
      }
    }
  }

  os.flush();
}

void LLHDProcessInterpreter::rebuildAddrRangeIndex() {
  addrRangeIndex.clear();
  // Add global variable ranges
  for (auto &entry : globalAddresses) {
    StringRef globalName = entry.getKey();
    uint64_t baseAddr = entry.getValue();
    auto blockIt = globalMemoryBlocks.find(globalName);
    if (blockIt != globalMemoryBlocks.end()) {
      uint64_t endAddr = baseAddr + blockIt->second.size;
      addrRangeIndex[baseAddr] = {endAddr, globalName, false};
    }
  }
  // Add malloc block ranges
  for (auto &entry : mallocBlocks) {
    uint64_t baseAddr = entry.first;
    uint64_t endAddr = baseAddr + entry.second.size;
    addrRangeIndex[baseAddr] = {endAddr, {}, true};
  }
  addrRangeIndexDirty = false;
}

MemoryBlock *LLHDProcessInterpreter::findBlockByAddress(uint64_t addr,
                                                        uint64_t &offset) {
  if (addrRangeIndexDirty)
    rebuildAddrRangeIndex();

  // Binary search: find the last entry with baseAddr <= addr
  auto it = addrRangeIndex.upper_bound(addr);
  if (it == addrRangeIndex.begin())
    return nullptr;
  --it;

  if (addr < it->second.endAddr) {
    offset = addr - it->first;
    if (it->second.isMalloc) {
      auto blockIt = mallocBlocks.find(it->first);
      return (blockIt != mallocBlocks.end()) ? &blockIt->second : nullptr;
    } else {
      auto blockIt = globalMemoryBlocks.find(it->second.globalName);
      return (blockIt != globalMemoryBlocks.end()) ? &blockIt->second : nullptr;
    }
  }
  return nullptr;
}

void LLHDProcessInterpreter::createInterfaceFieldShadowSignals() {
  // For each llhd.sig whose initial value is a pointer (interface instance
  // pattern), scan GEP uses to discover the interface struct layout, then
  // create shadow signals for each field. This enables event-driven
  // sensitivity for processes that read interface fields from memory.

  LLVM_DEBUG(llvm::dbgs() << "createInterfaceFieldShadowSignals: valueToSignal="
                          << valueToSignal.size() << " instanceValueToSignal="
                          << instanceValueToSignal.size() << " childModuleCopyPairs="
                          << childModuleCopyPairs.size() << "\n");

  for (auto &[sigValue, sigId] : valueToSignal) {
    auto sigOp = sigValue.getDefiningOp<llhd::SignalOp>();
    if (!sigOp)
      continue;

    // Check if this signal holds a pointer (interface instance pattern).
    Type initType = sigOp.getInit().getType();
    if (!isa<LLVM::LLVMPointerType>(initType))
      continue;

    // Get the malloc'd address from the moduleInitValueMap.
    auto addrIt = moduleInitValueMap.find(sigOp.getInit());
    if (addrIt == moduleInitValueMap.end() || addrIt->second.isX()) {
      // Also try looking up via the signal's initial value in the scheduler.
      // The init SSA value may not be in moduleInitValueMap if the sig was
      // registered during registerSignals (before executeModuleLevelLLVMOps).
      // In that case, try the scheduler's signal value directly.
      const auto &sigVal = scheduler.getSignalValue(sigId);
      if (!sigVal.isUnknown() && sigVal.getWidth() >= 64) {
        uint64_t ptrAddr = sigVal.getValue();
        if (ptrAddr != 0) {
          // Found a non-zero pointer value in the signal. Use it.
          moduleInitValueMap[sigOp.getInit()] = InterpretedValue(ptrAddr, 64);
          addrIt = moduleInitValueMap.find(sigOp.getInit());
        }
      }
      if (addrIt == moduleInitValueMap.end() || addrIt->second.isX())
        continue;
    }
    uint64_t mallocAddr = addrIt->second.getUInt64();
    if (mallocAddr == 0)
      continue;

    // Scan all GEP operations in the module that use probes of this signal.
    // We look for patterns like:
    //   %ptr = llhd.prb %sig : !llvm.ptr
    //   %field = llvm.getelementptr %ptr[0, N] : ... !llvm.struct<"interface.*", ...>
    // The GEP's element type tells us the interface struct layout.
    LLVM::LLVMStructType ifaceStructTy;
    unsigned numUsers = 0, numProbes = 0, numGeps = 0;
    for (auto *user : sigOp.getResult().getUsers()) {
      ++numUsers;
      auto probeOp = dyn_cast<llhd::ProbeOp>(user);
      if (!probeOp)
        continue;
      ++numProbes;
      for (auto *probeUser : probeOp.getResult().getUsers()) {
        auto gepOp = dyn_cast<LLVM::GEPOp>(probeUser);
        if (!gepOp)
          continue;
        ++numGeps;
        if (auto elemTy = gepOp.getElemType()) {
          if (auto structTy = dyn_cast<LLVM::LLVMStructType>(elemTy)) {
            LLVM_DEBUG(llvm::dbgs() << "parent GEP struct name: '"
                                    << structTy.getName() << "'\n");
            if (structTy.getName().starts_with("interface.")) {
              ifaceStructTy = structTy;
              break;
            }
          }
        }
        if (ifaceStructTy)
          break;
      }
      if (ifaceStructTy)
        break;
    }
    LLVM_DEBUG(llvm::dbgs() << "parent sig " << sigId
                            << ": users=" << numUsers << " probes=" << numProbes
                            << " geps=" << numGeps
                            << " ifaceFound=" << (ifaceStructTy ? "yes" : "no")
                            << " addr=0x" << llvm::format_hex(mallocAddr, 10) << "\n");

    // Also check through unrealized_conversion_cast → GEP chains
    // (used when interface ptr is passed through module ports)
    if (!ifaceStructTy) {
      for (auto *user : sigOp.getResult().getUsers()) {
        auto probeOp = dyn_cast<llhd::ProbeOp>(user);
        if (!probeOp)
          continue;
        for (auto *castUser : probeOp.getResult().getUsers()) {
          auto castOp =
              dyn_cast<mlir::UnrealizedConversionCastOp>(castUser);
          if (!castOp)
            continue;
          // The cast result may be used as instance operand; check GEPs
          // from processes in child instances via their probe chains
          for (auto *castResultUser : castOp.getResult(0).getUsers()) {
            auto gepOp2 = dyn_cast<LLVM::GEPOp>(castResultUser);
            if (!gepOp2)
              continue;
            if (auto elemTy = gepOp2.getElemType()) {
              if (auto structTy = dyn_cast<LLVM::LLVMStructType>(elemTy)) {
                if (structTy.getName().starts_with("interface.")) {
                  ifaceStructTy = structTy;
                  break;
                }
              }
            }
          }
          if (ifaceStructTy)
            break;
        }
        if (ifaceStructTy)
          break;
      }
    }

    if (!ifaceStructTy)
      continue;

    // Skip if already processed (same malloc address from another signal).
    // Reuse existing field signals for sensitivity expansion.
    if (interfaceFieldSignals.count(mallocAddr)) {
      // Find the existing field signals and map this signal to them.
      auto body = ifaceStructTy.getBody();
      llvm::SmallVector<SignalId, 4> fieldSignals;
      unsigned fieldOffset = 0;
      for (unsigned i = 0; i < body.size(); ++i) {
        uint64_t fieldAddr = mallocAddr + fieldOffset;
        auto it = interfaceFieldSignals.find(fieldAddr);
        if (it != interfaceFieldSignals.end())
          fieldSignals.push_back(it->second);
        fieldOffset += getLLVMTypeSizeForGEP(body[i]);
      }
      if (!fieldSignals.empty())
        interfacePtrToFieldSignals[sigId] = std::move(fieldSignals);
      continue;
    }

    // Create shadow signals for each field in the interface struct.
    auto body = ifaceStructTy.getBody();
    std::string sigName = signalIdToName.count(sigId)
                              ? signalIdToName[sigId]
                              : "iface";
    unsigned fieldOffset = 0;
    llvm::SmallVector<SignalId, 4> fieldSignals;

    for (unsigned i = 0; i < body.size(); ++i) {
      Type fieldType = body[i];
      unsigned fieldSize = getLLVMTypeSizeForGEP(fieldType);
      unsigned fieldBitWidth = getTypeWidth(fieldType);

      std::string fieldSigName =
          sigName + ".field_" + std::to_string(i);
      SignalId fieldSigId = scheduler.registerSignal(
          fieldSigName, fieldBitWidth, getSignalEncoding(fieldType));
      signalIdToName[fieldSigId] = fieldSigName;
      signalIdToType[fieldSigId] = fieldType;

      // Don't initialize shadow signals from memory here. Leave them as
      // unknown (X) so that the first reconciliation pass creates proper
      // X→value transitions visible to processes waiting for edges.
      // This matches IEEE 1800 semantics where signals start at X.

      uint64_t fieldAddr = mallocAddr + fieldOffset;
      interfaceFieldSignals[fieldAddr] = fieldSigId;
      fieldSignalToAddr[fieldSigId] = fieldAddr;
      fieldSignals.push_back(fieldSigId);

      fieldOffset += fieldSize;
    }

    interfacePtrToFieldSignals[sigId] = std::move(fieldSignals);
  }

  // Also process child instance signals (BFM interface structs).
  for (auto &[instId, sigMap] : instanceValueToSignal) {
    for (auto &[sigValue, sigId] : sigMap) {
      auto sigOp = sigValue.getDefiningOp<llhd::SignalOp>();
      if (!sigOp)
        continue;

      Type initType = sigOp.getInit().getType();
      if (!isa<LLVM::LLVMPointerType>(initType))
        continue;

      // Get the malloc'd address — try moduleInitValueMap first, then signal
      auto addrIt = moduleInitValueMap.find(sigOp.getInit());
      if (addrIt == moduleInitValueMap.end() || addrIt->second.isX()) {
        const auto &sigVal = scheduler.getSignalValue(sigId);
        if (!sigVal.isUnknown() && sigVal.getWidth() >= 64) {
          uint64_t ptrAddr = sigVal.getValue();
          if (ptrAddr != 0) {
            moduleInitValueMap[sigOp.getInit()] =
                InterpretedValue(ptrAddr, 64);
            addrIt = moduleInitValueMap.find(sigOp.getInit());
          }
        }
        if (addrIt == moduleInitValueMap.end() || addrIt->second.isX())
          continue;
      }
      uint64_t mallocAddr = addrIt->second.getUInt64();
      if (mallocAddr == 0)
        continue;

      // Scan GEP uses to find interface struct type
      LLVM::LLVMStructType ifaceStructTy;
      for (auto *user : sigOp.getResult().getUsers()) {
        auto probeOp = dyn_cast<llhd::ProbeOp>(user);
        if (!probeOp)
          continue;
        for (auto *probeUser : probeOp.getResult().getUsers()) {
          auto gepOp = dyn_cast<LLVM::GEPOp>(probeUser);
          if (!gepOp)
            continue;
          if (auto elemTy = gepOp.getElemType()) {
            if (auto structTy = dyn_cast<LLVM::LLVMStructType>(elemTy)) {
              if (structTy.getName().starts_with("interface.")) {
                ifaceStructTy = structTy;
                break;
              }
            }
          }
          if (ifaceStructTy)
            break;
        }
        if (ifaceStructTy)
          break;
      }

      if (!ifaceStructTy)
        continue;

      // Skip if already processed (same malloc address from parent)
      auto body = ifaceStructTy.getBody();
      if (body.empty())
        continue;
      if (interfaceFieldSignals.count(mallocAddr))
        continue;

      std::string sigName =
          signalIdToName.count(sigId) ? signalIdToName[sigId] : "child_iface";
      unsigned fieldOffset = 0;
      llvm::SmallVector<SignalId, 4> fieldSignals;

      for (unsigned i = 0; i < body.size(); ++i) {
        Type fieldType = body[i];
        unsigned fieldSize = getLLVMTypeSizeForGEP(fieldType);
        unsigned fieldBitWidth = getTypeWidth(fieldType);

        std::string fieldSigName =
            sigName + ".field_" + std::to_string(i);
        SignalId fieldSigId = scheduler.registerSignal(
            fieldSigName, fieldBitWidth, getSignalEncoding(fieldType));
        signalIdToName[fieldSigId] = fieldSigName;
        signalIdToType[fieldSigId] = fieldType;

        // Don't initialize - leave as unknown for reconciliation pass.

        uint64_t fieldAddr = mallocAddr + fieldOffset;
        // Diagnostic: detect overwrite of interfaceFieldSignals entries
        auto prevIt = interfaceFieldSignals.find(fieldAddr);
        if (prevIt != interfaceFieldSignals.end() &&
            prevIt->second != fieldSigId) {
          llvm::errs() << "[IFACE-OVERWRITE] addr=0x"
                       << llvm::format_hex(fieldAddr, 10)
                       << " old sig=" << prevIt->second
                       << " new sig=" << fieldSigId << " ("
                       << fieldSigName << ")\n";
        }
        interfaceFieldSignals[fieldAddr] = fieldSigId;
        fieldSignalToAddr[fieldSigId] = fieldAddr;
        fieldSignals.push_back(fieldSigId);

        fieldOffset += fieldSize;
      }

      interfacePtrToFieldSignals[sigId] = std::move(fieldSignals);
    }
  }

}

void LLHDProcessInterpreter::dumpOpStats(llvm::raw_ostream &os,
                                         size_t topN) const {
  if (opStats.empty())
    return;

  llvm::SmallVector<std::pair<llvm::StringRef, uint64_t>, 16> entries;
  entries.reserve(opStats.size());
  for (const auto &entry : opStats)
    entries.push_back({entry.getKey(), entry.getValue()});

  llvm::sort(entries, [](const auto &lhs, const auto &rhs) {
    if (lhs.second != rhs.second)
      return lhs.second > rhs.second;
    return lhs.first < rhs.first;
  });

  os << "\n=== Op Stats (top " << topN << ") ===\n";
  size_t limit = std::min(topN, entries.size());
  for (size_t i = 0; i < limit; ++i) {
    os << entries[i].first << ": " << entries[i].second << "\n";
  }
  os << "========================\n";
}

void LLHDProcessInterpreter::dumpProcessStats(llvm::raw_ostream &os,
                                              size_t topN) const {
  if (processStates.empty())
    return;

  struct ProcEntry {
    ProcessId id;
    uint64_t steps;
    uint64_t funcBodySteps;
    size_t opCount;
    uint64_t cacheSkips;
    uint64_t sensCacheHits;
    llvm::StringRef name;
  };

  llvm::SmallVector<ProcEntry, 16> entries;
  entries.reserve(processStates.size());
  for (const auto &entry : processStates) {
    ProcessId procId = entry.first;
    const ProcessExecutionState &state = entry.second;
    llvm::StringRef name;
    if (const Process *proc = scheduler.getProcess(procId))
      name = proc->getName();
    size_t opCount = state.opCount;
    if (opCount == 0) {
      if (auto processOp = state.getProcessOp()) {
        opCount = countRegionOps(processOp.getBody());
      } else if (auto initialOp = state.getInitialOp()) {
        opCount = countRegionOps(initialOp.getBody());
      }
    }
    entries.push_back({procId, state.totalSteps, state.funcBodySteps, opCount,
                       state.cacheSkips, state.waitSensitivityCacheHits, name});
  }

  llvm::sort(entries, [](const ProcEntry &lhs, const ProcEntry &rhs) {
    if (lhs.steps != rhs.steps)
      return lhs.steps > rhs.steps;
    return lhs.id < rhs.id;
  });

  os << "\n=== Process Stats (top " << topN << ") ===\n";
  size_t limit = std::min(topN, entries.size());
  for (size_t i = 0; i < limit; ++i) {
    os << "proc " << entries[i].id;
    if (!entries[i].name.empty())
      os << " '" << entries[i].name << "'";
    os << " steps=" << entries[i].steps
       << " funcSteps=" << entries[i].funcBodySteps
       << " ops=" << entries[i].opCount
       << " skips=" << entries[i].cacheSkips
       << " sens_cache=" << entries[i].sensCacheHits << "\n";
  }
  os << "===========================\n";
}

LogicalResult LLHDProcessInterpreter::initialize(hw::HWModuleOp hwModule) {
  LLVM_DEBUG(llvm::dbgs() << "LLHDProcessInterpreter: Initializing for module '"
                          << hwModule.getName() << "'\n");

  ++topModuleCount;

  // Store the module name for hierarchical path construction
  moduleName = hwModule.getName().str();

  // Store the root module for symbol lookup
  rootModule = hwModule->getParentOfType<ModuleOp>();

  // === STACK OVERFLOW FIX ===
  // Use a single iterative pass to discover all operations instead of
  // multiple recursive walk() calls. This prevents stack overflow on
  // large designs (165k+ lines with deep nesting).
  DiscoveredOps discoveredOps;
  discoverOpsIteratively(hwModule, discoveredOps);

  // Register all signals first (using pre-discovered ops)
  if (failed(registerSignals(hwModule, discoveredOps)))
    return failure();

  // Register seq.firreg operations before processes (using pre-discovered ops).
  registerFirRegs(discoveredOps, 0, InstanceInputMapping{});

  // Export signals to MooreRuntime signal registry for DPI/VPI access
  exportSignalsToRegistry();

  // Then register all processes (using pre-discovered ops)
  if (failed(registerProcesses(discoveredOps)))
    return failure();

  // Recursively process child module instances EXCEPT module-level ops.
  // We must register child signals and instance mappings first so that
  // continuous assignments can resolve instance outputs.
  // Note: initializeChildInstances does its own iterative discovery for each child
  if (failed(initializeChildInstances(discoveredOps, 0)))
    return failure();

  // Register combinational processes for static module-level drives
  // (continuous assignments like port connections).
  registerContinuousAssignments(hwModule, 0, InstanceInputMapping{});

  // Discover global ops once, shared between initializeGlobals and
  // executeGlobalConstructors to avoid duplicate module walks.
  // Only discover once (first module); subsequent modules share the same root.
  if (cachedGlobalOps.ctors.empty() && cachedGlobalOps.globals.empty()) {
    discoverGlobalOpsIteratively(cachedGlobalOps);
  }

  // Initialize LLVM global variables (especially vtables) using iterative discovery
  if (failed(initializeGlobals(cachedGlobalOps)))
    return failure();

  // Pre-populate function lookup cache by walking the module symbol table once.
  // ModuleOp::lookupSymbol is O(n) per call (linear scan of all ops); by
  // building the cache here we turn all subsequent lookups into O(1) hash hits
  // during global constructor execution and simulation.
  if (rootModule) {
    for (Operation &op : *rootModule.getBody()) {
      if (auto llvmFunc = dyn_cast<LLVM::LLVMFuncOp>(&op)) {
        StringRef name = llvmFunc.getName();
        if (!funcLookupCache.count(name))
          funcLookupCache[name] = {llvmFunc.getOperation(), 0};
      } else if (auto funcOp = dyn_cast<func::FuncOp>(&op)) {
        StringRef name = funcOp.getName();
        if (!funcLookupCache.count(name))
          funcLookupCache[name] = {funcOp.getOperation(), 1};
      }
    }
    LLVM_DEBUG(llvm::dbgs()
               << "LLHDProcessInterpreter: Pre-cached "
               << funcLookupCache.size() << " function lookups\n");
  }

  inGlobalInit = true;

  // Initialize LLVM global variables (vtables etc.) - safe to run per-module,
  // initializeGlobals is idempotent for shared globals.
  // NOTE: executeGlobalConstructors is NOT called here. It triggers UVM
  // run_test() which starts build_phase, which needs config_db entries from
  // ALL modules' initial blocks. So global constructors are deferred to
  // finalizeInit(), called after all top modules have been initialized.

  // Execute module-level LLVM ops (alloca, call, store) that initialize
  // module-level variables like strings before processes start.
  // This includes hdl_top's initial blocks that call config_db::set().
  if (failed(executeModuleLevelLLVMOps(hwModule)))
    return failure();

  // Now execute deferred child module-level ops. These were saved during
  // initializeChildInstances() and must run AFTER executeModuleLevelLLVMOps()
  // so that parent signal values (malloc results etc.) are in the scheduler
  // when child modules probe parent signals.
  executeChildModuleLevelOps();

  // Create shadow signals for interface struct fields. This must happen after
  // both parent and child module-level ops so that all interface pointer
  // addresses are known.
  createInterfaceFieldShadowSignals();

  LLVM_DEBUG({
    if (!interfaceFieldSignals.empty()) {
      llvm::dbgs() << "[circt-sim] Interface field signals: "
                   << interfaceFieldSignals.size() << " entries\n";
      for (auto &[addr, sigId] : interfaceFieldSignals) {
        llvm::dbgs() << "  addr=0x" << llvm::format_hex(addr, 16)
                     << " -> signal " << sigId;
        auto nameIt = signalIdToName.find(sigId);
        if (nameIt != signalIdToName.end())
          llvm::dbgs() << " (" << nameIt->second << ")";
        llvm::dbgs() << "\n";
      }
    }
  });

  // Set up propagation links using recorded child module-level store patterns.
  // childModuleCopyPairs records (srcAddr, destAddr) pairs from store ops that
  // copy parent interface fields to child interface fields during init.
  bool traceInterfacePropagation = traceSeqEnabled || traceAnalysisEnabled;
  if (!childModuleCopyPairs.empty() && interfaceFieldSignals.size() > 1) {
    unsigned resolvedPairs = 0;
    unsigned unresolvedSrc = 0, unresolvedDest = 0;
    for (auto &[srcAddr, destAddr] : childModuleCopyPairs) {
      auto srcIt = interfaceFieldSignals.find(srcAddr);
      auto destIt = interfaceFieldSignals.find(destAddr);
      if (srcIt == interfaceFieldSignals.end()) {
        ++unresolvedSrc;
        continue;
      }
      if (destIt == interfaceFieldSignals.end()) {
        ++unresolvedDest;
        continue;
      }
      SignalId parentSigId = srcIt->second;
      SignalId childSigId = destIt->second;
      if (parentSigId == childSigId) {
        // Propagate childToParentFieldAddr entries for self-link pairs
        // so grandchild addresses inherit parent mappings.
        auto srcRevIt = childToParentFieldAddr.find(srcAddr);
        if (srcRevIt != childToParentFieldAddr.end())
          childToParentFieldAddr[destAddr] = srcRevIt->second;
        auto destRevIt = childToParentFieldAddr.find(destAddr);
        if (destRevIt != childToParentFieldAddr.end())
          childToParentFieldAddr[srcAddr] = destRevIt->second;
        continue;
      }

      interfaceFieldPropagation[parentSigId].push_back(childSigId);
      childToParentFieldAddr[destAddr] = srcAddr;
      ++resolvedPairs;
      if (traceInterfacePropagation) {
        llvm::errs() << "[circt-sim] CopyPair link: signal " << parentSigId
                     << " (0x" << llvm::format_hex(srcAddr, 16)
                     << ", w="
                     << scheduler.getSignalValue(parentSigId).getWidth()
                     << ") -> signal " << childSigId << " (0x"
                     << llvm::format_hex(destAddr, 16)
                     << ", w="
                     << scheduler.getSignalValue(childSigId).getWidth()
                     << ")\n";
      }
    }
    if (traceInterfacePropagation) {
      llvm::errs() << "[circt-sim] childModuleCopyPairs: "
                   << childModuleCopyPairs.size() << " total, "
                   << resolvedPairs << " resolved, "
                   << unresolvedSrc << " unresolved-src, "
                   << unresolvedDest << " unresolved-dest\n";
      llvm::errs() << "[circt-sim] childToParentFieldAddr has "
                   << childToParentFieldAddr.size() << " entries, "
                   << "interfaceFieldPropagation has "
                   << interfaceFieldPropagation.size() << " entries\n";
    }
  }

  // Auto-link child BFM interface structs to parent interfaces for signal
  // propagation. Each BFM gets its own interface struct copy (different malloc
  // address), but they represent the same bus signals. Without propagation
  // links, BFM loads return stale 0 values.
  //
  // Strategy: identify parent interfaces (from top-level valueToSignal) and
  // child interfaces (from instanceValueToSignal). Link each child's fields
  // to the parent with the most matching field widths.
  bool enableHeuristicAutoLink = false;
  if (const char *env = std::getenv("CIRCT_SIM_ENABLE_AUTO_IFACE_AUTOLINK")) {
    if (env[0] == '1' || env[0] == 'y' || env[0] == 'Y' || env[0] == 't' ||
        env[0] == 'T')
      enableHeuristicAutoLink = true;
  }
  if (enableHeuristicAutoLink && interfacePtrToFieldSignals.size() > 1) {
    // Dump all known interface signals for diagnostics.
    llvm::errs() << "[circt-sim] Interface signal dump: "
                 << interfacePtrToFieldSignals.size() << " total interfaces\n";
    for (auto &[ifaceSigId, fieldSigIds] : interfacePtrToFieldSignals) {
      llvm::errs() << "  Interface signal " << ifaceSigId
                   << " (" << (signalIdToName.count(ifaceSigId)
                               ? signalIdToName[ifaceSigId] : "unnamed")
                   << "): " << fieldSigIds.size() << " fields, widths=[";
      for (size_t i = 0; i < fieldSigIds.size(); ++i) {
        if (i > 0) llvm::errs() << ",";
        llvm::errs() << scheduler.getSignalValue(fieldSigIds[i]).getWidth();
      }
      llvm::errs() << "]\n";
    }

    // Identify parent interface signal IDs (from the top-level module).
    // These are in valueToSignal, not instanceValueToSignal.
    llvm::DenseSet<SignalId> parentIfaceSignals;
    for (auto &[sigValue, sigId] : valueToSignal) {
      if (interfacePtrToFieldSignals.count(sigId))
        parentIfaceSignals.insert(sigId);
    }
    llvm::errs() << "[circt-sim] Parent interface signals: "
                 << parentIfaceSignals.size() << " [";
    for (SignalId pid : parentIfaceSignals) {
      llvm::errs() << pid << " ";
    }
    llvm::errs() << "]\n";

    // Build instance-aware child→parent mapping. For each child interface
    // signal, find which instance it belongs to, and which parent interface
    // signal feeds that instance. This ensures correct linking when multiple
    // parents have identical structures (e.g., master and slave apb_if).
    llvm::DenseMap<SignalId, SignalId> childToInstanceParent;
    for (auto &[instId, sigMap] : instanceValueToSignal) {
      // Find which parent interface signals are inputs to this instance.
      llvm::SmallVector<SignalId, 2> instanceParents;
      for (auto &[sigVal, sigId] : sigMap) {
        if (parentIfaceSignals.contains(sigId))
          instanceParents.push_back(sigId);
      }
      if (instanceParents.empty())
        continue;
      // Map each child interface signal in this instance to its parent.
      // Use the first parent interface (instances typically have one parent
      // interface passed as input).
      SignalId instanceParentSigId = instanceParents[0];
      for (auto &[sigVal, sigId] : sigMap) {
        if (!parentIfaceSignals.contains(sigId) &&
            interfacePtrToFieldSignals.count(sigId)) {
          childToInstanceParent[sigId] = instanceParentSigId;
          llvm::errs() << "[circt-sim] Instance-aware: child " << sigId
                       << " -> parent " << instanceParentSigId << "\n";
        }
      }
    }

    // For each non-parent interface, link to its instance's parent interface.
    // Falls back to best-match-by-width for children without instance info.
    unsigned autoLinked = 0;
    for (auto &[childIfaceSigId, childFieldSigIds] :
         interfacePtrToFieldSignals) {
      if (parentIfaceSignals.contains(childIfaceSigId))
        continue;

      // Try instance-aware parent first.
      SignalId bestParentSigId = 0;
      int bestMatchCount = 0;
      auto instParentIt = childToInstanceParent.find(childIfaceSigId);
      if (instParentIt != childToInstanceParent.end()) {
        bestParentSigId = instParentIt->second;
        // Count matching fields for diagnostic output.
        auto parentIt = interfacePtrToFieldSignals.find(bestParentSigId);
        if (parentIt != interfacePtrToFieldSignals.end()) {
          auto &parentFieldSigIds = parentIt->second;
          unsigned numFields =
              std::min(childFieldSigIds.size(), parentFieldSigIds.size());
          for (unsigned i = 0; i < numFields; ++i) {
            unsigned childW =
                scheduler.getSignalValue(childFieldSigIds[i]).getWidth();
            unsigned parentW =
                scheduler.getSignalValue(parentFieldSigIds[i]).getWidth();
            if (childW == parentW && childW > 0)
              ++bestMatchCount;
          }
        }
      }

      // Fallback: best-match-by-width against all parents.
      if (bestParentSigId == 0) {
        for (SignalId parentSigId : parentIfaceSignals) {
          auto parentIt = interfacePtrToFieldSignals.find(parentSigId);
          if (parentIt == interfacePtrToFieldSignals.end())
            continue;
          auto &parentFieldSigIds = parentIt->second;

          unsigned numFields =
              std::min(childFieldSigIds.size(), parentFieldSigIds.size());
          int matchCount = 0;
          for (unsigned i = 0; i < numFields; ++i) {
            unsigned childW =
                scheduler.getSignalValue(childFieldSigIds[i]).getWidth();
            unsigned parentW =
                scheduler.getSignalValue(parentFieldSigIds[i]).getWidth();
            if (childW == parentW && childW > 0)
              ++matchCount;
          }
          if (matchCount > bestMatchCount) {
            bestMatchCount = matchCount;
            bestParentSigId = parentSigId;
          }
        }
      }

      if (bestParentSigId == 0 || bestMatchCount == 0)
        continue;

      // Create propagation links from best-matching parent → child.
      auto parentIt = interfacePtrToFieldSignals.find(bestParentSigId);
      auto &parentFieldSigIds = parentIt->second;
      unsigned numFields =
          std::min(childFieldSigIds.size(), parentFieldSigIds.size());
      for (unsigned i = 0; i < numFields; ++i) {
        SignalId childFSig = childFieldSigIds[i];
        SignalId parentFSig = parentFieldSigIds[i];
        unsigned childW = scheduler.getSignalValue(childFSig).getWidth();
        unsigned parentW = scheduler.getSignalValue(parentFSig).getWidth();
        if (childW != parentW || childW == 0)
          continue;

        interfaceFieldPropagation[parentFSig].push_back(childFSig);

        auto childAddrIt = fieldSignalToAddr.find(childFSig);
        auto parentAddrIt = fieldSignalToAddr.find(parentFSig);
        if (childAddrIt != fieldSignalToAddr.end() &&
            parentAddrIt != fieldSignalToAddr.end()) {
          childToParentFieldAddr[childAddrIt->second] =
              parentAddrIt->second;
        }
        ++autoLinked;
      }

      if (traceInterfacePropagation) {
        llvm::errs() << "[circt-sim] Auto-linked " << bestMatchCount
                     << " fields from child interface " << childIfaceSigId
                     << " to parent interface " << bestParentSigId << "\n";
      }
    }
    if (autoLinked > 0 && traceInterfacePropagation) {
      llvm::errs() << "[circt-sim] Total auto-linked " << autoLinked
                   << " BFM interface fields to parent interfaces\n";
    }
  }

  // Detect intra-interface field propagation links.
  // Some interfaces have internal "output" fields (e.g., txSclkOutput) that
  // are supposed to drive "public" fields (e.g., sclk) via always/initial
  // blocks. When these blocks are not imported from the Verilog source, the
  // bridge is missing. Detect such relationships by analyzing which parent
  // interface fields are targets of reverse propagation from child BFMs but
  // don't have forward propagation children, and link them to matching public
  // fields in the same interface.
  // Signals that receive intra-interface links are tracked so that forward
  // propagation cascading is only applied to them (avoiding double-propagation
  // for normal BFM fields that already have reverse propagation handlers).
  llvm::DenseSet<SignalId> intraLinkedSignals;
  if (!childToParentFieldAddr.empty() && !interfaceFieldPropagation.empty()) {
    // Collect interface fields that are destinations of cross-block copies
    // but have no forward propagation children of their own.
    // childToParentFieldAddr maps destAddr → srcAddr. For "reverse" copies
    // (BFM → parent interface), destAddr is the parent interface field and
    // srcAddr is the BFM field. We want the parent interface field as key.
    llvm::DenseMap<SignalId, llvm::SmallVector<SignalId, 2>> reverseTargets;
    for (auto &[destAddr, srcAddr] : childToParentFieldAddr) {
      auto destSigIt = interfaceFieldSignals.find(destAddr);
      auto srcSigIt = interfaceFieldSignals.find(srcAddr);
      if (destSigIt == interfaceFieldSignals.end() ||
          srcSigIt == interfaceFieldSignals.end())
        continue;
      // Only include cross-block entries (same-block = self-link).
      uint64_t destOff = 0, srcOff = 0;
      MemoryBlock *destBlk = findBlockByAddress(destAddr, destOff);
      MemoryBlock *srcBlk = findBlockByAddress(srcAddr, srcOff);
      if (!destBlk || !srcBlk || destBlk == srcBlk)
        continue;
      reverseTargets[destSigIt->second].push_back(srcSigIt->second);
    }

    // Group parent interface field signals by their memory block (interface).
    // Fields in the same interface struct share the same malloc'd block.
    llvm::DenseMap<MemoryBlock *, llvm::SmallVector<SignalId, 8>> ifaceGroups;
    for (auto &[addr, sigId] : interfaceFieldSignals) {
      uint64_t off = 0;
      MemoryBlock *blk = findBlockByAddress(addr, off);
      if (blk)
        ifaceGroups[blk].push_back(sigId);
    }

    if (traceInterfacePropagation) {
      llvm::errs() << "[circt-sim] Intra-link detection: "
                   << reverseTargets.size() << " reverse targets, "
                   << ifaceGroups.size() << " interface groups\n";
      for (auto &[sig, children] : reverseTargets) {
        std::string name = signalIdToName.count(sig) ? signalIdToName[sig] : "?";
        llvm::errs() << "  reverse target sig " << sig << " (" << name
                     << ") from " << children.size() << " children\n";
      }
    }

    unsigned intraLinks = 0;
    for (auto &[blk, fieldSigs] : ifaceGroups) {
      // Separate into "public" (has forward children) and "dangling" (reverse
      // target but no forward children).
      llvm::SmallVector<SignalId, 4> publicFields;
      llvm::SmallVector<SignalId, 4> danglingFields;

      for (SignalId sig : fieldSigs) {
        bool hasForwardChildren = false;
        auto propIt = interfaceFieldPropagation.find(sig);
        if (propIt != interfaceFieldPropagation.end() &&
            !propIt->second.empty())
          hasForwardChildren = true;

        bool isReverseTarget = reverseTargets.count(sig);

        if (isReverseTarget && !hasForwardChildren)
          danglingFields.push_back(sig);
        else if (hasForwardChildren)
          publicFields.push_back(sig);
      }

      if (traceInterfacePropagation) {
        llvm::errs() << "[circt-sim] Interface block: " << fieldSigs.size()
                     << " fields, " << publicFields.size() << " public, "
                     << danglingFields.size() << " dangling\n";
      }

      if (danglingFields.empty() || publicFields.empty())
        continue;

      // Only create intra-links for parent interface blocks (blocks whose
      // public fields drive children in 2+ distinct external blocks).
      // BFM blocks typically only drive 1 external block (the parent
      // interface), so they're excluded. This prevents creating spurious
      // intra-links within BFM structs.
      llvm::DenseSet<MemoryBlock *> childBlocks;
      for (SignalId pubSig : publicFields) {
        auto pubPropIt = interfaceFieldPropagation.find(pubSig);
        if (pubPropIt == interfaceFieldPropagation.end())
          continue;
        for (SignalId child : pubPropIt->second) {
          auto childAddrIt = fieldSignalToAddr.find(child);
          if (childAddrIt == fieldSignalToAddr.end())
            continue;
          uint64_t off = 0;
          MemoryBlock *cb = findBlockByAddress(childAddrIt->second, off);
          if (cb && cb != blk)
            childBlocks.insert(cb);
        }
      }

      if (traceInterfacePropagation) {
        llvm::errs() << "[circt-sim]   child blocks: "
                     << childBlocks.size() << "\n";
      }

      // Skip blocks that don't look like parent interfaces (< 2 child blocks).
      if (childBlocks.size() < 2)
        continue;

      // For each dangling reverse target, find matching public field(s) by
      // width. Use the child BFM's field ordering to disambiguate: the
      // dangling field's reverse-propagation source child signal and a
      // public field's forward-propagation child signal should be adjacent
      // fields in the same child BFM interface (output follows input).
      for (SignalId dangSig : danglingFields) {
        unsigned dangW = scheduler.getSignalValue(dangSig).getWidth();
        auto &childSources = reverseTargets[dangSig];
        SignalId bestPublicSig = 0;
        bool found = false;

        // For each child that writes to this dangling parent field,
        // find the child's field index and look for the adjacent input field.
        for (SignalId childSig : childSources) {
          uint64_t childAddr = fieldSignalToAddr.count(childSig)
                                   ? fieldSignalToAddr[childSig]
                                   : 0;
          if (!childAddr)
            continue;

          // Find the child field with the closest lower address in the
          // same memory block. This is the "adjacent input" field just
          // before the output field in the child's interface struct.
          uint64_t childOff = 0;
          MemoryBlock *childBlk = findBlockByAddress(childAddr, childOff);
          if (!childBlk)
            continue;

          uint64_t bestPrevAddr = 0;
          SignalId bestPrevSig = 0;
          bool foundPrev = false;
          for (auto &[fAddr, fSig] : interfaceFieldSignals) {
            if (fAddr >= childAddr)
              continue;
            uint64_t fOff = 0;
            MemoryBlock *fBlk = findBlockByAddress(fAddr, fOff);
            if (fBlk != childBlk)
              continue;
            if (!foundPrev || fAddr > bestPrevAddr) {
              bestPrevAddr = fAddr;
              bestPrevSig = fSig;
              foundPrev = true;
            }
          }
          if (!foundPrev)
            continue;

          // The prev child field is an input; find its parent source.
          // Check interfaceFieldPropagation: which parent has this prev
          // child as a forward-propagation target?
          for (SignalId pubSig : publicFields) {
            if (scheduler.getSignalValue(pubSig).getWidth() != dangW)
              continue;
            auto pubPropIt = interfaceFieldPropagation.find(pubSig);
            if (pubPropIt == interfaceFieldPropagation.end())
              continue;
            for (SignalId pubChild : pubPropIt->second) {
              if (pubChild == bestPrevSig) {
                bestPublicSig = pubSig;
                found = true;
                break;
              }
            }
            if (found)
              break;
          }
          if (found)
            break;
        }

        if (!found) {
          // Fallback: match by width alone if there's exactly one candidate.
          llvm::SmallVector<SignalId, 2> candidates;
          for (SignalId pubSig : publicFields) {
            if (scheduler.getSignalValue(pubSig).getWidth() == dangW)
              candidates.push_back(pubSig);
          }
          if (candidates.size() == 1) {
            bestPublicSig = candidates[0];
            found = true;
          }
        }

        if (found && bestPublicSig != 0) {
          // Add intra-interface link: dangling parent → public parent's
          // children. This makes the reverse propagation cascade through
          // the public field to all child BFMs.
          auto &publicChildren =
              interfaceFieldPropagation[bestPublicSig];
          auto &dangChildren = interfaceFieldPropagation[dangSig];
          for (SignalId child : publicChildren) {
            if (std::find(dangChildren.begin(), dangChildren.end(), child) ==
                dangChildren.end())
              dangChildren.push_back(child);
          }
          // Also add the public field itself so its signal gets updated.
          if (std::find(dangChildren.begin(), dangChildren.end(),
                        bestPublicSig) == dangChildren.end())
            dangChildren.push_back(bestPublicSig);

          intraLinkedSignals.insert(dangSig);
          ++intraLinks;
          if (traceInterfacePropagation) {
            std::string dangName = signalIdToName.count(dangSig)
                                       ? signalIdToName[dangSig]
                                       : "?";
            std::string pubName = signalIdToName.count(bestPublicSig)
                                      ? signalIdToName[bestPublicSig]
                                      : "?";
            llvm::errs() << "[circt-sim] Intra-interface link: " << dangSig
                         << " (" << dangName << ") -> " << bestPublicSig
                         << " (" << pubName << ") + "
                         << publicChildren.size() << " children\n";
          }
        }
      }
    }
    if (intraLinks > 0 && traceInterfacePropagation) {
      llvm::errs() << "[circt-sim] Added " << intraLinks
                   << " intra-interface field propagation links\n";
    }
  }

  // Diagnostic: dump the full interfaceFieldPropagation map.
  if (traceInterfacePropagation && !interfaceFieldPropagation.empty()) {
    llvm::errs() << "[circt-sim] interfaceFieldPropagation map ("
                 << interfaceFieldPropagation.size() << " parent fields):\n";
    for (auto &[parentSig, children] : interfaceFieldPropagation) {
      std::string parentName =
          signalIdToName.count(parentSig) ? signalIdToName[parentSig] : "?";
      llvm::errs() << "  parent sig " << parentSig << " (" << parentName
                   << ", w=" << scheduler.getSignalValue(parentSig).getWidth()
                   << ") -> " << children.size() << " children:";
      for (SignalId cid : children) {
        std::string childName =
            signalIdToName.count(cid) ? signalIdToName[cid] : "?";
        llvm::errs() << " " << cid << "(" << childName
                     << ",w=" << scheduler.getSignalValue(cid).getWidth()
                     << ")";
      }
      llvm::errs() << "\n";
    }
  }

  LLVM_DEBUG(llvm::dbgs() << "LLHDProcessInterpreter: Registered "
                          << getNumSignals() << " signals and "
                          << getNumProcesses() << " processes\n");

  return success();
}

LogicalResult LLHDProcessInterpreter::finalizeInit() {
  LLVM_DEBUG(llvm::dbgs()
             << "LLHDProcessInterpreter: finalizeInit - executing global "
                "constructors after all modules initialized\n");

  // Execute LLVM global constructors (e.g., __moore_global_init_uvm_pkg::uvm_top)
  // This triggers UVM run_test() → build_phase → config_db::get(), so it MUST
  // run AFTER all modules' executeModuleLevelLLVMOps() have completed (which
  // includes hdl_top's initial blocks that call config_db::set()).
  if (failed(executeGlobalConstructors(cachedGlobalOps)))
    return failure();

  inGlobalInit = false;

  // Reset terminationRequested after global init. During UVM initialization,
  // m_uvm_get_root() triggers uvm_fatal → die() → sim.terminate, which sets
  // terminationRequested = true. Without reset, all processes get killed.
  if (terminationRequested) {
    LLVM_DEBUG(llvm::dbgs()
               << "LLHDProcessInterpreter: clearing terminationRequested "
               << "set during global init\n");
    terminationRequested = false;
  }

  LLVM_DEBUG({
    llvm::dbgs() << "Signal table (signalIdToName=" << signalIdToName.size()
                 << ", valueToSignal=" << valueToSignal.size() << "):\n";
    for (const auto &kv : signalIdToName)
      llvm::dbgs() << "  signal " << kv.first << " = " << kv.second << "\n";
    for (const auto &instKv : instanceValueToSignal) {
      for (const auto &valKv : instKv.second) {
        llvm::dbgs() << "  inst[" << instKv.first << "] signal " << valKv.second;
        if (signalIdToName.count(valKv.second))
          llvm::dbgs() << " = " << signalIdToName[valKv.second];
        llvm::dbgs() << "\n";
      }
    }
  });

  // Set up signal change callback to re-evaluate module drives that depend
  // on signals (via llhd.prb in the combinational chain).
  {
    scheduler.setSignalChangeCallback(
        [this](SignalId sigId, const SignalValue &newVal) {
          executeModuleDrivesForSignal(sigId);
        });
    LLVM_DEBUG(llvm::dbgs() << "Registered signal change callback for "
                            << signalDependentModuleDrives.size()
                            << " signal-dependent module drive mappings\n");
  }

  return success();
}

LogicalResult
LLHDProcessInterpreter::initializeChildInstances(const DiscoveredOps &ops,
                                                 InstanceId parentInstanceId) {
  // Process all pre-discovered hw.instance operations (no walk() needed)
  for (hw::InstanceOp instOp : ops.instances) {
    // Get the referenced module name
    StringRef childModuleName = instOp.getReferencedModuleName();

    LLVM_DEBUG(llvm::dbgs() << "  Found instance '" << instOp.getInstanceName()
                            << "' of module '" << childModuleName << "'\n");

    // Look up the child module in the symbol table
    if (!rootModule) {
      LLVM_DEBUG(llvm::dbgs() << "    Warning: No root module for symbol lookup\n");
      continue;
    }

    auto childModule =
        rootModule.lookupSymbol<hw::HWModuleOp>(childModuleName);
    if (!childModule) {
      LLVM_DEBUG(llvm::dbgs() << "    Warning: Could not find module '"
                              << childModuleName << "'\n");
      continue;
    }

    InstanceId instanceId = nextInstanceId++;

    llvm::SmallVector<std::string, 8> outputNames;
    for (auto portInfo : childModule.getPortList()) {
      if (!portInfo.isInput())
        outputNames.push_back(portInfo.getName().str());
    }

    InstanceInputMapping instanceInputMap;
    llvm::SmallVector<std::pair<SignalId, InstanceOutputInfo>, 8>
        pendingInstanceOutputs;

    // Map child module input block arguments to parent signals for EACH instance.
    // This is needed so that when we evaluate instance outputs, the input mappings
    // are available (and to allow firreg reset init to see the parent signals).
    auto &childBody = childModule.getBody();
    if (!childBody.empty()) {
      for (auto portInfo : childModule.getPortList()) {
        if (!portInfo.isInput())
          continue;
        unsigned operandIdx = portInfo.argNum;
        if (operandIdx >= instOp.getNumOperands())
          continue;
        auto childArg = cast<mlir::BlockArgument>(
            childBody.getArgument(operandIdx));
        Value operand = instOp.getOperand(operandIdx);
        instanceInputMap.push_back({childArg, operand, parentInstanceId});
        SignalId sigId = 0;
        {
          ScopedInstanceContext scope(*this, parentInstanceId);
          sigId = resolveSignalId(operand);
        }
        if (sigId != 0) {
          instanceValueToSignal[instanceId][childArg] = sigId;
          LLVM_DEBUG(llvm::dbgs()
                     << "    Mapped child input '"
                     << portInfo.getName() << "' to signal " << sigId << "\n");
        }
      }
    }
    instanceInputMaps[instanceId] = instanceInputMap;

    // Map instance results to child module outputs for instance evaluation.
    if (auto *bodyBlock = childModule.getBodyBlock()) {
      if (auto outputOp =
              dyn_cast<hw::OutputOp>(bodyBlock->getTerminator())) {
        unsigned resultCount = instOp.getNumResults();
        unsigned outputCount = outputOp.getNumOperands();
        unsigned mapCount = std::min(resultCount, outputCount);
        for (unsigned i = 0; i < mapCount; ++i) {
          InstanceOutputInfo info;
          info.outputValue = outputOp.getOperand(i);
          info.inputMap = instanceInputMap;
          info.instanceId = instanceId;
          instanceOutputMap[parentInstanceId][instOp.getResult(i)] = info;
          std::string outName;
          if (i < outputNames.size() && !outputNames[i].empty())
            outName = outputNames[i];
          else
            outName = "out_" + std::to_string(i);
          std::string hierName =
              instOp.getInstanceName().str() + "." + outName;
          Type outType = outputOp.getOperand(i).getType();
          unsigned width = getTypeWidth(outType);
          SignalId outSigId =
              scheduler.registerSignal(hierName, width,
                                       getSignalEncoding(outType));
          valueToSignal[instOp.getResult(i)] = outSigId;
          signalIdToName[outSigId] = hierName;
          signalIdToType[outSigId] = unwrapSignalType(outType);

          pendingInstanceOutputs.push_back({outSigId, info});
        }
        if (resultCount != outputCount) {
          LLVM_DEBUG(llvm::dbgs()
                     << "    Warning: Instance output count mismatch for '"
                     << instOp.getInstanceName() << "' (results="
                     << resultCount << ", outputs=" << outputCount << ")\n");
        }
      }
    }

    DiscoveredOps childOps;
    auto cacheIt = discoveredOpsCache.find(childModuleName);
    if (cacheIt == discoveredOpsCache.end()) {
      discoverOpsIteratively(childModule, childOps);
      discoveredOpsCache.try_emplace(childModuleName, childOps);
    } else {
      childOps = cacheIt->second;
    }

    // Register signals from child module using pre-discovered ops (per instance)
    for (llhd::SignalOp sigOp : childOps.signals) {
      std::string name = sigOp.getName().value_or("").str();
      if (name.empty())
        name = "sig_" + std::to_string(valueToSignal.size());
      std::string hierName = instOp.getInstanceName().str() + "." + name;

      Type innerType = sigOp.getInit().getType();
      unsigned width = getTypeWidth(innerType);

      SignalId sigId =
          scheduler.registerSignal(hierName, width,
                                   getSignalEncoding(innerType));
      instanceValueToSignal[instanceId][sigOp.getResult()] = sigId;
      signalIdToName[sigId] = hierName;
      signalIdToType[sigId] = innerType;

      llvm::APInt initValue;
      if (getSignalInitValue(sigOp.getInit(), width, initValue)) {
        scheduler.updateSignal(sigId, SignalValue(initValue));
      } else {
        // For signals whose init value is a block argument (mapped from parent
        // instance), evaluate through the input mapping to get the actual value.
        // Without this, the signal starts as X (the default), which causes
        // firreg processes to see X clock/reset at their first execution.
        ScopedInstanceContext instScope(*this, instanceId);
        ScopedInputValueMap inputScope(*this, instanceInputMap);
        InterpretedValue evalInit = evaluateContinuousValue(sigOp.getInit());
        if (!evalInit.isX())
          scheduler.updateSignal(sigId, evalInit.toSignalValue());
      }

      LLVM_DEBUG(llvm::dbgs() << "    Registered child signal '" << hierName
                              << "' with ID " << sigId << "\n");
    }

    // Defer child module-level LLVM ops (malloc, GEP, load, store, probe)
    // to run AFTER executeModuleLevelLLVMOps(). This ensures that when child
    // modules probe parent signals, the parent signal values have already been
    // computed (e.g. malloc results stored into parent interface signals).
    deferredChildModuleOps.push_back(
        {childModule, instanceId, instanceInputMap, childOps, instOp});

    // Register seq.firreg operations for the child module (per instance).
    registerFirRegs(childOps, instanceId, instanceInputMap);

    // Register processes from child module using pre-discovered ops
    for (llhd::ProcessOp processOp : childOps.processes) {
      std::string procName = instOp.getInstanceName().str() + ".llhd_process_" +
                             std::to_string(processStates.size());

      ProcessExecutionState state(processOp);
      state.instanceId = instanceId;
      state.inputMap = instanceInputMap;
      state.cacheable = isProcessCacheableBody(processOp);
      ProcessId procId = scheduler.registerProcess(procName, []() {});
      if (auto *process = scheduler.getProcess(procId))
        process->setCallback([this, procId]() { executeProcess(procId); });

      state.currentBlock = &processOp.getBody().front();
      state.currentOp = state.currentBlock->begin();
      registerProcessState(procId, std::move(state));
      instanceOpToProcessId[instanceId][processOp.getOperation()] = procId;

      LLVM_DEBUG(llvm::dbgs() << "    Registered child process '" << procName
                              << "' with ID " << procId << "\n");

      scheduler.scheduleProcess(procId, SchedulingRegion::Active);
    }

    // Register module-level llhd.drv operations using pre-discovered ops.
    for (llhd::DriveOp driveOp : childOps.moduleDrives) {
      registerModuleDrive(driveOp, instanceId, instanceInputMap);
    }

    // Register seq.initial blocks from child module using pre-discovered ops
    for (seq::InitialOp initialOp : childOps.initials) {
      std::string initName = instOp.getInstanceName().str() + ".seq_initial_" +
                             std::to_string(processStates.size());

      ProcessExecutionState state(initialOp);
      state.instanceId = instanceId;
      state.inputMap = instanceInputMap;
      state.cacheable = false;
      ProcessId procId = scheduler.registerProcess(initName, []() {});
      if (auto *process = scheduler.getProcess(procId))
        process->setCallback([this, procId]() { executeProcess(procId); });

      state.currentBlock = initialOp.getBodyBlock();
      state.currentOp = state.currentBlock->begin();
      registerProcessState(procId, std::move(state));
      instanceOpToProcessId[instanceId][initialOp.getOperation()] = procId;

      LLVM_DEBUG(llvm::dbgs() << "    Registered child initial block '" << initName
                              << "' with ID " << procId << "\n");

      scheduler.scheduleProcess(procId, SchedulingRegion::Active);
    }

    // Recursively process child module's instances using discovered ops
    (void)initializeChildInstances(childOps, instanceId);

    // Process pendingInstanceOutputs for EACH instance. Each instance needs its
    // own output updates even if they reference the same child module outputs.
    for (const auto &pending : pendingInstanceOutputs) {
      InstanceOutputUpdate update;
      update.signalId = pending.first;
      update.outputValue = pending.second.outputValue;
      update.instanceId = pending.second.instanceId;
      update.inputMap = pending.second.inputMap;
      {
        ScopedInstanceContext instScope(*this, update.instanceId);
        if (update.inputMap.empty()) {
          collectProcessIds(update.outputValue, update.processIds);
        } else {
          ScopedInputValueMap scope(*this, update.inputMap);
          collectProcessIds(update.outputValue, update.processIds);
        }
      }
      instanceOutputUpdates.push_back(update);

      llvm::SmallVector<SignalId, 4> sourceSignals;
      {
        ScopedInstanceContext instScope(*this, update.instanceId);
        if (update.inputMap.empty()) {
          collectSignalIds(update.outputValue, sourceSignals);
        } else {
          ScopedInputValueMap scope(*this, update.inputMap);
          collectSignalIds(update.outputValue, sourceSignals);
        }
      }
      if (sourceSignals.empty() && update.processIds.empty()) {
        scheduleInstanceOutputUpdate(update.signalId, update.outputValue,
                                     update.instanceId,
                                     update.inputMap.empty()
                                         ? nullptr
                                         : &update.inputMap);
      } else if (!sourceSignals.empty()) {
        LLVM_DEBUG({
          llvm::dbgs() << "Instance output signal " << update.signalId
                       << " depends on " << sourceSignals.size()
                       << " source signals:";
          for (SignalId s : sourceSignals)
            llvm::dbgs() << " " << s;
          llvm::dbgs() << "\n";
        });
        std::string procName = "inst_out_" + std::to_string(update.signalId);
        auto inputMap = update.inputMap;
        InstanceId instanceId = update.instanceId;
        ProcessId procId = scheduler.registerProcess(
            procName, [this, signalId = update.signalId,
                       outputValue = update.outputValue, instanceId,
                       inputMap]() {
              scheduleInstanceOutputUpdate(
                  signalId, outputValue, instanceId,
                  inputMap.empty() ? nullptr : &inputMap);
            });
        auto *process = scheduler.getProcess(procId);
        if (process) {
          process->setCombinational(true);
          for (SignalId srcSigId : sourceSignals)
            scheduler.addSensitivity(procId, srcSigId);
        }
        scheduleInstanceOutputUpdate(update.signalId, update.outputValue,
                                     update.instanceId,
                                     update.inputMap.empty()
                                         ? nullptr
                                         : &update.inputMap);
        scheduler.scheduleProcess(procId, SchedulingRegion::Active);
      }
    }

    // Register combinational processes for static module-level drives in child.
    // This MUST happen after input mapping so that collectSignalIds can resolve
    // child input block arguments to parent signals for proper sensitivity setup.
    registerContinuousAssignments(childModule, instanceId, instanceInputMap);
  }

  return success();
}

//===----------------------------------------------------------------------===//
// Helper Functions
//===----------------------------------------------------------------------===//

static bool isProcessCacheableBody(Operation *op) {
  bool cacheable = true;
  op->walk([&](Operation *nestedOp) {
    if (isa<sim::TerminateOp, sim::PrintFormattedProcOp, sim::SimForkOp,
            sim::SimJoinOp, sim::SimJoinAnyOp, sim::SimDisableForkOp,
            llhd::HaltOp, seq::YieldOp>(nestedOp)) {
      cacheable = false;
      return WalkResult::interrupt();
    }
    if (dyn_cast<CallOpInterface>(nestedOp)) {
      cacheable = false;
      return WalkResult::interrupt();
    }
    return WalkResult::advance();
  });
  return cacheable;
}

/// Safe insertBits that clamps instead of asserting when the sub-value
/// extends beyond the target's bit width.
static void safeInsertBits(llvm::APInt &target, const llvm::APInt &source,
                           unsigned bitPosition) {
  unsigned subWidth = source.getBitWidth();
  unsigned targetWidth = target.getBitWidth();
  if (bitPosition >= targetWidth) {
    LLVM_DEBUG(llvm::dbgs() << "insertBits clamp: bitPosition (" << bitPosition
                            << ") >= targetWidth (" << targetWidth
                            << "), skipping\n");
    return;
  }
  if (subWidth + bitPosition > targetWidth) {
    // Truncate the source to fit
    unsigned availBits = targetWidth - bitPosition;
    LLVM_DEBUG(llvm::dbgs() << "insertBits clamp: subWidth " << subWidth
                            << " -> " << availBits
                            << " (targetWidth=" << targetWidth
                            << " bitPos=" << bitPosition << ")\n");
    target.insertBits(source.trunc(availBits), bitPosition);
    return;
  }
  target.insertBits(source, bitPosition);
}

/// Flatten an aggregate constant (struct or array) into a single APInt.
/// This is used for initializing signals with aggregate types.
/// For 4-state logic, structs typically have the form {value, unknown}.
static Type stripTypeAliases(Type type) {
  while (auto alias = dyn_cast<hw::TypeAliasType>(type))
    type = alias.getInnerType();
  return type;
}

static APInt flattenAggregateAttr(Attribute fieldAttr, Type fieldType) {
  fieldType = stripTypeAliases(fieldType);
  unsigned fieldWidth = LLHDProcessInterpreter::getTypeWidth(fieldType);
  APInt result(fieldWidth, 0);

  if (auto intAttr = dyn_cast<IntegerAttr>(fieldAttr)) {
    APInt fieldValue = intAttr.getValue();
    if (fieldValue.getBitWidth() < fieldWidth)
      fieldValue = fieldValue.zext(fieldWidth);
    else if (fieldValue.getBitWidth() > fieldWidth)
      fieldValue = fieldValue.trunc(fieldWidth);
    return fieldValue;
  }

  auto arrayAttr = dyn_cast<ArrayAttr>(fieldAttr);
  if (!arrayAttr)
    return result;

  if (auto structType = dyn_cast<hw::StructType>(fieldType)) {
    auto elements = structType.getElements();
    unsigned bitOffset = fieldWidth;

    for (size_t i = 0; i < arrayAttr.size() && i < elements.size(); ++i) {
      unsigned elemWidth =
          LLHDProcessInterpreter::getTypeWidth(elements[i].type);
      bitOffset -= elemWidth;
      APInt elemValue = flattenAggregateAttr(arrayAttr[i], elements[i].type);
      if (elemValue.getBitWidth() < elemWidth)
        elemValue = elemValue.zext(elemWidth);
      else if (elemValue.getBitWidth() > elemWidth)
        elemValue = elemValue.trunc(elemWidth);
      safeInsertBits(result,elemValue, bitOffset);
    }
    return result;
  }

  if (auto arrayType = dyn_cast<hw::ArrayType>(fieldType)) {
    unsigned elementWidth =
        LLHDProcessInterpreter::getTypeWidth(arrayType.getElementType());
    unsigned bitOffset = fieldWidth;

    for (Attribute elemAttr : arrayAttr) {
      bitOffset -= elementWidth;
      APInt elemValue =
          flattenAggregateAttr(elemAttr, arrayType.getElementType());
      if (elemValue.getBitWidth() < elementWidth)
        elemValue = elemValue.zext(elementWidth);
      else if (elemValue.getBitWidth() > elementWidth)
        elemValue = elemValue.trunc(elementWidth);
      safeInsertBits(result,elemValue, bitOffset);
    }
  }

  return result;
}

static APInt flattenAggregateConstant(hw::AggregateConstantOp aggConstOp) {
  return flattenAggregateAttr(aggConstOp.getFields(),
                              aggConstOp.getResult().getType());
}

static size_t countRegionOps(mlir::Region &region) {
  llvm::SmallVector<mlir::Region *, 16> regionWorklist;
  regionWorklist.push_back(&region);
  size_t count = 0;

  while (!regionWorklist.empty()) {
    mlir::Region *curRegion = regionWorklist.pop_back_val();
    for (mlir::Block &block : *curRegion) {
      for (mlir::Operation &op : block) {
        ++count;
        for (mlir::Region &nested : op.getRegions())
          regionWorklist.push_back(&nested);
      }
    }
  }

  return count;
}

/// Extract an initial APInt value from a signal init operand if possible.
/// Returns true if a constant value was found and normalized to the signal width.
static bool getSignalInitValue(Value initValue, unsigned width,
                               llvm::APInt &outValue) {
  if (auto constOp = initValue.getDefiningOp<hw::ConstantOp>()) {
    outValue = constOp.getValue();
  } else if (auto aggConstOp =
                 initValue.getDefiningOp<hw::AggregateConstantOp>()) {
    outValue = flattenAggregateConstant(aggConstOp);
  } else if (auto bitcastOp = initValue.getDefiningOp<hw::BitcastOp>()) {
    if (auto constOp = bitcastOp.getInput().getDefiningOp<hw::ConstantOp>()) {
      outValue = constOp.getValue();
    } else if (auto aggConstOp = bitcastOp.getInput()
                                     .getDefiningOp<hw::AggregateConstantOp>()) {
      outValue = flattenAggregateConstant(aggConstOp);
    } else {
      return false;
    }
  } else {
    return false;
  }

  if (outValue.getBitWidth() < width)
    outValue = outValue.zext(width);
  else if (outValue.getBitWidth() > width)
    outValue = outValue.trunc(width);
  return true;
}

/// Normalize two APInt values to have the same bit width for binary operations.
/// If the widths differ, both are extended/truncated to the target width.
/// This prevents assertion failures in APInt binary operators that require
/// matching bit widths.
static void normalizeWidths(llvm::APInt &lhs, llvm::APInt &rhs,
                            unsigned targetWidth) {
  // Adjust lhs to target width
  if (lhs.getBitWidth() < targetWidth) {
    lhs = lhs.zext(targetWidth);
  } else if (lhs.getBitWidth() > targetWidth) {
    lhs = lhs.trunc(targetWidth);
  }

  // Adjust rhs to target width
  if (rhs.getBitWidth() < targetWidth) {
    rhs = rhs.zext(targetWidth);
  } else if (rhs.getBitWidth() > targetWidth) {
    rhs = rhs.trunc(targetWidth);
  }
}

//===----------------------------------------------------------------------===//
// Iterative Operation Discovery (Stack Overflow Prevention)
//===----------------------------------------------------------------------===//

void LLHDProcessInterpreter::discoverOpsIteratively(hw::HWModuleOp hwModule,
                                                     DiscoveredOps &ops) {
  // Use an explicit worklist to traverse operations iteratively instead of
  // using walk(), which is recursive and causes stack overflow on large designs.
  // This single pass replaces 17+ separate walk() calls.

  llvm::SmallVector<Operation *, 256> worklist;
  llvm::SmallVector<Region *, 64> regionWorklist;

  // Start with the module's body region
  regionWorklist.push_back(&hwModule.getBody());

  while (!regionWorklist.empty()) {
    Region *region = regionWorklist.pop_back_val();

    // Process all blocks in this region
    for (Block &block : *region) {
      // Process all operations in this block
      for (Operation &op : block) {
        // Classify the operation by type
        if (auto instOp = dyn_cast<hw::InstanceOp>(&op)) {
          ops.instances.push_back(instOp);
        } else if (auto sigOp = dyn_cast<llhd::SignalOp>(&op)) {
          ops.signals.push_back(sigOp);
        } else if (auto outputOp = dyn_cast<llhd::OutputOp>(&op)) {
          ops.outputs.push_back(outputOp);
        } else if (auto processOp = dyn_cast<llhd::ProcessOp>(&op)) {
          ops.processes.push_back(processOp);
          // Don't recurse into process bodies for discovering module-level ops
        } else if (auto combOp = dyn_cast<llhd::CombinationalOp>(&op)) {
          ops.combinationals.push_back(combOp);
          // Don't recurse into combinational bodies
        } else if (auto initialOp = dyn_cast<seq::InitialOp>(&op)) {
          ops.initials.push_back(initialOp);
          // Don't recurse into initial bodies
        } else if (auto driveOp = dyn_cast<llhd::DriveOp>(&op)) {
          // Only collect module-level drives (not inside processes/initials)
          if (!op.getParentOfType<llhd::ProcessOp>() &&
              !op.getParentOfType<seq::InitialOp>()) {
            ops.moduleDrives.push_back(driveOp);
          }
        } else if (auto firRegOp = dyn_cast<seq::FirRegOp>(&op)) {
          ops.firRegs.push_back(firRegOp);
        }

        // Add nested regions to worklist (but skip process/initial/combinational bodies
        // since we don't want to discover ops inside those as module-level)
        if (!isa<llhd::ProcessOp, seq::InitialOp, llhd::CombinationalOp>(&op)) {
          for (Region &nestedRegion : op.getRegions()) {
            regionWorklist.push_back(&nestedRegion);
          }
        }
      }
    }
  }

  LLVM_DEBUG(llvm::dbgs() << "  Iterative discovery found: "
                          << ops.instances.size() << " instances, "
                          << ops.signals.size() << " signals, "
                          << ops.outputs.size() << " outputs, "
                          << ops.processes.size() << " processes, "
                          << ops.combinationals.size() << " combinationals, "
                          << ops.initials.size() << " initials, "
                          << ops.moduleDrives.size() << " module drives, "
                          << ops.firRegs.size() << " firRegs\n");
}

void LLHDProcessInterpreter::discoverGlobalOpsIteratively(
    DiscoveredGlobalOps &ops) {
  if (!rootModule)
    return;

  // Use an explicit worklist to traverse operations iteratively
  llvm::SmallVector<Region *, 64> regionWorklist;
  regionWorklist.push_back(&rootModule.getBodyRegion());

  while (!regionWorklist.empty()) {
    Region *region = regionWorklist.pop_back_val();

    for (Block &block : *region) {
      for (Operation &op : block) {
        // Classify global operations
        if (auto globalOp = dyn_cast<LLVM::GlobalOp>(&op)) {
          ops.globals.push_back(globalOp);
        } else if (auto ctorsOp = dyn_cast<LLVM::GlobalCtorsOp>(&op)) {
          ops.ctors.push_back(ctorsOp);
        }

        // Add nested regions (but skip hw.module bodies - we process those separately)
        if (!isa<hw::HWModuleOp>(&op)) {
          for (Region &nestedRegion : op.getRegions()) {
            regionWorklist.push_back(&nestedRegion);
          }
        }
      }
    }
  }

  LLVM_DEBUG(llvm::dbgs() << "  Global discovery found: "
                          << ops.globals.size() << " globals, "
                          << ops.ctors.size() << " global ctors\n");
}

//===----------------------------------------------------------------------===//
// Signal Registration
//===----------------------------------------------------------------------===//

LogicalResult LLHDProcessInterpreter::registerSignals(
    hw::HWModuleOp hwModule, const DiscoveredOps &ops) {
  // First, register module ports that are ref types (signal references)
  for (auto portInfo : hwModule.getPortList()) {
    if (auto refType = dyn_cast<llhd::RefType>(portInfo.type)) {
      std::string name = portInfo.getName().str();
      Type innerType = refType.getNestedType();
      unsigned width = getTypeWidth(innerType);

      SignalId sigId =
          scheduler.registerSignal(name, width, getSignalEncoding(innerType));
      signalIdToName[sigId] = name;
      signalIdToType[sigId] = innerType;

      // Map the block argument to the signal
      if (portInfo.isInput()) {
        auto &body = hwModule.getBody();
        if (!body.empty()) {
          Value arg = body.getArgument(portInfo.argNum);
          valueToSignal[arg] = sigId;
          LLVM_DEBUG(llvm::dbgs() << "  Registered port signal '" << name
                                  << "' with ID " << sigId << " (width=" << width
                                  << ")\n");
        }
      }
    }
  }

  // Register all pre-discovered llhd.sig operations (no walk() needed)
  for (llhd::SignalOp sigOp : ops.signals) {
    registerSignal(sigOp);
  }

  // Register all pre-discovered llhd.output operations (no walk() needed)
  for (llhd::OutputOp outputOp : ops.outputs) {
    // llhd.output creates a signal implicitly
    std::string name = outputOp.getName().value_or("").str();
    if (name.empty()) {
      name = "output_" + std::to_string(valueToSignal.size());
    }

    Type innerType = outputOp.getValue().getType();
    unsigned width = getTypeWidth(innerType);

    SignalId sigId =
        scheduler.registerSignal(name, width, getSignalEncoding(innerType));
    valueToSignal[outputOp.getResult()] = sigId;
    signalIdToName[sigId] = name;
    signalIdToType[sigId] = innerType;

    LLVM_DEBUG(llvm::dbgs() << "  Registered output signal '" << name
                            << "' with ID " << sigId << " (width=" << width
                            << ")\n");
  }

  return success();
}

SignalId LLHDProcessInterpreter::registerSignal(llhd::SignalOp sigOp) {
  // Get signal name - use the optional name attribute if present
  std::string name = sigOp.getName().value_or("").str();
  if (name.empty()) {
    // Generate a name based on the SSA value
    name = "sig_" + std::to_string(valueToSignal.size());
  }

  // Get the type of the signal (the inner type, not the ref type)
  Type innerType = sigOp.getInit().getType();
  unsigned width = getTypeWidth(innerType);

  // Check for resolution attribute (wand/wor nets).
  SignalResolution resolution = SignalResolution::Default;
  if (auto resAttr = sigOp->getAttrOfType<mlir::StringAttr>("circt.resolution")) {
    if (resAttr.getValue() == "wired_and")
      resolution = SignalResolution::WiredAnd;
    else if (resAttr.getValue() == "wired_or")
      resolution = SignalResolution::WiredOr;
  }

  // Register with the scheduler
  SignalId sigId =
      scheduler.registerSignal(name, width, getSignalEncoding(innerType),
                               resolution);

  // Store the mapping
  valueToSignal[sigOp.getResult()] = sigId;
  signalIdToName[sigId] = name;
  signalIdToType[sigId] = innerType;

  llvm::APInt initValue;
  if (getSignalInitValue(sigOp.getInit(), width, initValue)) {
    scheduler.updateSignal(sigId, SignalValue(initValue));
    LLVM_DEBUG(llvm::dbgs() << "  Set initial value to " << initValue << "\n");
  }

  LLVM_DEBUG(llvm::dbgs() << "  Registered signal '" << name << "' with ID "
                          << sigId << " (width=" << width << ")\n");

  return sigId;
}

SignalId LLHDProcessInterpreter::getSignalId(Value signalRef) const {
  SignalId sigId = getSignalIdInInstance(signalRef, activeInstanceId);
  if (sigId != 0)
    return sigId;
  SignalId uniqueSigId = 0;
  for (const auto &ctx : instanceValueToSignal) {
    auto instIt = ctx.second.find(signalRef);
    if (instIt == ctx.second.end())
      continue;
    if (uniqueSigId != 0 && uniqueSigId != instIt->second)
      return 0;
    uniqueSigId = instIt->second;
  }
  if (uniqueSigId != 0)
    return uniqueSigId;
  return 0; // Invalid signal ID
}

SignalId LLHDProcessInterpreter::getSignalIdInInstance(Value signalRef,
                                                       InstanceId instanceId) const {
  if (instanceId != 0) {
    auto ctxIt = instanceValueToSignal.find(instanceId);
    if (ctxIt != instanceValueToSignal.end()) {
      auto it = ctxIt->second.find(signalRef);
      if (it != ctxIt->second.end())
        return it->second;
    }
  }
  auto it = valueToSignal.find(signalRef);
  if (it != valueToSignal.end())
    return it->second;
  return 0; // Invalid signal ID
}

llvm::StringRef LLHDProcessInterpreter::getSignalName(SignalId id) const {
  auto it = signalIdToName.find(id);
  if (it != signalIdToName.end())
    return it->second;
  return "";
}

Type LLHDProcessInterpreter::getSignalValueType(SignalId sigId) const {
  auto it = signalIdToType.find(sigId);
  if (it != signalIdToType.end())
    return it->second;
  for (const auto &entry : valueToSignal) {
    if (entry.second == sigId)
      return unwrapSignalType(entry.first.getType());
  }
  for (const auto &ctx : instanceValueToSignal) {
    for (const auto &entry : ctx.second) {
      if (entry.second == sigId)
        return unwrapSignalType(entry.first.getType());
    }
  }
  return Type();
}

static llvm::APInt adjustAPIntWidth(llvm::APInt value, unsigned targetWidth) {
  if (value.getBitWidth() == targetWidth)
    return value;
  if (value.getBitWidth() < targetWidth)
    return value.zext(targetWidth);
  return value.trunc(targetWidth);
}

llvm::APInt LLHDProcessInterpreter::convertLLVMToHWLayout(
    llvm::APInt value, Type llvmType, Type hwType) const {
  unsigned llvmWidth = getTypeWidth(llvmType);
  unsigned hwWidth = getTypeWidth(hwType);
  value = adjustAPIntWidth(value, llvmWidth);

  if (auto llvmStructType = dyn_cast<LLVM::LLVMStructType>(llvmType)) {
    if (auto hwStructType = dyn_cast<hw::StructType>(hwType)) {
      APInt result = APInt::getZero(hwWidth);
      auto hwElements = hwStructType.getElements();
      auto llvmBody = llvmStructType.getBody();
      size_t count = std::min(hwElements.size(), llvmBody.size());

      unsigned llvmOffset = 0;
      unsigned hwOffset = hwWidth;
      for (size_t i = 0; i < count; ++i) {
        unsigned llvmFieldWidth = getTypeWidth(llvmBody[i]);
        unsigned hwFieldWidth = getTypeWidth(hwElements[i].type);
        hwOffset -= hwFieldWidth;
        APInt fieldBits = value.extractBits(llvmFieldWidth, llvmOffset);
        APInt converted =
            convertLLVMToHWLayout(fieldBits, llvmBody[i], hwElements[i].type);
        converted = adjustAPIntWidth(converted, hwFieldWidth);
        safeInsertBits(result,converted, hwOffset);
        llvmOffset += llvmFieldWidth;
      }
      return adjustAPIntWidth(result, hwWidth);
    }
  }

  if (auto llvmArrayType = dyn_cast<LLVM::LLVMArrayType>(llvmType)) {
    if (auto hwArrayType = dyn_cast<hw::ArrayType>(hwType)) {
      unsigned llvmElemWidth = getTypeWidth(llvmArrayType.getElementType());
      unsigned hwElemWidth = getTypeWidth(hwArrayType.getElementType());
      unsigned numElements = hwArrayType.getNumElements();
      unsigned llvmElements = llvmArrayType.getNumElements();
      size_t count = std::min(numElements, llvmElements);

      APInt result = APInt::getZero(hwWidth);
      for (size_t i = 0; i < count; ++i) {
        unsigned llvmOffset = i * llvmElemWidth;
        unsigned hwOffset = (numElements - 1 - i) * hwElemWidth;
        APInt fieldBits = value.extractBits(llvmElemWidth, llvmOffset);
        APInt converted = convertLLVMToHWLayout(
            fieldBits, llvmArrayType.getElementType(),
            hwArrayType.getElementType());
        converted = adjustAPIntWidth(converted, hwElemWidth);
        safeInsertBits(result,converted, hwOffset);
      }
      return adjustAPIntWidth(result, hwWidth);
    }
  }

  return adjustAPIntWidth(value, hwWidth);
}

llvm::APInt LLHDProcessInterpreter::convertHWToLLVMLayout(
    llvm::APInt value, Type hwType, Type llvmType) const {
  unsigned hwWidth = getTypeWidth(hwType);
  unsigned llvmWidth = getTypeWidth(llvmType);
  value = adjustAPIntWidth(value, hwWidth);

  if (auto hwStructType = dyn_cast<hw::StructType>(hwType)) {
    if (auto llvmStructType = dyn_cast<LLVM::LLVMStructType>(llvmType)) {
      APInt result = APInt::getZero(llvmWidth);
      auto hwElements = hwStructType.getElements();
      auto llvmBody = llvmStructType.getBody();
      size_t count = std::min(hwElements.size(), llvmBody.size());

      unsigned hwOffset = hwWidth;
      unsigned llvmOffset = 0;
      for (size_t i = 0; i < count; ++i) {
        unsigned hwFieldWidth = getTypeWidth(hwElements[i].type);
        unsigned llvmFieldWidth = getTypeWidth(llvmBody[i]);
        hwOffset -= hwFieldWidth;
        APInt fieldBits = value.extractBits(hwFieldWidth, hwOffset);
        APInt converted = convertHWToLLVMLayout(
            fieldBits, hwElements[i].type, llvmBody[i]);
        converted = adjustAPIntWidth(converted, llvmFieldWidth);
        safeInsertBits(result,converted, llvmOffset);
        llvmOffset += llvmFieldWidth;
      }
      return adjustAPIntWidth(result, llvmWidth);
    }
  }

  if (auto hwArrayType = dyn_cast<hw::ArrayType>(hwType)) {
    if (auto llvmArrayType = dyn_cast<LLVM::LLVMArrayType>(llvmType)) {
      unsigned hwElemWidth = getTypeWidth(hwArrayType.getElementType());
      unsigned llvmElemWidth = getTypeWidth(llvmArrayType.getElementType());
      unsigned numElements = hwArrayType.getNumElements();
      unsigned llvmElements = llvmArrayType.getNumElements();
      size_t count = std::min(numElements, llvmElements);

      APInt result = APInt::getZero(llvmWidth);
      for (size_t i = 0; i < count; ++i) {
        unsigned hwOffset = (numElements - 1 - i) * hwElemWidth;
        unsigned llvmOffset = i * llvmElemWidth;
        APInt fieldBits = value.extractBits(hwElemWidth, hwOffset);
        APInt converted = convertHWToLLVMLayout(
            fieldBits, hwArrayType.getElementType(),
            llvmArrayType.getElementType());
        converted = adjustAPIntWidth(converted, llvmElemWidth);
        safeInsertBits(result,converted, llvmOffset);
      }
      return adjustAPIntWidth(result, llvmWidth);
    }
  }

  return adjustAPIntWidth(value, llvmWidth);
}

llvm::APInt LLHDProcessInterpreter::convertLLVMToHWLayoutByHWType(
    llvm::APInt value, Type hwType) const {
  if (auto refType = dyn_cast<llhd::RefType>(hwType))
    hwType = refType.getNestedType();

  unsigned hwWidth = getTypeWidth(hwType);
  value = adjustAPIntWidth(value, hwWidth);

  if (auto hwStructType = dyn_cast<hw::StructType>(hwType)) {
    APInt result = APInt::getZero(hwWidth);
    auto hwElements = hwStructType.getElements();

    unsigned llvmOffset = 0;
    unsigned hwOffset = hwWidth;
    for (auto element : hwElements) {
      unsigned fieldWidth = getTypeWidth(element.type);
      hwOffset -= fieldWidth;
      APInt fieldBits = value.extractBits(fieldWidth, llvmOffset);
      APInt converted =
          convertLLVMToHWLayoutByHWType(fieldBits, element.type);
      converted = adjustAPIntWidth(converted, fieldWidth);
      safeInsertBits(result,converted, hwOffset);
      llvmOffset += fieldWidth;
    }
    return result;
  }

  if (auto hwArrayType = dyn_cast<hw::ArrayType>(hwType)) {
    APInt result = APInt::getZero(hwWidth);
    Type elemType = hwArrayType.getElementType();
    unsigned elemWidth = getTypeWidth(elemType);
    unsigned numElements = hwArrayType.getNumElements();

    for (unsigned i = 0; i < numElements; ++i) {
      unsigned llvmOffset = i * elemWidth;
      unsigned hwOffset = (numElements - 1 - i) * elemWidth;
      APInt elemBits = value.extractBits(elemWidth, llvmOffset);
      APInt converted = convertLLVMToHWLayoutByHWType(elemBits, elemType);
      converted = adjustAPIntWidth(converted, elemWidth);
      safeInsertBits(result,converted, hwOffset);
    }
    return result;
  }

  return value;
}

llvm::APInt LLHDProcessInterpreter::convertHWToLLVMLayoutByHWType(
    llvm::APInt value, Type hwType) const {
  if (auto refType = dyn_cast<llhd::RefType>(hwType))
    hwType = refType.getNestedType();

  unsigned hwWidth = getTypeWidth(hwType);
  value = adjustAPIntWidth(value, hwWidth);

  if (auto hwStructType = dyn_cast<hw::StructType>(hwType)) {
    APInt result = APInt::getZero(hwWidth);
    auto hwElements = hwStructType.getElements();

    unsigned hwOffset = hwWidth;
    unsigned llvmOffset = 0;
    for (auto element : hwElements) {
      unsigned fieldWidth = getTypeWidth(element.type);
      hwOffset -= fieldWidth;
      APInt fieldBits = value.extractBits(fieldWidth, hwOffset);
      APInt converted =
          convertHWToLLVMLayoutByHWType(fieldBits, element.type);
      converted = adjustAPIntWidth(converted, fieldWidth);
      safeInsertBits(result,converted, llvmOffset);
      llvmOffset += fieldWidth;
    }
    return result;
  }

  if (auto hwArrayType = dyn_cast<hw::ArrayType>(hwType)) {
    APInt result = APInt::getZero(hwWidth);
    Type elemType = hwArrayType.getElementType();
    unsigned elemWidth = getTypeWidth(elemType);
    unsigned numElements = hwArrayType.getNumElements();

    for (unsigned i = 0; i < numElements; ++i) {
      unsigned hwOffset = (numElements - 1 - i) * elemWidth;
      unsigned llvmOffset = i * elemWidth;
      APInt elemBits = value.extractBits(elemWidth, hwOffset);
      APInt converted = convertHWToLLVMLayoutByHWType(elemBits, elemType);
      converted = adjustAPIntWidth(converted, elemWidth);
      safeInsertBits(result,converted, llvmOffset);
    }
    return result;
  }

  return value;
}

std::optional<llvm::APInt>
LLHDProcessInterpreter::getEncodedUnknownForType(Type type) const {
  if (auto refType = dyn_cast<llhd::RefType>(type))
    return getEncodedUnknownForType(refType.getNestedType());

  if (auto structType = dyn_cast<hw::StructType>(type)) {
    auto elements = structType.getElements();
    unsigned totalWidth = getTypeWidth(structType);

    if (elements.size() == 2 &&
        elements[0].name.getValue() == "value" &&
        elements[1].name.getValue() == "unknown") {
      unsigned unknownWidth = getTypeWidth(elements[1].type);
      APInt result(totalWidth, 0);
      if (unknownWidth == 0)
        return result;
      APInt unknownMask = APInt::getLowBitsSet(totalWidth, unknownWidth);
      result |= unknownMask;
      return result;
    }

    APInt result(totalWidth, 0);
    unsigned bitOffset = totalWidth;
    for (auto element : elements) {
      auto fieldOpt = getEncodedUnknownForType(element.type);
      if (!fieldOpt)
        return std::nullopt;
      unsigned fieldWidth = getTypeWidth(element.type);
      bitOffset -= fieldWidth;
      APInt fieldBits = fieldOpt->zextOrTrunc(fieldWidth);
      safeInsertBits(result,fieldBits, bitOffset);
    }
    return result;
  }

  if (auto arrayType = dyn_cast<hw::ArrayType>(type)) {
    unsigned elemWidth = getTypeWidth(arrayType.getElementType());
    unsigned count = arrayType.getNumElements();
    unsigned totalWidth = elemWidth * count;
    auto elemOpt = getEncodedUnknownForType(arrayType.getElementType());
    if (!elemOpt)
      return std::nullopt;
    APInt elemBits = elemOpt->zextOrTrunc(elemWidth);
    APInt result(totalWidth, 0);
    for (unsigned i = 0; i < count; ++i) {
      unsigned offset = (count - 1 - i) * elemWidth;
      safeInsertBits(result,elemBits, offset);
    }
    return result;
  }

  return std::nullopt;
}

//===----------------------------------------------------------------------===//
// Signal Registry Bridge
//===----------------------------------------------------------------------===//

namespace {
/// Static pointer to the current interpreter for callback access.
/// This is needed because the MooreRuntime callbacks are C-style function
/// pointers that don't support closures.
LLHDProcessInterpreter *currentInterpreter = nullptr;

/// Callback for reading a signal value from the ProcessScheduler.
int64_t signalReadCallback(MooreSignalHandle handle, void *userData) {
  auto *scheduler = static_cast<ProcessScheduler *>(userData);
  if (!scheduler)
    return 0;

  SignalId sigId = static_cast<SignalId>(handle);
  const SignalValue &value = scheduler->getSignalValue(sigId);
  return static_cast<int64_t>(value.getValue());
}

/// Callback for writing (depositing) a signal value.
int32_t signalWriteCallback(MooreSignalHandle handle, int64_t value,
                            void *userData) {
  auto *scheduler = static_cast<ProcessScheduler *>(userData);
  if (!scheduler)
    return 0;

  SignalId sigId = static_cast<SignalId>(handle);
  // Get the signal's width from the current value
  const SignalValue &currentVal = scheduler->getSignalValue(sigId);
  SignalValue newVal(static_cast<uint64_t>(value), currentVal.getWidth());
  scheduler->updateSignal(sigId, newVal);
  return 1;
}

/// Callback for forcing a signal value.
/// Forces override normal signal updates until released.
int32_t signalForceCallback(MooreSignalHandle handle, int64_t value,
                            void *userData) {
  auto *scheduler = static_cast<ProcessScheduler *>(userData);
  if (!scheduler)
    return 0;

  SignalId sigId = static_cast<SignalId>(handle);
  // Get the signal's width from the current value
  const SignalValue &currentVal = scheduler->getSignalValue(sigId);
  SignalValue newVal(static_cast<uint64_t>(value), currentVal.getWidth());

  // Update the signal value (force tracking is done in MooreRuntime)
  scheduler->updateSignal(sigId, newVal);
  return 1;
}

/// Callback for releasing a forced signal.
int32_t signalReleaseCallback(MooreSignalHandle handle, void *userData) {
  // Release tracking is handled in MooreRuntime forcedSignals map
  // Just return success - the signal will resume normal operation
  (void)handle;
  (void)userData;
  return 1;
}
} // namespace

void LLHDProcessInterpreter::exportSignalsToRegistry() {
  // Clear any existing registrations from previous runs
  __moore_signal_registry_clear();
  __moore_signal_registry_clear_all_forced();

  LLVM_DEBUG(llvm::dbgs() << "LLHDProcessInterpreter: Exporting "
                          << signalIdToName.size()
                          << " signals to MooreRuntime registry\n");

  // Export each signal with its hierarchical path
  for (const auto &entry : signalIdToName) {
    SignalId sigId = entry.first;
    const std::string &signalName = entry.second;

    // Build hierarchical path: moduleName.signalName
    std::string hierarchicalPath;
    if (!moduleName.empty()) {
      hierarchicalPath = moduleName + "." + signalName;
    } else {
      hierarchicalPath = signalName;
    }

    // Get the signal width from the scheduler
    const SignalValue &value = scheduler.getSignalValue(sigId);
    uint32_t width = value.getWidth();

    // Register the signal with both hierarchical and simple paths
    __moore_signal_registry_register(hierarchicalPath.c_str(),
                                     static_cast<MooreSignalHandle>(sigId),
                                     width);

    // Also register with just the signal name for simpler access
    __moore_signal_registry_register(signalName.c_str(),
                                     static_cast<MooreSignalHandle>(sigId),
                                     width);

    LLVM_DEBUG(llvm::dbgs() << "  Exported '" << hierarchicalPath
                            << "' (ID=" << sigId << ", width=" << width
                            << ")\n");
  }

  // Set up the accessor callbacks
  setupRegistryAccessors();

  LLVM_DEBUG(llvm::dbgs() << "LLHDProcessInterpreter: Signal registry now has "
                          << __moore_signal_registry_count() << " entries\n");
}

void LLHDProcessInterpreter::setupRegistryAccessors() {
  // Store current interpreter for static callbacks
  currentInterpreter = this;

  // Set up the accessor callbacks with the ProcessScheduler as user data
  __moore_signal_registry_set_accessor(
      signalReadCallback,   // Read callback
      signalWriteCallback,  // Write/deposit callback
      signalForceCallback,  // Force callback
      signalReleaseCallback, // Release callback
      &scheduler             // User data (ProcessScheduler pointer)
  );

  LLVM_DEBUG(llvm::dbgs()
             << "LLHDProcessInterpreter: Registry accessors configured, "
             << "connected=" << __moore_signal_registry_is_connected() << "\n");
}

//===----------------------------------------------------------------------===//
// Process Registration
//===----------------------------------------------------------------------===//

LogicalResult
LLHDProcessInterpreter::registerProcesses(const DiscoveredOps &ops) {
  // Register all pre-discovered llhd.process operations (no walk() needed)
  for (llhd::ProcessOp processOp : ops.processes) {
    LLVM_DEBUG(llvm::dbgs() << "  Found llhd.process op (numResults="
                            << processOp.getNumResults() << ")\n");
    registerProcess(processOp);
  }

  // Handle pre-discovered llhd.combinational operations
  for ([[maybe_unused]] llhd::CombinationalOp combOp : ops.combinationals) {
    // TODO: Handle combinational processes in Phase 1B
    LLVM_DEBUG(llvm::dbgs() << "  Found combinational process (TODO)\n");
  }

  // Register all pre-discovered seq.initial operations (no walk() needed)
  for (seq::InitialOp initialOp : ops.initials) {
    registerInitialBlock(initialOp);
  }

  // Handle pre-discovered module-level llhd.drv operations (no walk() needed)
  // Note: The iterative discovery already filters for module-level drives
  for (llhd::DriveOp driveOp : ops.moduleDrives) {
    registerModuleDrive(driveOp, 0, InstanceInputMapping{});
  }

  return success();
}

ProcessId LLHDProcessInterpreter::registerProcess(llhd::ProcessOp processOp) {
  // Generate a process name
  std::string name = "llhd_process_" + std::to_string(processStates.size());

  // Create the execution state for this process
  ProcessExecutionState state(processOp);
  state.cacheable = isProcessCacheableBody(processOp);

  // Register with the scheduler, then bind the callback to the real ID.
  ProcessId procId = scheduler.registerProcess(name, []() {});
  if (auto *process = scheduler.getProcess(procId))
    process->setCallback([this, procId]() { executeProcess(procId); });

  // Store the state
  state.currentBlock = &processOp.getBody().front();
  state.currentOp = state.currentBlock->begin();

  // Initialize process results to 0. Process results (e.g., from
  // `llhd.process -> i1`) represent signals whose initial value is 0.
  // Without this, self-referential reads (e.g., `comb.xor %result, %true`)
  // inside the process body would return X before the first halt/yield.
  for (auto result : processOp.getResults()) {
    unsigned width = getTypeWidth(result.getType());
    state.valueMap[result] = InterpretedValue(APInt(width, 0));
  }

  registerProcessState(procId, std::move(state));
  opToProcessId[processOp.getOperation()] = procId;

  LLVM_DEBUG(llvm::dbgs() << "  Registered process '" << name << "' with ID "
                          << procId << "\n");

  // Schedule the process to run at time 0 (initialization)
  scheduler.scheduleProcess(procId, SchedulingRegion::Active);

  return procId;
}

ProcessId LLHDProcessInterpreter::registerInitialBlock(seq::InitialOp initialOp) {
  // Generate a process name for the initial block
  std::string name = "seq_initial_" + std::to_string(processStates.size());

  // Create the execution state for this initial block
  ProcessExecutionState state(initialOp);
  state.cacheable = false;

  // Register with the scheduler, then bind the callback to the real ID.
  ProcessId procId = scheduler.registerProcess(name, []() {});
  if (auto *process = scheduler.getProcess(procId))
    process->setCallback([this, procId]() { executeProcess(procId); });

  // Store the state - initial blocks have a body with a single block
  state.currentBlock = initialOp.getBodyBlock();
  state.currentOp = state.currentBlock->begin();
  registerProcessState(procId, std::move(state));
  opToProcessId[initialOp.getOperation()] = procId;

  LLVM_DEBUG(llvm::dbgs() << "  Registered initial block '" << name
                          << "' with ID " << procId << "\n");

  // Schedule the initial block to run at time 0 (initialization)
  scheduler.scheduleProcess(procId, SchedulingRegion::Active);

  return procId;
}

void LLHDProcessInterpreter::registerModuleDrive(
    llhd::DriveOp driveOp, InstanceId instanceId,
    const InstanceInputMapping &inputMap) {
  ScopedInstanceContext instScope(*this, instanceId);
  ScopedInputValueMap inputScope(*this, inputMap);
  // Module-level drives need special handling:
  // The drive value comes from process results which are populated when
  // the process executes llhd.wait yield or llhd.halt with yield operands.
  //
  // For each module-level drive, we need to:
  // 1. Track the drive operation
  // 2. Identify the source process (if the value comes from a process result)
  // 3. Schedule the drive when the process yields

  Value driveValue = driveOp.getValue();
  InstanceId driveInstance = instanceId;

  // Resolve the drive value through inputValueMap if it's a block argument.
  // This handles the case where a child module's input is mapped to a parent's
  // process result, e.g.: hw.instance @child(in: %proc_val) where %proc_val is
  // the result of an llhd.process in the parent module.
  if (auto arg = dyn_cast<mlir::BlockArgument>(driveValue)) {
    Value mappedValue;
    InstanceId mappedInstance = instanceId;
    if (lookupInputMapping(arg, mappedValue, mappedInstance)) {
      driveValue = mappedValue;
      driveInstance = mappedInstance;
    }
  }

  // Trace through combinational operations to find all upstream process results.
  // The drive value may be a direct process result (llhd.process -> i1) or it
  // may be derived through combinational logic (e.g., comb.and %proc_val, %in).
  // We need to find ALL upstream processes so the drive is re-evaluated when
  // any of them yields.
  llvm::SmallVector<mlir::Value, 8> worklist;
  llvm::DenseSet<mlir::Value> visited;
  llvm::SmallVector<ProcessId, 4> connectedProcesses;
  llvm::SmallVector<SignalId, 4> dependentSignals;
  worklist.push_back(driveValue);
  while (!worklist.empty()) {
    mlir::Value v = worklist.pop_back_val();
    if (!v || !visited.insert(v).second)
      continue;
    // Direct process result?
    if (auto processOp = v.getDefiningOp<llhd::ProcessOp>()) {
      ProcessId procId = InvalidProcessId;
      if (driveInstance != 0) {
        auto ctxIt = instanceOpToProcessId.find(driveInstance);
        if (ctxIt != instanceOpToProcessId.end()) {
          auto procIt = ctxIt->second.find(processOp.getOperation());
          if (procIt != ctxIt->second.end())
            procId = procIt->second;
        }
      }
      if (procId == InvalidProcessId) {
        auto procIt = opToProcessId.find(processOp.getOperation());
        if (procIt != opToProcessId.end())
          procId = procIt->second;
      }
      if (procId != InvalidProcessId)
        connectedProcesses.push_back(procId);
      continue;
    }
    // Track signal dependencies via llhd.prb
    if (auto prbOp = v.getDefiningOp<llhd::ProbeOp>()) {
      SignalId sigId = getSignalId(prbOp.getSignal());
      if (sigId != 0)
        dependentSignals.push_back(sigId);
      continue;
    }
    // Trace through combinational ops (comb.and, comb.or, comb.xor, comb.mux,
    // comb.concat, comb.extract, hw.struct_extract, etc.)
    if (auto *defOp = v.getDefiningOp()) {
      if (defOp->getDialect() &&
          (defOp->getDialect()->getNamespace() == "comb" ||
           defOp->getDialect()->getNamespace() == "hw")) {
        for (mlir::Value operand : defOp->getOperands())
          worklist.push_back(operand);
      }
    }
  }

  if (!connectedProcesses.empty()) {
    size_t driveIdx = moduleDrives.size();
    for (ProcessId procId : connectedProcesses) {
      // Store this drive for later execution when the process yields
      moduleDrives.push_back({driveOp, procId, instanceId, inputMap});

      LLVM_DEBUG(llvm::dbgs() << "  Registered module-level drive connected to "
                              << "process " << procId << "\n");
    }
    // Register signal dependencies for all entries we just added
    for (SignalId sigId : dependentSignals) {
      for (size_t i = driveIdx; i < moduleDrives.size(); ++i)
        signalDependentModuleDrives[sigId].push_back(i);
      LLVM_DEBUG(llvm::dbgs() << "Module drive also depends on signal "
                              << sigId << " (driveIdx=" << driveIdx << ")\n");
    }
  } else {
    // For non-process-connected drives, schedule them immediately
    // This handles static/constant drives at module level
    LLVM_DEBUG(llvm::dbgs() << "  Found module-level drive (static)\n");
    // These will be handled during initialization
    staticModuleDrives.push_back({driveOp, instanceId, inputMap});
  }
}

void LLHDProcessInterpreter::executeModuleDrives(ProcessId procId) {
  // Recursion guard - prevent re-entrant calls during value evaluation
  static thread_local llvm::DenseSet<ProcessId> inProgress;
  if (!inProgress.insert(procId).second) {
    LLVM_DEBUG(llvm::dbgs()
               << "Skipping recursive executeModuleDrives for proc "
               << procId << "\n");
    return;
  }
  auto cleanup = llvm::make_scope_exit([&]() { inProgress.erase(procId); });

  auto stateIt = processStates.find(procId);
  if (stateIt == processStates.end())
    return;

  LLVM_DEBUG(llvm::dbgs() << "executeModuleDrives proc " << procId
                          << " moduleDrives=" << moduleDrives.size() << "\n");

  // Execute all module-level drives connected to this process
  size_t drivesProcessed = 0;
  size_t driveIdx = 0;
  for (auto &entry : moduleDrives) {
    ++driveIdx;
    if (entry.procId != procId)
      continue;
    ++drivesProcessed;
    ScopedInstanceContext instScope(*this, entry.instanceId);
    ScopedInputValueMap inputScope(*this, entry.inputMap);
    llhd::DriveOp driveOp = entry.driveOp;

    // Get the signal ID
    SignalId sigId = getSignalId(driveOp.getSignal());
    if (sigId == 0) {
      LLVM_DEBUG(llvm::dbgs() << "  Error: Unknown signal in module drive\n");
      continue;
    }

    // Check enable condition if present
    if (driveOp.getEnable()) {
      InterpretedValue enableVal = getValue(procId, driveOp.getEnable());
      if (enableVal.isX() || enableVal.getUInt64() == 0) {
        LLVM_DEBUG(llvm::dbgs() << "  Module drive disabled\n");
        continue;
      }
    }

    // Get the value to drive from the process result
    InterpretedValue driveVal = getValue(procId, driveOp.getValue());

    // Get the delay time
    SimTime delay = convertTimeValue(procId, driveOp.getTime());

    // Calculate the target time
    SimTime currentTime = scheduler.getCurrentTime();
    SimTime targetTime = currentTime.advanceTime(delay.realTime);
    if (delay.deltaStep > 0) {
      targetTime.deltaStep = delay.deltaStep;
    }

    LLVM_DEBUG(llvm::dbgs() << "  Module drive: scheduling update to signal "
                            << sigId << " value="
                            << (driveVal.isX() ? "X"
                                                : std::to_string(driveVal.getUInt64()))
                            << " at time " << targetTime.realTime << " fs\n");

    // Schedule the signal update.
    // Use updateSignalWithStrength for multi-driver resolution (wand/wor).
    SignalValue newVal = driveVal.toSignalValue();

    // Extract drive strength from the drive operation.
    DriveStrength strength0 = DriveStrength::Strong;
    DriveStrength strength1 = DriveStrength::Strong;
    if (auto s0Attr = driveOp.getStrength0Attr())
      strength0 = static_cast<DriveStrength>(
          static_cast<uint8_t>(s0Attr.getValue()));
    if (auto s1Attr = driveOp.getStrength1Attr())
      strength1 = static_cast<DriveStrength>(
          static_cast<uint8_t>(s1Attr.getValue()));

    uint64_t driverId =
        reinterpret_cast<uint64_t>(driveOp.getOperation());

    scheduler.getEventScheduler().schedule(
        targetTime, SchedulingRegion::NBA,
        Event([this, sigId, driverId, newVal, strength0, strength1]() {
          scheduler.updateSignalWithStrength(sigId, driverId, newVal,
                                             strength0, strength1);
        }));
  }
  (void)drivesProcessed;
}

void LLHDProcessInterpreter::executeModuleDrivesForSignal(SignalId sigId) {
  auto it = signalDependentModuleDrives.find(sigId);
  if (it == signalDependentModuleDrives.end())
    return;

  LLVM_DEBUG(llvm::dbgs() << "executeModuleDrivesForSignal: signal " << sigId
                          << " changed, re-evaluating " << it->second.size()
                          << " dependent module drives\n");

  for (size_t idx : it->second) {
    if (idx >= moduleDrives.size())
      continue;
    auto &entry = moduleDrives[idx];
    ScopedInstanceContext instScope(*this, entry.instanceId);
    ScopedInputValueMap inputScope(*this, entry.inputMap);
    llhd::DriveOp driveOp = entry.driveOp;

    SignalId dstSigId = getSignalId(driveOp.getSignal());
    if (dstSigId == 0)
      continue;

    // Check enable condition if present
    if (driveOp.getEnable()) {
      InterpretedValue enableVal = evaluateContinuousValue(driveOp.getEnable());
      if (enableVal.isX() || enableVal.getUInt64() == 0)
        continue;
    }

    InterpretedValue driveVal = evaluateContinuousValue(driveOp.getValue());
    LLVM_DEBUG(llvm::dbgs() << "  driveVal="
                            << (driveVal.isX() ? "X" : std::to_string(driveVal.getUInt64()))
                            << " dstSig=" << dstSigId << " procId=" << entry.procId << "\n");
    SimTime delay = convertTimeValue(entry.procId, driveOp.getTime());
    SimTime currentTime = scheduler.getCurrentTime();
    SimTime targetTime = currentTime.advanceTime(delay.realTime);
    if (delay.deltaStep > 0)
      targetTime.deltaStep = currentTime.deltaStep + delay.deltaStep;

    LLVM_DEBUG(llvm::dbgs() << "  targetTime=" << targetTime.realTime
                            << " delta=" << targetTime.deltaStep << "\n");

    SignalValue newVal = driveVal.toSignalValue();
    DriveStrength strength0 = DriveStrength::Strong;
    DriveStrength strength1 = DriveStrength::Strong;
    if (auto s0Attr = driveOp.getStrength0Attr())
      strength0 =
          static_cast<DriveStrength>(static_cast<uint8_t>(s0Attr.getValue()));
    if (auto s1Attr = driveOp.getStrength1Attr())
      strength1 =
          static_cast<DriveStrength>(static_cast<uint8_t>(s1Attr.getValue()));

    uint64_t driverId = reinterpret_cast<uint64_t>(driveOp.getOperation());

    scheduler.getEventScheduler().schedule(
        targetTime, SchedulingRegion::NBA,
        Event([this, dstSigId, driverId, newVal, strength0, strength1]() {
          scheduler.updateSignalWithStrength(dstSigId, driverId, newVal,
                                             strength0, strength1);
        }));
  }
}

void LLHDProcessInterpreter::executeInstanceOutputUpdates(ProcessId procId) {
  for (const auto &entry : instanceOutputUpdates) {
    if (entry.processIds.empty())
      continue;
    bool dependsOnProc = false;
    for (ProcessId id : entry.processIds) {
      if (id == procId) {
        dependsOnProc = true;
        break;
      }
    }
    if (dependsOnProc)
      scheduleInstanceOutputUpdate(entry.signalId, entry.outputValue,
                                   entry.instanceId,
                                   entry.inputMap.empty()
                                       ? nullptr
                                       : &entry.inputMap);
  }
}

void LLHDProcessInterpreter::registerContinuousAssignments(
    hw::HWModuleOp hwModule, InstanceId instanceId,
    const InstanceInputMapping &inputMap) {
  // For each static module-level drive, we need to:
  // 1. Find which signals the drive value depends on (via llhd.prb)
  // 2. Create a combinational process that re-executes when those signals change
  // 3. The process evaluates the drive value and schedules the signal update

  for (const auto &entry : staticModuleDrives) {
    if (entry.instanceId != instanceId)
      continue;
    llhd::DriveOp driveOp = entry.driveOp;
    if (driveOp->getParentOfType<hw::HWModuleOp>() != hwModule)
      continue;
    // Find the signal being driven
    const InstanceInputMapping &driveInputMap =
        entry.inputMap.empty() ? inputMap : entry.inputMap;
    ScopedInstanceContext instScope(*this, instanceId);
    ScopedInputValueMap inputScope(*this, driveInputMap);

    SignalId targetSigId = getSignalId(driveOp.getSignal());
    if (targetSigId == 0) {
      LLVM_DEBUG(llvm::dbgs()
                 << "continuous assignment: unknown target signal\n");
      continue;
    }

    LLVM_DEBUG(llvm::dbgs() << "continuous assignment: static drive signal="
                            << targetSigId << " instId=" << instanceId << "\n");

    llvm::SmallVector<ProcessId, 4> processIds;
    collectProcessIds(driveOp.getValue(), processIds);
    if (driveOp.getEnable())
      collectProcessIds(driveOp.getEnable(), processIds);

    llvm::SmallVector<SignalId, 4> sourceSignals;
    collectSignalIds(driveOp.getValue(), sourceSignals);
    if (driveOp.getEnable())
      collectSignalIds(driveOp.getEnable(), sourceSignals);

    if (!processIds.empty()) {
      LLVM_DEBUG(llvm::dbgs()
                 << "  Continuous assignment depends on "
                 << processIds.size() << " process result(s)\n");
      for (ProcessId procId : processIds) {
        bool alreadyRegistered = false;
        for (const auto &entry : moduleDrives) {
          if (entry.driveOp == driveOp && entry.procId == procId &&
              entry.instanceId == instanceId) {
            alreadyRegistered = true;
            break;
          }
        }
        if (!alreadyRegistered)
          moduleDrives.push_back({driveOp, procId, instanceId, driveInputMap});
      }
    }

    if (sourceSignals.empty() && processIds.empty()) {
      // No source signals - this is a constant drive, execute once at init
      LLVM_DEBUG(llvm::dbgs()
                 << "  Constant continuous assignment to signal " << targetSigId
                 << "\n");
      executeContinuousAssignment(driveOp);
      continue;
    }

    if (sourceSignals.empty()) {
      // Process-result-only drive; updates are handled on process yields.
      continue;
    }

    LLVM_DEBUG({
      llvm::dbgs() << "continuous assignment: signal " << targetSigId
                   << " depends on " << sourceSignals.size()
                   << " source signals:";
      for (SignalId s : sourceSignals)
        llvm::dbgs() << " " << s;
      llvm::dbgs() << "\n";
    });

    // Generate a unique process name
    std::string processName =
        "cont_assign_" + std::to_string(targetSigId);

    // Register a combinational process that executes the drive
    ProcessId procId = scheduler.registerProcess(
        processName,
        [this, driveOp, instanceId, driveInputMap]() {
          ScopedInstanceContext scope(*this, instanceId);
          ScopedInputValueMap inputScope(*this, driveInputMap);
          executeContinuousAssignment(driveOp);
        });

    // Mark as combinational and add sensitivities to all source signals
    auto *process = scheduler.getProcess(procId);
    if (process) {
      process->setCombinational(true);
      for (SignalId srcSigId : sourceSignals) {
        scheduler.addSensitivity(procId, srcSigId);
        LLVM_DEBUG(llvm::dbgs()
                   << "    Added sensitivity to signal " << srcSigId << "\n");
      }
    }

    // Execute once at initialization
    executeContinuousAssignment(driveOp);

    // Schedule the process to run at time 0 to ensure initial state is correct
    scheduler.scheduleProcess(procId, SchedulingRegion::Active);

    // Build combSignalDriveMap for signals driven by static combinational
    // assignments with no enable condition and no process dependencies.
    // This allows evaluateContinuousValue to trace through intermediate
    // signals whose values may be stale (epsilon delays not yet fired).
    // Exclude input port relay drives (where drive value is a block arg)
    // since those signals get correct values from the parent instance's
    // zero-delay drives and tracing through them would bypass the
    // updated signal value.
    if (!driveOp.getEnable() && processIds.empty() &&
        !isa<mlir::BlockArgument>(driveOp.getValue())) {
      combSignalDriveMap[targetSigId] = {driveOp.getValue(), instanceId,
                                         driveInputMap};
    }
  }
}

SignalId LLHDProcessInterpreter::resolveSignalId(mlir::Value value) const {
  if (SignalId sigId = getSignalId(value))
    return sigId;
  auto instMapIt = instanceOutputMap.find(activeInstanceId);
  if (instMapIt != instanceOutputMap.end()) {
    auto instIt = instMapIt->second.find(value);
    if (instIt != instMapIt->second.end()) {
      const auto &info = instIt->second;
      if (info.inputMap.empty())
        return resolveSignalId(info.outputValue);
      ScopedInputValueMap scope(
        *const_cast<LLHDProcessInterpreter *>(this), info.inputMap);
      ScopedInstanceContext instScope(
          *const_cast<LLHDProcessInterpreter *>(this), info.instanceId);
      return resolveSignalId(info.outputValue);
    }
  }
  if (auto arg = dyn_cast<mlir::BlockArgument>(value)) {
    Value mappedValue;
    InstanceId mappedInstance = activeInstanceId;
    if (lookupInputMapping(arg, mappedValue, mappedInstance) &&
        mappedValue != value) {
      ScopedInstanceContext scope(
          *const_cast<LLHDProcessInterpreter *>(this), mappedInstance);
      return resolveSignalId(mappedValue);
    }
    // Trace through function block argument sources. When a function is
    // called with an !llhd.ref argument, refBlockArgSources maps the
    // callee's block arg back to the caller's operand. This enables
    // resolveSignalId to follow the chain through nested function calls
    // (e.g., run_phase → driveToBFM → driveMsbFirstPosedge) even after
    // suspension has erased intermediate valueToSignal entries.
    if (activeProcessId != 0) {
      auto stateIt = processStates.find(activeProcessId);
      if (stateIt != processStates.end()) {
        auto srcIt = stateIt->second.refBlockArgSources.find(arg);
        if (srcIt != stateIt->second.refBlockArgSources.end() &&
            srcIt->second != value) {
          return resolveSignalId(srcIt->second);
        }
      }
    }
  }
  // NOTE: We explicitly do NOT trace through llhd::ProbeOp here.
  // The result of a probe is a VALUE (not a signal reference).
  // Operations on probe results should treat them as values, not signals.
  // This is important for cases like:
  //   %ptr = llhd.prb %sig : !llvm.ptr  // %ptr is a VALUE (pointer address)
  //   llvm.store %val, %ptr            // Should write to MEMORY, not drive %sig
  // Trace through UnrealizedConversionCastOp - these are used to convert
  // between !llhd.ref types and LLVM pointer types when passing signals
  // as function arguments.
  if (auto castOp = value.getDefiningOp<mlir::UnrealizedConversionCastOp>()) {
    if (castOp.getInputs().size() == 1) {
      Value castInput = castOp.getInputs()[0];
      // If the cast converts a probe result (VALUE) to !llhd.ref (SIGNAL REF),
      // trace through the probe to find the underlying signal. This pattern
      // occurs when interface pointer signals are passed through module ports:
      //   %sig = llhd.sig %ptr : !llvm.ptr
      //   %val = llhd.prb %sig : !llvm.ptr
      //   %ref = unrealized_conversion_cast %val : !llvm.ptr to !llhd.ref<!llvm.ptr>
      if (auto probeOp = castInput.getDefiningOp<llhd::ProbeOp>()) {
        if (SignalId sigId = getSignalId(probeOp.getSignal()))
          return sigId;
        return resolveSignalId(probeOp.getSignal());
      }
      return resolveSignalId(castInput);
    }
  }
  // Note: arith.select on ref types is handled dynamically in interpretProbe
  // and interpretDrive since it requires evaluating the condition at runtime.
  // resolveSignalId is a const function that cannot evaluate conditions, so
  // we return 0 here and let the caller handle it.
  return 0;
}

bool LLHDProcessInterpreter::lookupInputMapping(
    mlir::BlockArgument arg, mlir::Value &mappedValue,
    InstanceId &mappedInstance) const {
  auto argIt = inputValueMap.find(arg);
  if (argIt != inputValueMap.end()) {
    mappedValue = argIt->second;
    auto instIt = inputValueInstanceMap.find(arg);
    mappedInstance =
        (instIt != inputValueInstanceMap.end()) ? instIt->second
                                                : activeInstanceId;
    return true;
  }
  auto instanceIt = instanceInputMaps.find(activeInstanceId);
  if (instanceIt == instanceInputMaps.end())
    return false;
  for (const auto &entry : instanceIt->second) {
    if (entry.arg != arg)
      continue;
    mappedValue = entry.value;
    mappedInstance = entry.instanceId;
    return true;
  }
  return false;
}

void LLHDProcessInterpreter::collectSignalIds(
    mlir::Value value, llvm::SmallVectorImpl<SignalId> &signals) const {
  struct WorkItem {
    mlir::Value value;
    const InstanceInputMapping *inputMap = nullptr;
    InstanceId instanceId = 0;
  };

  llvm::SmallVector<WorkItem, 8> worklist;
  llvm::SmallVector<WorkItem, 16> visited;
  worklist.push_back({value, nullptr, activeInstanceId});

  while (!worklist.empty()) {
    WorkItem item = worklist.pop_back_val();
    ScopedInstanceContext instScope(
        *const_cast<LLHDProcessInterpreter *>(this), item.instanceId);
    bool seen = false;
    for (const auto &entry : visited) {
      if (entry.value == item.value && entry.inputMap == item.inputMap &&
          entry.instanceId == item.instanceId) {
        seen = true;
        break;
      }
    }
    if (seen)
      continue;
    visited.push_back(item);

    if (SignalId sigId = getSignalId(item.value)) {
      signals.push_back(sigId);
      continue;
    }

    auto instMapIt = instanceOutputMap.find(item.instanceId);
    if (instMapIt != instanceOutputMap.end()) {
      auto instIt = instMapIt->second.find(item.value);
      if (instIt != instMapIt->second.end()) {
        const auto &info = instIt->second;
        worklist.push_back({info.outputValue, &info.inputMap, info.instanceId});
        continue;
      }
    }

    if (auto arg = dyn_cast<mlir::BlockArgument>(item.value)) {
      if (item.inputMap) {
        for (const auto &entry : *item.inputMap) {
          if (entry.arg == arg) {
            worklist.push_back({entry.value, nullptr, entry.instanceId});
            break;
          }
        }
      }
      Value mappedValue;
      InstanceId mappedInstance = item.instanceId;
      if (lookupInputMapping(arg, mappedValue, mappedInstance)) {
        worklist.push_back({mappedValue, nullptr, mappedInstance});
        continue;
      }
    }

    if (auto toClock = item.value.getDefiningOp<seq::ToClockOp>()) {
      worklist.push_back({toClock.getInput(), item.inputMap, item.instanceId});
      continue;
    }

    if (auto fromClock = item.value.getDefiningOp<seq::FromClockOp>()) {
      worklist.push_back({fromClock.getInput(), item.inputMap, item.instanceId});
      continue;
    }

    if (auto combOp = item.value.getDefiningOp<llhd::CombinationalOp>()) {
      // Add all operands from operations inside the combinational block to the
      // worklist. This avoids recursion through collectSignalIdsFromCombinational
      // which can cause stack overflow on large designs (e.g., OpenTitan IPs).
      combOp.walk([&](Operation *op) {
        for (Value operand : op->getOperands())
          worklist.push_back({operand, item.inputMap, item.instanceId});
      });
      continue;
    }

    if (Operation *defOp = item.value.getDefiningOp()) {
      for (Value operand : defOp->getOperands())
        worklist.push_back({operand, item.inputMap, item.instanceId});
    }
  }
}

void LLHDProcessInterpreter::collectProcessIds(
    mlir::Value value, llvm::SmallVectorImpl<ProcessId> &processIds) const {
  struct WorkItem {
    mlir::Value value;
    const InstanceInputMapping *inputMap = nullptr;
    InstanceId instanceId = 0;
  };

  llvm::SmallVector<WorkItem, 8> worklist;
  llvm::SmallVector<WorkItem, 16> visited;
  llvm::DenseSet<ProcessId> seen;
  worklist.push_back({value, nullptr, activeInstanceId});

  while (!worklist.empty()) {
    WorkItem item = worklist.pop_back_val();
    ScopedInstanceContext instScope(
        *const_cast<LLHDProcessInterpreter *>(this), item.instanceId);
    bool seenValue = false;
    for (const auto &entry : visited) {
      if (entry.value == item.value && entry.inputMap == item.inputMap &&
          entry.instanceId == item.instanceId) {
        seenValue = true;
        break;
      }
    }
    if (seenValue)
      continue;
    visited.push_back(item);

    auto instMapIt = instanceOutputMap.find(item.instanceId);
    if (instMapIt != instanceOutputMap.end()) {
      auto instIt = instMapIt->second.find(item.value);
      if (instIt != instMapIt->second.end()) {
        const auto &info = instIt->second;
        worklist.push_back({info.outputValue, &info.inputMap, info.instanceId});
        continue;
      }
    }

    if (auto arg = dyn_cast<mlir::BlockArgument>(item.value)) {
      if (item.inputMap) {
        for (const auto &entry : *item.inputMap) {
          if (entry.arg == arg) {
            worklist.push_back({entry.value, nullptr, entry.instanceId});
            break;
          }
        }
      }
      Value mappedValue;
      InstanceId mappedInstance = item.instanceId;
      if (lookupInputMapping(arg, mappedValue, mappedInstance)) {
        worklist.push_back({mappedValue, nullptr, mappedInstance});
        continue;
      }
    }

    if (auto result = dyn_cast<OpResult>(item.value)) {
      if (auto processOp = dyn_cast<llhd::ProcessOp>(result.getOwner())) {
        ProcessId procId = InvalidProcessId;
        if (item.instanceId != 0) {
          auto ctxIt = instanceOpToProcessId.find(item.instanceId);
          if (ctxIt != instanceOpToProcessId.end()) {
            auto procIt = ctxIt->second.find(processOp.getOperation());
            if (procIt != ctxIt->second.end())
              procId = procIt->second;
          }
        }
        if (procId == InvalidProcessId) {
          auto procIt = opToProcessId.find(processOp.getOperation());
          if (procIt != opToProcessId.end())
            procId = procIt->second;
        }
        if (procId != InvalidProcessId && seen.insert(procId).second)
          processIds.push_back(procId);
        continue;
      }
    }

    if (Operation *defOp = item.value.getDefiningOp()) {
      for (Value operand : defOp->getOperands())
        worklist.push_back({operand, item.inputMap, item.instanceId});
    }
  }
}

// NOTE: collectSignalIdsFromCombinational has been inlined into collectSignalIds
// to avoid stack overflow from mutual recursion on large designs (e.g., OpenTitan
// hmac_reg_top, rv_timer_reg_top, spi_host_reg_top). The logic now adds operands
// directly to the worklist when encountering a CombinationalOp.

void LLHDProcessInterpreter::registerFirRegs(const DiscoveredOps &ops,
                                             InstanceId instanceId,
                                             const InstanceInputMapping &inputMap) {
  ScopedInstanceContext instScope(*this, instanceId);
  ScopedInputValueMap inputScope(*this, inputMap);
  auto &firRegMap =
      (instanceId == 0) ? firRegStates : instanceFirRegStates[instanceId];
  auto &signalMap =
      (instanceId == 0) ? valueToSignal : instanceValueToSignal[instanceId];
  // Register all pre-discovered seq.firreg operations (no walk() needed)
  for (seq::FirRegOp regOp : ops.firRegs) {
    if (firRegMap.contains(regOp.getOperation()))
      continue;

    std::string baseName;
    if (auto nameAttr = regOp.getNameAttr())
      baseName = nameAttr.str();
    else
      baseName = "firreg_" + std::to_string(firRegMap.size());
    std::string name = baseName;
    if (instanceId != 0)
      name = "inst" + std::to_string(instanceId) + "." + baseName;

    unsigned width = getTypeWidth(regOp.getType());
    SignalId sigId =
        scheduler.registerSignal(name, width, getSignalEncoding(regOp.getType()));
    signalMap[regOp.getResult()] = sigId;
    signalIdToName[sigId] = name;
    signalIdToType[sigId] = unwrapSignalType(regOp.getType());

    bool initSet = false;
    if (regOp.hasReset() && regOp.getIsAsync()) {
      InterpretedValue resetVal = evaluateContinuousValue(regOp.getReset());
      if (!resetVal.isX() && resetVal.getUInt64() != 0) {
        InterpretedValue resetValue =
            evaluateContinuousValue(regOp.getResetValue());
        scheduler.updateSignal(sigId, resetValue.toSignalValue());
        initSet = true;
      }
    }

    if (!initSet && regOp.hasPresetValue()) {
      auto preset = regOp.getPresetAttr();
      if (preset) {
        SignalValue initVal(preset.getValue());
        scheduler.updateSignal(sigId, initVal);
        initSet = true;
      }
    }

    if (!initSet) {
      scheduler.updateSignal(sigId, SignalValue::makeX(width));
    }

    FirRegState state;
    state.signalId = sigId;
    state.instanceId = instanceId;
    state.inputMap = inputMap;
    firRegMap[regOp.getOperation()] = state;

    std::string procName = "firreg_" + name;
    ProcessId procId = scheduler.registerProcess(
        procName, [this, regOp, instanceId, inputMap]() {
          ScopedInstanceContext scope(*this, instanceId);
          ScopedInputValueMap inputScope(*this, inputMap);
          executeFirReg(regOp, instanceId);
        });
    if (auto *process = scheduler.getProcess(procId)) {
      // Schedule firreg updates after combinational propagation in the time slot.
      process->setPreferredRegion(SchedulingRegion::NBA);
    }

    // Track any clock edge so we can update prevClock on negedges too.
    // The actual posedge detection is done inside executeFirReg.
    llvm::SmallVector<SignalId, 4> clkSignals;
    collectSignalIds(regOp.getClk(), clkSignals);
    for (SignalId sig : clkSignals)
      scheduler.addSensitivity(procId, sig, EdgeType::AnyEdge);

    if (regOp.hasReset() && regOp.getIsAsync()) {
      llvm::SmallVector<SignalId, 4> rstSignals;
      collectSignalIds(regOp.getReset(), rstSignals);
      for (SignalId sig : rstSignals)
        scheduler.addSensitivity(procId, sig, EdgeType::AnyEdge);
    }

    scheduler.scheduleProcess(procId, SchedulingRegion::Active);
  }
}

void LLHDProcessInterpreter::executeFirReg(seq::FirRegOp regOp,
                                           InstanceId instanceId) {
  auto &firRegMap =
      (instanceId == 0) ? firRegStates : instanceFirRegStates[instanceId];
  auto it = firRegMap.find(regOp.getOperation());
  if (it == firRegMap.end())
    return;

  FirRegState &state = it->second;
  ScopedInstanceContext instScope(*this, state.instanceId);
  ScopedInputValueMap inputScope(*this, state.inputMap);

  InterpretedValue clkVal = evaluateContinuousValue(regOp.getClk());

  bool clockPosedge = false;
  if (!clkVal.isX()) {
    if (!state.hasPrevClock) {
      state.prevClock = clkVal;
      state.hasPrevClock = true;
    } else if (!state.prevClock.isX()) {
      uint64_t prev = state.prevClock.getUInt64();
      uint64_t curr = clkVal.getUInt64();
      clockPosedge = (prev == 0 && curr != 0);
      state.prevClock = clkVal;
    } else {
      state.prevClock = clkVal;
    }
  }

  bool hasReset = regOp.hasReset();
  bool resetActive = false;
  bool resetUnknown = false;
  InterpretedValue resetVal;
  if (hasReset) {
    resetVal = evaluateContinuousValue(regOp.getReset());
    if (resetVal.isX()) {
      resetUnknown = true;
    } else {
      resetActive = resetVal.getUInt64() != 0;
    }
  }

  InterpretedValue newVal;
  bool doUpdate = false;

  if (hasReset && resetUnknown && clockPosedge) {
    // Only drive X when there's a clock posedge with unknown reset.
    // During combinational settling, the reset signal may temporarily pass
    // through X before stabilizing. Driving X on every intermediate glitch
    // causes the firreg to oscillate between X and its correct value.
    // For async reset: if reset goes to X between clock edges, keep the
    // firreg's current value; the next settled evaluation will correct it.
    newVal = InterpretedValue::makeX(getTypeWidth(regOp.getType()));
    doUpdate = true;
  } else if (hasReset && regOp.getIsAsync() && resetActive) {
    newVal = evaluateContinuousValue(regOp.getResetValue());
    doUpdate = true;
  } else if (clockPosedge) {
    if (hasReset && resetActive && !regOp.getIsAsync()) {
      newVal = evaluateContinuousValue(regOp.getResetValue());
    } else {
      newVal = evaluateContinuousValue(regOp.getNext());
    }
    doUpdate = true;
  }

  if (!doUpdate)
    return;

  scheduler.updateSignal(state.signalId, newVal.toSignalValue());
}

void LLHDProcessInterpreter::executeContinuousAssignment(
    llhd::DriveOp driveOp) {
  // Get the signal being driven
  SignalId targetSigId = getSignalId(driveOp.getSignal());
  if (targetSigId == 0) {
    LLVM_DEBUG(llvm::dbgs()
               << "  Error: Unknown signal in continuous assignment\n");
    return;
  }

  // Evaluate the drive value by interpreting the defining operation chain
  // We use process ID 0 as a dummy since continuous assignments don't have
  // their own process state - they evaluate values directly from signal state
  if (driveOp.getEnable()) {
    InterpretedValue enableVal = evaluateContinuousValue(driveOp.getEnable());
    if (enableVal.isX() || enableVal.getUInt64() == 0) {
      LLVM_DEBUG(llvm::dbgs() << "  Continuous assignment disabled\n");
      return;
    }
  }
  InterpretedValue driveVal = evaluateContinuousValue(driveOp.getValue());

  // Get the delay time
  SimTime delay;
  if (auto timeOp = driveOp.getTime().getDefiningOp<llhd::ConstantTimeOp>()) {
    delay = convertTime(timeOp.getValueAttr());
  } else {
    // Default to epsilon delay
    delay = SimTime(0, 0, 1);
  }

  // Calculate the target time
  SimTime currentTime = scheduler.getCurrentTime();
  SimTime targetTime = currentTime.advanceTime(delay.realTime);
  if (delay.deltaStep > 0) {
    targetTime.deltaStep = currentTime.deltaStep + delay.deltaStep;
  }

  LLVM_DEBUG(llvm::dbgs() << "  Continuous assignment: scheduling update to signal "
                          << targetSigId << " value="
                          << (driveVal.isX() ? "X"
                                             : std::to_string(driveVal.getUInt64()))
                          << " at time " << targetTime.realTime << " fs\n");

  // DEBUG: trace key signals for tlul_adapter_reg readback investigation
  {
    auto nameIt = scheduler.getSignalNames().find(targetSigId);
    if (nameIt != scheduler.getSignalNames().end()) {
      const auto &name = nameIt->second;
      if (name.find("we_o") != std::string::npos ||
          name.find("reg_q") != std::string::npos ||
          name.find("wdata_o") != std::string::npos ||
          name.find("wr_req") != std::string::npos ||
          name.find("rdata") != std::string::npos) {
        llvm::errs() << "[SIG-TRACE] t=" << currentTime.realTime
                     << " d=" << currentTime.deltaStep
                     << " sig=" << targetSigId << " (" << name << ")"
                     << " val=" << (driveVal.isX() ? std::string("X") : [&]() { llvm::SmallString<32> s; driveVal.getAPInt().toString(s, 16, false); return ("0x" + s).str(); }())
                     << " sched_t=" << targetTime.realTime
                     << " sched_d=" << targetTime.deltaStep << "\n";
      }
    }
  }

  // Schedule the signal update.
  // Use updateSignalWithStrength to support multi-driver resolution (wand/wor).
  // Each DriveOp gets a unique driver ID based on its pointer address.
  SignalValue newVal = driveVal.toSignalValue();

  // Extract drive strength from the drive operation.
  DriveStrength strength0 = DriveStrength::Strong;
  DriveStrength strength1 = DriveStrength::Strong;
  if (auto s0Attr = driveOp.getStrength0Attr())
    strength0 = static_cast<DriveStrength>(
        static_cast<uint8_t>(s0Attr.getValue()));
  if (auto s1Attr = driveOp.getStrength1Attr())
    strength1 = static_cast<DriveStrength>(
        static_cast<uint8_t>(s1Attr.getValue()));

  uint64_t driverId =
      reinterpret_cast<uint64_t>(driveOp.getOperation());

  scheduler.getEventScheduler().schedule(
      targetTime, SchedulingRegion::Active,
      Event([this, targetSigId, driverId, newVal, strength0, strength1]() {
        scheduler.updateSignalWithStrength(targetSigId, driverId, newVal,
                                           strength0, strength1);
      }));
}

void LLHDProcessInterpreter::scheduleInstanceOutputUpdate(
    SignalId signalId, mlir::Value outputValue, InstanceId instanceId,
    const InstanceInputMapping *inputMap) {
  ScopedInstanceContext instScope(*this, instanceId);
  if (inputMap && !inputMap->empty()) {
    ScopedInputValueMap scope(*this, *inputMap);
    InterpretedValue driveVal = evaluateContinuousValue(outputValue);
    SignalValue newVal = driveVal.toSignalValue();
    // DEBUG: trace key instance output signals
    {
      auto nameIt = scheduler.getSignalNames().find(signalId);
      if (nameIt != scheduler.getSignalNames().end()) {
        const auto &name = nameIt->second;
        if (name.find("we_o") != std::string::npos ||
            name.find("reg_q") != std::string::npos ||
            name.find("wdata_o") != std::string::npos ||
            name.find("rdata") != std::string::npos) {
          auto curTime = scheduler.getCurrentTime();
          llvm::errs() << "[INST-OUT] t=" << curTime.realTime
                       << " d=" << curTime.deltaStep
                       << " sig=" << signalId << " (" << name << ")"
                       << " val=" << (driveVal.isX() ? std::string("X") : ("0x" + std::to_string(driveVal.getUInt64())))
                       << " changed=" << (scheduler.getSignalValue(signalId) != newVal ? "Y" : "N")
                       << "\n";
        }
      }
    }
    if (scheduler.getSignalValue(signalId) == newVal)
      return;
    scheduler.updateSignal(signalId, newVal);
    return;
  }
  InterpretedValue driveVal = evaluateContinuousValue(outputValue);
  SignalValue newVal = driveVal.toSignalValue();
  // DEBUG: trace key instance output signals (no input map path)
  {
    auto nameIt = scheduler.getSignalNames().find(signalId);
    if (nameIt != scheduler.getSignalNames().end()) {
      const auto &name = nameIt->second;
      if (name.find("we_o") != std::string::npos ||
          name.find("reg_q") != std::string::npos ||
          name.find("wdata_o") != std::string::npos ||
          name.find("rdata") != std::string::npos) {
        auto curTime = scheduler.getCurrentTime();
        llvm::errs() << "[INST-OUT] t=" << curTime.realTime
                     << " d=" << curTime.deltaStep
                     << " sig=" << signalId << " (" << name << ")"
                     << " val=" << (driveVal.isX() ? std::string("X") : ("0x" + std::to_string(driveVal.getUInt64())))
                     << " changed=" << (scheduler.getSignalValue(signalId) != newVal ? "Y" : "N")
                     << "\n";
      }
    }
  }
  if (scheduler.getSignalValue(signalId) == newVal)
    return;

  scheduler.updateSignal(signalId, newVal);
}

bool LLHDProcessInterpreter::evaluateCombinationalOp(
    llhd::CombinationalOp combOp,
    llvm::SmallVectorImpl<InterpretedValue> &results) {
  results.clear();

  ProcessId tempProcId = nextTempProcId++;
  while (processStates.count(tempProcId))
    tempProcId = nextTempProcId++;

  ProcessExecutionState tempState;
  tempState.processOrInitialOp = combOp.getOperation();
  tempState.currentBlock = &combOp.getBody().front();
  tempState.currentOp = tempState.currentBlock->begin();
  processStates[tempProcId] = std::move(tempState);

  bool sawYield = false;
  auto &state = processStates[tempProcId];
  for (Operation &op : *state.currentBlock) {
    if (auto yieldOp = dyn_cast<llhd::YieldOp>(&op)) {
      for (Value operand : yieldOp.getOperands())
        results.push_back(getValue(tempProcId, operand));
      sawYield = true;
      break;
    }

    if (failed(interpretOperation(tempProcId, &op))) {
      LLVM_DEBUG(llvm::dbgs()
                 << "  Warning: Failed to interpret combinational op\n");
      // Emit diagnostic for failed combinational op
      llvm::errs() << "circt-sim: Failed to interpret combinational op\n";
      llvm::errs() << "  Operation: ";
      op.print(llvm::errs(), OpPrintingFlags().printGenericOpForm());
      llvm::errs() << "\n";
      llvm::errs() << "  Location: " << op.getLoc() << "\n";
      break;
    }
  }

  processStates.erase(tempProcId);

  if (!sawYield) {
    results.clear();
    for (Type resultType : combOp.getResultTypes())
      results.push_back(InterpretedValue::makeX(getTypeWidth(resultType)));
    return false;
  }

  return true;
}

/// Evaluate a value for continuous assignments by reading from current signal
/// state.
InterpretedValue LLHDProcessInterpreter::evaluateContinuousValue(
    mlir::Value value) {
  // Guard against stack overflow from deep instance hierarchy recursion.
  // evaluateContinuousValueImpl recurses through evaluateContinuousValue when
  // crossing instance boundaries (instanceOutputMap, combSignalDriveMap,
  // input mappings). Cap the depth and return X for the value.
  if (continuousEvalDepth >= 64) {
    return InterpretedValue::makeX(getTypeWidth(value.getType()));
  }
  ++continuousEvalDepth;
  auto result = evaluateContinuousValueImpl(value);
  --continuousEvalDepth;
  return result;
}

InterpretedValue LLHDProcessInterpreter::evaluateContinuousValueImpl(
    mlir::Value value) {
  enum class EvalKind {
    None,
    Forward,
    StructExtract,
    ArrayGet,
    ArrayCreate,
    ArraySlice,
    ArrayConcat,
    StructCreate,
    StructInject,
    StructInjectLegacy,
    Bitcast,
    Xor,
    And,
    Or,
    ICmp,
    Mux,
    Concat,
    Extract,
    Add,
    Sub,
    Replicate,
    Parity,
    Shl,
    ShrU,
    ShrS,
    Mul,
    DivS,
    DivU,
    ModS,
    ModU
  };

  struct EvalFrame {
    mlir::Value value;
    EvalKind kind = EvalKind::None;
    unsigned stage = 0;
    mlir::Value aux;
  };

  // Track how many times each value has been pushed onto the evaluation stack.
  // In a DAG (directed acyclic graph), a value may be shared by multiple
  // consumers. We allow pushing a value up to 2 times: once for the original
  // reference and once for a shared dependency. The duplicate will be a no-op
  // when popped (already cached from the first evaluation). If a value is
  // pushed more than twice, it indicates a true combinational cycle.
  llvm::DenseMap<mlir::Value, unsigned> pushCount;
  llvm::DenseMap<mlir::Value, InterpretedValue> cache;
  llvm::SmallVector<EvalFrame, 64> stack;

  auto makeUnknown = [&](mlir::Value v) -> InterpretedValue {
    return InterpretedValue::makeX(getTypeWidth(v.getType()));
  };

  auto pushValue = [&](mlir::Value v) {
    if (!v)
      return;
    if (cache.find(v) != cache.end())
      return;
    auto &count = pushCount[v];
    if (count >= 2) {
      LLVM_DEBUG(llvm::dbgs()
                 << "  Warning: Cycle detected in evaluateContinuousValue\n");
      return;
    }
    count++;
    stack.push_back(EvalFrame{v});
  };

  pushValue(value);

  while (!stack.empty()) {
    EvalFrame &frame = stack.back();
    mlir::Value current = frame.value;
    if (cache.find(current) != cache.end()) {
      stack.pop_back();
      continue;
    }

    auto finish = [&](InterpretedValue result) {
      cache[current] = result;
      stack.pop_back();
    };

    auto getCached = [&](mlir::Value v) -> InterpretedValue {
      auto it = cache.find(v);
      if (it != cache.end())
        return it->second;
      return makeUnknown(v);
    };

    if (frame.stage == 0) {
      // Check instanceOutputMap BEFORE getSignalId. Instance results are
      // registered as signals (for caching), but the signal value may be stale
      // when multiple combinational processes fire in response to the same
      // source signal change. By evaluating through the instance we always
      // compute the correct combinational value from current inputs.
      auto instMapIt = instanceOutputMap.find(activeInstanceId);
      if (instMapIt != instanceOutputMap.end()) {
        auto instIt = instMapIt->second.find(current);
        if (instIt != instMapIt->second.end()) {
          const auto &info = instIt->second;
          ScopedInstanceContext instScope(*this, info.instanceId);
          if (info.inputMap.empty()) {
            finish(evaluateContinuousValue(info.outputValue));
          } else {
            ScopedInputValueMap scope(*this, info.inputMap);
            finish(evaluateContinuousValue(info.outputValue));
          }
          continue;
        }
      }

      if (SignalId sigId = getSignalId(current)) {
        // For signals driven by purely combinational expressions, trace
        // through the drive expression rather than reading the (potentially
        // stale) signal value. This handles the case where multiple levels
        // of epsilon-delay combinational assignments haven't propagated yet
        // (e.g., DUT internal wires like wr_req, a_ack).
        // Skip if we're already evaluating this signal (cycle detection).
        auto combIt = combSignalDriveMap.find(sigId);
        if (combIt != combSignalDriveMap.end() &&
            !continuousEvalVisitedSignals.count(sigId)) {
          continuousEvalVisitedSignals.insert(sigId);
          const auto &driveInfo = combIt->second;
          ScopedInstanceContext instScope(*this, driveInfo.instanceId);
          if (!driveInfo.inputMap.empty()) {
            ScopedInputValueMap inputScope(*this, driveInfo.inputMap);
            finish(evaluateContinuousValue(driveInfo.driveValue));
          } else {
            finish(evaluateContinuousValue(driveInfo.driveValue));
          }
          continuousEvalVisitedSignals.erase(sigId);
          continue;
        }

        const SignalValue &sv = scheduler.getSignalValue(sigId);
        if (sv.isUnknown()) {
          if (auto encoded = getEncodedUnknownForType(current.getType()))
            finish(InterpretedValue(*encoded));
          else
            finish(makeUnknown(current));
        } else {
          finish(InterpretedValue::fromSignalValue(sv));
        }
        continue;
      }

      if (auto result = dyn_cast<OpResult>(current)) {
        if (auto processOp = dyn_cast<llhd::ProcessOp>(result.getOwner())) {
          ProcessId procId = InvalidProcessId;
          if (activeInstanceId != 0) {
            auto ctxIt = instanceOpToProcessId.find(activeInstanceId);
            if (ctxIt != instanceOpToProcessId.end()) {
              auto procIt = ctxIt->second.find(processOp.getOperation());
              if (procIt != ctxIt->second.end())
                procId = procIt->second;
            }
          }
          if (procId == InvalidProcessId) {
            auto procIt = opToProcessId.find(processOp.getOperation());
            if (procIt != opToProcessId.end())
              procId = procIt->second;
          }
          if (procId != InvalidProcessId) {
            auto stateIt = processStates.find(procId);
            if (stateIt != processStates.end()) {
              auto valIt = stateIt->second.valueMap.find(current);
              if (valIt != stateIt->second.valueMap.end()) {
                finish(valIt->second);
                continue;
              }
            }
          }
          // Fallback: check persisted process results (process may have
          // halted and its valueMap cleared).
          {
            auto persistIt = persistedProcessResults.find(current);
            if (persistIt != persistedProcessResults.end()) {
              finish(persistIt->second);
              continue;
            }
          }
          finish(makeUnknown(current));
          continue;
        }
      }

      if (auto arg = dyn_cast<mlir::BlockArgument>(current)) {
        Value mappedValue;
        InstanceId mappedInstance = activeInstanceId;
        if (lookupInputMapping(arg, mappedValue, mappedInstance) &&
            mappedValue != current) {
          if (mappedInstance != activeInstanceId) {
            ScopedInstanceContext scope(*this, mappedInstance);
            finish(evaluateContinuousValue(mappedValue));
            continue;
          }
          frame.kind = EvalKind::Forward;
          frame.aux = mappedValue;
          frame.stage = 1;
          pushValue(frame.aux);
          continue;
        }
        SignalId sigId = getSignalId(arg);
        if (sigId != 0) {
          const SignalValue &sv = scheduler.getSignalValue(sigId);
          if (sv.isUnknown()) {
            if (auto encoded = getEncodedUnknownForType(arg.getType()))
              finish(InterpretedValue(*encoded));
            else
              finish(makeUnknown(current));
          } else {
            finish(InterpretedValue::fromSignalValue(sv));
          }
          continue;
        }
      }

      if (auto regOp = current.getDefiningOp<seq::FirRegOp>()) {
        SignalId sigId = getSignalId(regOp.getResult());
        if (sigId != 0) {
          const SignalValue &sv = scheduler.getSignalValue(sigId);
          auto result = InterpretedValue::fromSignalValue(sv);
          finish(result);
        } else {
          finish(makeUnknown(current));
        }
        continue;
      }

      if (auto combOp = current.getDefiningOp<llhd::CombinationalOp>()) {
        llvm::SmallVector<InterpretedValue, 4> results;
        (void)evaluateCombinationalOp(combOp, results);
        auto result = dyn_cast<OpResult>(current);
        if (result && result.getResultNumber() < results.size())
          finish(results[result.getResultNumber()]);
        else
          finish(makeUnknown(current));
        continue;
      }

      if (auto toClockOp = current.getDefiningOp<seq::ToClockOp>()) {
        frame.kind = EvalKind::Forward;
        frame.aux = toClockOp.getInput();
        frame.stage = 1;
        pushValue(frame.aux);
        continue;
      }

      if (auto fromClockOp = current.getDefiningOp<seq::FromClockOp>()) {
        frame.kind = EvalKind::Forward;
        frame.aux = fromClockOp.getInput();
        frame.stage = 1;
        pushValue(frame.aux);
        continue;
      }

      if (auto probeOp = current.getDefiningOp<llhd::ProbeOp>()) {
        SignalId sigId = resolveSignalId(probeOp.getSignal());
        if (sigId != 0) {
          // For signals driven by purely combinational expressions, trace
          // through the drive expression rather than reading the (potentially
          // stale) signal value. This handles the case where DUT internal
          // wires (a_ack, wr_req, etc.) haven't propagated through their
          // epsilon-delay chain yet when an outer expression needs them.
          // Skip if we're already evaluating this signal (cycle detection).
          auto combIt = combSignalDriveMap.find(sigId);
          if (combIt != combSignalDriveMap.end() &&
              !continuousEvalVisitedSignals.count(sigId)) {
            continuousEvalVisitedSignals.insert(sigId);
            const auto &driveInfo = combIt->second;
            ScopedInstanceContext instScope(*this, driveInfo.instanceId);
            if (!driveInfo.inputMap.empty()) {
              ScopedInputValueMap inputScope(*this, driveInfo.inputMap);
              finish(evaluateContinuousValue(driveInfo.driveValue));
            } else {
              finish(evaluateContinuousValue(driveInfo.driveValue));
            }
            continuousEvalVisitedSignals.erase(sigId);
            continue;
          }

          const SignalValue &sv = scheduler.getSignalValue(sigId);
          finish(InterpretedValue::fromSignalValue(sv));
        } else {
          finish(makeUnknown(current));
        }
        continue;
      }

      if (auto constOp = current.getDefiningOp<hw::ConstantOp>()) {
        finish(InterpretedValue(constOp.getValue()));
        continue;
      }

      if (auto aggConstOp = current.getDefiningOp<hw::AggregateConstantOp>()) {
        llvm::APInt flatValue = flattenAggregateConstant(aggConstOp);
        finish(InterpretedValue(flatValue));
        continue;
      }

      if (current.getDefiningOp<hw::StructExtractOp>()) {
        frame.kind = EvalKind::StructExtract;
        frame.stage = 1;
        pushValue(current.getDefiningOp<hw::StructExtractOp>().getInput());
        continue;
      }

      if (current.getDefiningOp<hw::ArrayGetOp>()) {
        frame.kind = EvalKind::ArrayGet;
        frame.stage = 1;
        auto arrayGetOp = current.getDefiningOp<hw::ArrayGetOp>();
        pushValue(arrayGetOp.getInput());
        pushValue(arrayGetOp.getIndex());
        continue;
      }

      if (current.getDefiningOp<hw::ArrayCreateOp>()) {
        frame.kind = EvalKind::ArrayCreate;
        frame.stage = 1;
        auto createOp = current.getDefiningOp<hw::ArrayCreateOp>();
        for (Value input : createOp.getInputs())
          pushValue(input);
        continue;
      }

      if (current.getDefiningOp<hw::ArraySliceOp>()) {
        frame.kind = EvalKind::ArraySlice;
        frame.stage = 1;
        auto sliceOp = current.getDefiningOp<hw::ArraySliceOp>();
        pushValue(sliceOp.getInput());
        pushValue(sliceOp.getLowIndex());
        continue;
      }

      if (current.getDefiningOp<hw::ArrayConcatOp>()) {
        frame.kind = EvalKind::ArrayConcat;
        frame.stage = 1;
        auto concatOp = current.getDefiningOp<hw::ArrayConcatOp>();
        for (Value input : concatOp.getInputs())
          pushValue(input);
        continue;
      }

      if (current.getDefiningOp<hw::StructCreateOp>()) {
        frame.kind = EvalKind::StructCreate;
        frame.stage = 1;
        auto createOp = current.getDefiningOp<hw::StructCreateOp>();
        for (Value input : createOp.getInput())
          pushValue(input);
        continue;
      }

      if (current.getDefiningOp<hw::StructInjectOp>()) {
        frame.kind = EvalKind::StructInject;
        frame.stage = 1;
        auto injectOp = current.getDefiningOp<hw::StructInjectOp>();
        pushValue(injectOp.getInput());
        pushValue(injectOp.getNewValue());
        continue;
      }

      if (auto *defOp = current.getDefiningOp()) {
        if (defOp->getName().getStringRef() == "hw.struct_inject") {
          frame.kind = EvalKind::StructInjectLegacy;
          frame.stage = 1;
          pushValue(defOp->getOperand(0));
          pushValue(defOp->getOperand(1));
          continue;
        }
      }

      if (current.getDefiningOp<hw::BitcastOp>()) {
        frame.kind = EvalKind::Bitcast;
        frame.stage = 1;
        pushValue(current.getDefiningOp<hw::BitcastOp>().getInput());
        continue;
      }

      if (current.getDefiningOp<comb::XorOp>()) {
        frame.kind = EvalKind::Xor;
        frame.stage = 1;
        auto xorOp = current.getDefiningOp<comb::XorOp>();
        for (Value operand : xorOp.getOperands())
          pushValue(operand);
        continue;
      }

      if (current.getDefiningOp<comb::AndOp>()) {
        frame.kind = EvalKind::And;
        frame.stage = 1;
        auto andOp = current.getDefiningOp<comb::AndOp>();
        for (Value operand : andOp.getOperands())
          pushValue(operand);
        continue;
      }

      if (current.getDefiningOp<comb::OrOp>()) {
        frame.kind = EvalKind::Or;
        frame.stage = 1;
        auto orOp = current.getDefiningOp<comb::OrOp>();
        for (Value operand : orOp.getOperands())
          pushValue(operand);
        continue;
      }

      if (current.getDefiningOp<comb::ICmpOp>()) {
        frame.kind = EvalKind::ICmp;
        frame.stage = 1;
        auto icmpOp = current.getDefiningOp<comb::ICmpOp>();
        pushValue(icmpOp.getLhs());
        pushValue(icmpOp.getRhs());
        continue;
      }

      if (current.getDefiningOp<comb::MuxOp>()) {
        frame.kind = EvalKind::Mux;
        frame.stage = 1;
        auto muxOp = current.getDefiningOp<comb::MuxOp>();
        frame.aux = muxOp.getCond();
        pushValue(frame.aux);
        continue;
      }

      if (current.getDefiningOp<comb::ConcatOp>()) {
        frame.kind = EvalKind::Concat;
        frame.stage = 1;
        auto concatOp = current.getDefiningOp<comb::ConcatOp>();
        for (Value operand : concatOp.getOperands())
          pushValue(operand);
        continue;
      }

      if (current.getDefiningOp<comb::ExtractOp>()) {
        frame.kind = EvalKind::Extract;
        frame.stage = 1;
        pushValue(current.getDefiningOp<comb::ExtractOp>().getInput());
        continue;
      }

      if (current.getDefiningOp<comb::AddOp>()) {
        frame.kind = EvalKind::Add;
        frame.stage = 1;
        auto addOp = current.getDefiningOp<comb::AddOp>();
        for (Value operand : addOp.getOperands())
          pushValue(operand);
        continue;
      }

      if (current.getDefiningOp<comb::SubOp>()) {
        frame.kind = EvalKind::Sub;
        frame.stage = 1;
        auto subOp = current.getDefiningOp<comb::SubOp>();
        pushValue(subOp.getOperand(0));
        pushValue(subOp.getOperand(1));
        continue;
      }

      if (current.getDefiningOp<comb::ReplicateOp>()) {
        frame.kind = EvalKind::Replicate;
        frame.stage = 1;
        auto replOp = current.getDefiningOp<comb::ReplicateOp>();
        pushValue(replOp.getInput());
        continue;
      }

      if (current.getDefiningOp<comb::ParityOp>()) {
        frame.kind = EvalKind::Parity;
        frame.stage = 1;
        auto parityOp = current.getDefiningOp<comb::ParityOp>();
        pushValue(parityOp.getInput());
        continue;
      }

      if (current.getDefiningOp<comb::ShlOp>()) {
        frame.kind = EvalKind::Shl;
        frame.stage = 1;
        auto shlOp = current.getDefiningOp<comb::ShlOp>();
        pushValue(shlOp.getLhs());
        pushValue(shlOp.getRhs());
        continue;
      }

      if (current.getDefiningOp<comb::ShrUOp>()) {
        frame.kind = EvalKind::ShrU;
        frame.stage = 1;
        auto shrOp = current.getDefiningOp<comb::ShrUOp>();
        pushValue(shrOp.getLhs());
        pushValue(shrOp.getRhs());
        continue;
      }

      if (current.getDefiningOp<comb::ShrSOp>()) {
        frame.kind = EvalKind::ShrS;
        frame.stage = 1;
        auto shrOp = current.getDefiningOp<comb::ShrSOp>();
        pushValue(shrOp.getLhs());
        pushValue(shrOp.getRhs());
        continue;
      }

      if (current.getDefiningOp<comb::MulOp>()) {
        frame.kind = EvalKind::Mul;
        frame.stage = 1;
        auto mulOp = current.getDefiningOp<comb::MulOp>();
        for (Value operand : mulOp.getOperands())
          pushValue(operand);
        continue;
      }

      if (current.getDefiningOp<comb::DivSOp>()) {
        frame.kind = EvalKind::DivS;
        frame.stage = 1;
        auto divOp = current.getDefiningOp<comb::DivSOp>();
        pushValue(divOp.getLhs());
        pushValue(divOp.getRhs());
        continue;
      }

      if (current.getDefiningOp<comb::DivUOp>()) {
        frame.kind = EvalKind::DivU;
        frame.stage = 1;
        auto divOp = current.getDefiningOp<comb::DivUOp>();
        pushValue(divOp.getLhs());
        pushValue(divOp.getRhs());
        continue;
      }

      if (current.getDefiningOp<comb::ModSOp>()) {
        frame.kind = EvalKind::ModS;
        frame.stage = 1;
        auto modOp = current.getDefiningOp<comb::ModSOp>();
        pushValue(modOp.getLhs());
        pushValue(modOp.getRhs());
        continue;
      }

      if (current.getDefiningOp<comb::ModUOp>()) {
        frame.kind = EvalKind::ModU;
        frame.stage = 1;
        auto modOp = current.getDefiningOp<comb::ModUOp>();
        pushValue(modOp.getLhs());
        pushValue(modOp.getRhs());
        continue;
      }

      LLVM_DEBUG(llvm::dbgs()
                 << "  Warning: Cannot evaluate continuous value for "
                 << *current.getDefiningOp() << "\n");
      finish(makeUnknown(current));
      continue;
    }

    switch (frame.kind) {
    case EvalKind::Forward: {
      InterpretedValue forwarded = getCached(frame.aux);
      finish(forwarded);
      break;
    }
    case EvalKind::StructExtract: {
      auto extractOp = current.getDefiningOp<hw::StructExtractOp>();
      InterpretedValue inputVal = getCached(extractOp.getInput());
      if (inputVal.isX()) {
        finish(makeUnknown(current));
        break;
      }
      auto structType =
          hw::type_cast<hw::StructType>(extractOp.getInput().getType());
      StringRef fieldName = extractOp.getFieldName();
      unsigned bitOffset = 0;
      unsigned fieldWidth = 0;
      auto elements = structType.getElements();
      unsigned totalWidth = getTypeWidth(structType);
      for (auto &element : elements) {
        unsigned elemWidth = getTypeWidth(element.type);
        if (element.name == fieldName) {
          fieldWidth = elemWidth;
          break;
        }
        bitOffset += elemWidth;
      }
      unsigned shiftAmount = totalWidth - bitOffset - fieldWidth;
      llvm::APInt fieldVal =
          inputVal.getAPInt().extractBits(fieldWidth, shiftAmount);
      finish(InterpretedValue(fieldVal));
      break;
    }
    case EvalKind::ArrayGet: {
      auto arrayGetOp = current.getDefiningOp<hw::ArrayGetOp>();
      InterpretedValue arrayVal = getCached(arrayGetOp.getInput());
      InterpretedValue indexVal = getCached(arrayGetOp.getIndex());
      if (arrayVal.isX() || indexVal.isX()) {
        finish(makeUnknown(current));
        break;
      }
      auto arrayType =
          hw::type_cast<hw::ArrayType>(arrayGetOp.getInput().getType());
      unsigned elementWidth = getTypeWidth(arrayType.getElementType());
      unsigned numElements = arrayType.getNumElements();
      uint64_t index = indexVal.getAPInt().getZExtValue();
      if (index >= numElements) {
        finish(InterpretedValue::makeX(elementWidth));
        break;
      }
      // Array element 0 is at LSB (offset 0), matching CIRCT hw dialect convention.
      unsigned bitOffset = index * elementWidth;
      APInt result = arrayVal.getAPInt().extractBits(elementWidth, bitOffset);
      finish(InterpretedValue(result));
      break;
    }
    case EvalKind::ArrayCreate: {
      auto createOp = current.getDefiningOp<hw::ArrayCreateOp>();
      auto arrayType = hw::type_cast<hw::ArrayType>(createOp.getType());
      unsigned elementWidth = getTypeWidth(arrayType.getElementType());
      unsigned numElements = arrayType.getNumElements();
      unsigned totalWidth = elementWidth * numElements;

      APInt result(totalWidth, 0);
      bool hasX = false;

      for (size_t i = 0; i < createOp.getInputs().size(); ++i) {
        InterpretedValue elem = getCached(createOp.getInputs()[i]);
        APInt elemVal(elementWidth, 0);
        if (elem.isX()) {
          if (auto encoded =
                  getEncodedUnknownForType(arrayType.getElementType())) {
            elemVal = encoded->zextOrTrunc(elementWidth);
          } else {
            hasX = true;
            break;
          }
        } else {
          elemVal = elem.getAPInt();
        }
        if (elemVal.getBitWidth() < elementWidth)
          elemVal = elemVal.zext(elementWidth);
        else if (elemVal.getBitWidth() > elementWidth)
          elemVal = elemVal.trunc(elementWidth);
        unsigned offset = (numElements - 1 - i) * elementWidth;
        safeInsertBits(result,elemVal, offset);
      }

      if (hasX) {
        finish(InterpretedValue::makeX(totalWidth));
      } else {
        finish(InterpretedValue(result));
      }
      break;
    }
    case EvalKind::ArraySlice: {
      auto sliceOp = current.getDefiningOp<hw::ArraySliceOp>();
      InterpretedValue arrayVal = getCached(sliceOp.getInput());
      InterpretedValue indexVal = getCached(sliceOp.getLowIndex());
      auto resultType = hw::type_cast<hw::ArrayType>(sliceOp.getType());
      if (arrayVal.isX() || indexVal.isX()) {
        unsigned resultWidth = getTypeWidth(resultType.getElementType()) *
                               resultType.getNumElements();
        finish(InterpretedValue::makeX(resultWidth));
        break;
      }

      auto inputType =
          hw::type_cast<hw::ArrayType>(sliceOp.getInput().getType());
      unsigned elementWidth = getTypeWidth(inputType.getElementType());
      unsigned inputElements = inputType.getNumElements();
      unsigned resultElements = resultType.getNumElements();
      uint64_t lowIdx = indexVal.getAPInt().getZExtValue();

      if (lowIdx + resultElements > inputElements) {
        unsigned resultWidth = elementWidth * resultElements;
        finish(InterpretedValue::makeX(resultWidth));
        break;
      }

      // Array element 0 is at LSB (offset 0), matching CIRCT hw dialect convention.
      unsigned offset = lowIdx * elementWidth;
      unsigned sliceWidth = resultElements * elementWidth;
      APInt slice = arrayVal.getAPInt().extractBits(sliceWidth, offset);
      finish(InterpretedValue(slice));
      break;
    }
    case EvalKind::ArrayConcat: {
      auto concatOp = current.getDefiningOp<hw::ArrayConcatOp>();
      auto resultType = hw::type_cast<hw::ArrayType>(concatOp.getType());
      unsigned resultWidth = getTypeWidth(resultType.getElementType()) *
                             resultType.getNumElements();

      APInt result(resultWidth, 0);
      bool hasX = false;
      unsigned bitOffset = resultWidth;

      for (Value input : concatOp.getInputs()) {
        InterpretedValue val = getCached(input);
        if (val.isX()) {
          hasX = true;
          break;
        }
        unsigned inputWidth = val.getWidth();
        bitOffset -= inputWidth;
        safeInsertBits(result,val.getAPInt(), bitOffset);
      }

      if (hasX) {
        finish(InterpretedValue::makeX(resultWidth));
      } else {
        finish(InterpretedValue(result));
      }
      break;
    }
    case EvalKind::StructCreate: {
      auto createOp = current.getDefiningOp<hw::StructCreateOp>();
      auto structType = hw::type_cast<hw::StructType>(createOp.getType());
      unsigned totalWidth = getTypeWidth(structType);
      llvm::APInt result(totalWidth, 0);
      auto elements = structType.getElements();
      unsigned bitOffset = totalWidth;
      for (size_t i = 0; i < createOp.getInput().size(); ++i) {
        InterpretedValue fieldVal = getCached(createOp.getInput()[i]);
        unsigned fieldWidth = getTypeWidth(elements[i].type);
        bitOffset -= fieldWidth;
        if (!fieldVal.isX()) {
          APInt fieldBits = fieldVal.getAPInt();
          if (fieldBits.getBitWidth() < fieldWidth)
            fieldBits = fieldBits.zext(fieldWidth);
          else if (fieldBits.getBitWidth() > fieldWidth)
            fieldBits = fieldBits.trunc(fieldWidth);
          safeInsertBits(result,fieldBits, bitOffset);
        }
      }
      finish(InterpretedValue(result));
      break;
    }
    case EvalKind::StructInject: {
      auto injectOp = current.getDefiningOp<hw::StructInjectOp>();
      InterpretedValue structVal = getCached(injectOp.getInput());
      InterpretedValue newVal = getCached(injectOp.getNewValue());
      unsigned totalWidth = getTypeWidth(injectOp.getType());
      if (structVal.isX() || newVal.isX()) {
        finish(InterpretedValue::makeX(totalWidth));
        break;
      }
      auto structType = cast<hw::StructType>(injectOp.getInput().getType());
      auto fieldIndexOpt = structType.getFieldIndex(injectOp.getFieldName());
      if (!fieldIndexOpt) {
        finish(InterpretedValue::makeX(totalWidth));
        break;
      }
      unsigned fieldIndex = *fieldIndexOpt;
      auto elements = structType.getElements();
      unsigned fieldOffset = 0;
      for (size_t i = fieldIndex + 1; i < elements.size(); ++i)
        fieldOffset += getTypeWidth(elements[i].type);
      unsigned fieldWidth = getTypeWidth(elements[fieldIndex].type);
      llvm::APInt result = structVal.getAPInt();
      llvm::APInt fieldValue = newVal.getAPInt();
      if (fieldValue.getBitWidth() < fieldWidth)
        fieldValue = fieldValue.zext(fieldWidth);
      else if (fieldValue.getBitWidth() > fieldWidth)
        fieldValue = fieldValue.trunc(fieldWidth);
      safeInsertBits(result,fieldValue, fieldOffset);
      finish(InterpretedValue(result));
      break;
    }
    case EvalKind::StructInjectLegacy: {
      auto *defOp = current.getDefiningOp();
      Value input = defOp->getOperand(0);
      Value newValue = defOp->getOperand(1);
      auto structType = cast<hw::StructType>(input.getType());
      unsigned totalWidth = getTypeWidth(structType);
      auto fieldIndexAttr = defOp->getAttrOfType<IntegerAttr>("fieldIndex");
      if (!fieldIndexAttr) {
        finish(InterpretedValue::makeX(totalWidth));
        break;
      }
      unsigned fieldIndex = fieldIndexAttr.getValue().getZExtValue();
      auto elements = structType.getElements();
      InterpretedValue structVal = getCached(input);
      InterpretedValue newVal = getCached(newValue);
      if (structVal.isX() || newVal.isX()) {
        finish(InterpretedValue::makeX(totalWidth));
        break;
      }
      unsigned fieldOffset = 0;
      for (size_t i = fieldIndex + 1; i < elements.size(); ++i)
        fieldOffset += getTypeWidth(elements[i].type);
      unsigned fieldWidth = getTypeWidth(elements[fieldIndex].type);
      llvm::APInt result = structVal.getAPInt();
      llvm::APInt fieldValue = newVal.getAPInt();
      if (fieldValue.getBitWidth() < fieldWidth)
        fieldValue = fieldValue.zext(fieldWidth);
      else if (fieldValue.getBitWidth() > fieldWidth)
        fieldValue = fieldValue.trunc(fieldWidth);
      safeInsertBits(result,fieldValue, fieldOffset);
      finish(InterpretedValue(result));
      break;
    }
    case EvalKind::Bitcast: {
      auto bitcastOp = current.getDefiningOp<hw::BitcastOp>();
      InterpretedValue inputVal = getCached(bitcastOp.getInput());
      unsigned outputWidth = getTypeWidth(bitcastOp.getType());
      if (inputVal.isX()) {
        finish(InterpretedValue::makeX(outputWidth));
        break;
      }
      llvm::APInt result = inputVal.getAPInt();
      if (result.getBitWidth() < outputWidth)
        result = result.zext(outputWidth);
      else if (result.getBitWidth() > outputWidth)
        result = result.trunc(outputWidth);
      finish(InterpretedValue(result));
      break;
    }
    case EvalKind::Xor: {
      auto xorOp = current.getDefiningOp<comb::XorOp>();
      unsigned width = getTypeWidth(current.getType());
      llvm::APInt result = APInt::getZero(width);
      bool sawX = false;
      for (Value operand : xorOp.getOperands()) {
        InterpretedValue opVal = getCached(operand);
        if (opVal.isX()) { sawX = true; break; }
        llvm::APInt v = opVal.getAPInt();
        if (v.getBitWidth() != width)
          v = v.zextOrTrunc(width);
        result ^= v;
      }
      if (sawX)
        finish(makeUnknown(current));
      else
        finish(InterpretedValue(result));
      break;
    }
    case EvalKind::And: {
      auto andOp = current.getDefiningOp<comb::AndOp>();
      unsigned width = getTypeWidth(current.getType());
      llvm::APInt result(width, 0);
      result.setAllBits();
      bool sawX = false;
      for (Value operand : andOp.getOperands()) {
        InterpretedValue opVal = getCached(operand);
        if (opVal.isX()) {
          sawX = true;
          break;
        }
        llvm::APInt opBits = opVal.getAPInt();
        if (opBits.getBitWidth() < width)
          opBits = opBits.zext(width);
        else if (opBits.getBitWidth() > width)
          opBits = opBits.trunc(width);
        result &= opBits;
      }
      if (sawX)
        finish(InterpretedValue::makeX(width));
      else
        finish(InterpretedValue(result));
      break;
    }
    case EvalKind::Or: {
      auto orOp = current.getDefiningOp<comb::OrOp>();
      unsigned width = getTypeWidth(current.getType());
      llvm::APInt result(width, 0);
      bool sawX = false;
      for (Value operand : orOp.getOperands()) {
        InterpretedValue opVal = getCached(operand);
        if (opVal.isX()) {
          sawX = true;
          break;
        }
        llvm::APInt opBits = opVal.getAPInt();
        if (opBits.getBitWidth() < width)
          opBits = opBits.zext(width);
        else if (opBits.getBitWidth() > width)
          opBits = opBits.trunc(width);
        result |= opBits;
      }
      if (sawX)
        finish(InterpretedValue::makeX(width));
      else
        finish(InterpretedValue(result));
      break;
    }
    case EvalKind::ICmp: {
      auto icmpOp = current.getDefiningOp<comb::ICmpOp>();
      InterpretedValue lhs = getCached(icmpOp.getLhs());
      InterpretedValue rhs = getCached(icmpOp.getRhs());
      if (lhs.isX() || rhs.isX()) {
        finish(InterpretedValue::makeX(1));
        break;
      }
      bool result = false;
      llvm::APInt lVal = lhs.getAPInt();
      llvm::APInt rVal = rhs.getAPInt();
      unsigned compareWidth = std::max(lVal.getBitWidth(), rVal.getBitWidth());
      normalizeWidths(lVal, rVal, compareWidth);
      switch (icmpOp.getPredicate()) {
      case comb::ICmpPredicate::eq:
        result = (lVal == rVal);
        break;
      case comb::ICmpPredicate::ne:
        result = (lVal != rVal);
        break;
      case comb::ICmpPredicate::ult:
        result = lVal.ult(rVal);
        break;
      case comb::ICmpPredicate::ule:
        result = lVal.ule(rVal);
        break;
      case comb::ICmpPredicate::ugt:
        result = lVal.ugt(rVal);
        break;
      case comb::ICmpPredicate::uge:
        result = lVal.uge(rVal);
        break;
      default:
        result = false;
        break;
      }
      finish(InterpretedValue(result ? 1ULL : 0ULL, 1));
      break;
    }
    case EvalKind::Mux: {
      auto muxOp = current.getDefiningOp<comb::MuxOp>();
      if (frame.stage == 1) {
        InterpretedValue cond = getCached(frame.aux);
        if (cond.isX()) {
          finish(makeUnknown(current));
          break;
        }
        Value selected = cond.getUInt64() != 0 ? muxOp.getTrueValue()
                                               : muxOp.getFalseValue();
        frame.aux = selected;
        frame.stage = 2;
        pushValue(selected);
        continue;
      }
      InterpretedValue selectedVal = getCached(frame.aux);
      finish(selectedVal);
      break;
    }
    case EvalKind::Concat: {
      auto concatOp = current.getDefiningOp<comb::ConcatOp>();
      unsigned totalWidth = getTypeWidth(current.getType());
      llvm::APInt result(totalWidth, 0);
      unsigned bitOffset = totalWidth;
      for (Value operand : concatOp.getOperands()) {
        InterpretedValue opVal = getCached(operand);
        unsigned width = getTypeWidth(operand.getType());
        bitOffset -= width;
        if (opVal.isX())
          continue;
        llvm::APInt bits = opVal.getAPInt();
        if (bits.getBitWidth() < width)
          bits = bits.zext(width);
        else if (bits.getBitWidth() > width)
          bits = bits.trunc(width);
        safeInsertBits(result,bits, bitOffset);
      }
      finish(InterpretedValue(result));
      break;
    }
    case EvalKind::Extract: {
      auto extractOp = current.getDefiningOp<comb::ExtractOp>();
      InterpretedValue inputVal = getCached(extractOp.getInput());
      unsigned width = getTypeWidth(current.getType());
      if (inputVal.isX()) {
        finish(InterpretedValue::makeX(width));
        break;
      }
      unsigned lowBit = extractOp.getLowBit();
      llvm::APInt input = inputVal.getAPInt();
      llvm::APInt sliced = input.extractBits(width, lowBit);
      finish(InterpretedValue(sliced));
      break;
    }
    case EvalKind::Add: {
      auto addOp = current.getDefiningOp<comb::AddOp>();
      unsigned width = getTypeWidth(current.getType());
      llvm::APInt result = APInt::getZero(width);
      bool sawX = false;
      for (Value operand : addOp.getOperands()) {
        InterpretedValue opVal = getCached(operand);
        if (opVal.isX()) { sawX = true; break; }
        llvm::APInt v = opVal.getAPInt();
        if (v.getBitWidth() != width)
          v = v.zextOrTrunc(width);
        result += v;
      }
      if (sawX)
        finish(makeUnknown(current));
      else
        finish(InterpretedValue(result));
      break;
    }
    case EvalKind::Sub: {
      auto subOp = current.getDefiningOp<comb::SubOp>();
      InterpretedValue lhs = getCached(subOp.getOperand(0));
      InterpretedValue rhs = getCached(subOp.getOperand(1));
      if (lhs.isX() || rhs.isX()) {
        finish(makeUnknown(current));
        break;
      }
      llvm::APInt lhsVal = lhs.getAPInt();
      llvm::APInt rhsVal = rhs.getAPInt();
      unsigned width = getTypeWidth(current.getType());
      normalizeWidths(lhsVal, rhsVal, width);
      finish(InterpretedValue(lhsVal - rhsVal));
      break;
    }
    case EvalKind::Replicate: {
      auto replOp = current.getDefiningOp<comb::ReplicateOp>();
      InterpretedValue input = getCached(replOp.getInput());
      if (input.isX()) {
        finish(InterpretedValue::makeX(getTypeWidth(current.getType())));
        break;
      }
      unsigned inputWidth = input.getWidth();
      unsigned multiple = replOp.getMultiple();
      llvm::APInt result(getTypeWidth(current.getType()), 0);
      for (unsigned i = 0; i < multiple; ++i) {
        llvm::APInt chunk = input.getAPInt().zext(result.getBitWidth());
        result = result.shl(inputWidth) | chunk;
      }
      finish(InterpretedValue(result));
      break;
    }
    case EvalKind::Parity: {
      auto parityOp = current.getDefiningOp<comb::ParityOp>();
      InterpretedValue input = getCached(parityOp.getInput());
      if (input.isX()) {
        finish(InterpretedValue::makeX(1));
        break;
      }
      bool parity = (input.getAPInt().popcount() & 1) != 0;
      finish(InterpretedValue(parity, 1));
      break;
    }
    case EvalKind::Shl: {
      auto shlOp = current.getDefiningOp<comb::ShlOp>();
      InterpretedValue lhs = getCached(shlOp.getLhs());
      InterpretedValue rhs = getCached(shlOp.getRhs());
      if (lhs.isX() || rhs.isX()) {
        finish(InterpretedValue::makeX(getTypeWidth(current.getType())));
        break;
      }
      uint64_t shift = rhs.getAPInt().getLimitedValue();
      unsigned bitWidth = lhs.getAPInt().getBitWidth();
      if (shift >= bitWidth) {
        finish(InterpretedValue(APInt::getZero(bitWidth)));
      } else {
        finish(InterpretedValue(lhs.getAPInt().shl(shift)));
      }
      break;
    }
    case EvalKind::ShrU: {
      auto shrOp = current.getDefiningOp<comb::ShrUOp>();
      InterpretedValue lhs = getCached(shrOp.getLhs());
      InterpretedValue rhs = getCached(shrOp.getRhs());
      if (lhs.isX() || rhs.isX()) {
        finish(InterpretedValue::makeX(getTypeWidth(current.getType())));
        break;
      }
      uint64_t shift = rhs.getAPInt().getLimitedValue();
      unsigned bitWidth = lhs.getAPInt().getBitWidth();
      if (shift >= bitWidth) {
        finish(InterpretedValue(APInt::getZero(bitWidth)));
      } else {
        finish(InterpretedValue(lhs.getAPInt().lshr(shift)));
      }
      break;
    }
    case EvalKind::ShrS: {
      auto shrOp = current.getDefiningOp<comb::ShrSOp>();
      InterpretedValue lhs = getCached(shrOp.getLhs());
      InterpretedValue rhs = getCached(shrOp.getRhs());
      if (lhs.isX() || rhs.isX()) {
        finish(InterpretedValue::makeX(getTypeWidth(current.getType())));
        break;
      }
      uint64_t shift = rhs.getAPInt().getLimitedValue();
      unsigned bitWidth = lhs.getAPInt().getBitWidth();
      if (shift >= bitWidth) {
        // Arithmetic shift right by >= bitWidth: result is all sign bits
        finish(InterpretedValue(
            lhs.getAPInt().isNegative()
                ? APInt::getAllOnes(bitWidth)
                : APInt::getZero(bitWidth)));
      } else {
        finish(InterpretedValue(lhs.getAPInt().ashr(shift)));
      }
      break;
    }
    case EvalKind::Mul: {
      auto mulOp = current.getDefiningOp<comb::MulOp>();
      unsigned targetWidth = getTypeWidth(current.getType());
      llvm::APInt result(targetWidth, 1);
      bool sawX = false;
      for (Value operand : mulOp.getOperands()) {
        InterpretedValue value = getCached(operand);
        if (value.isX()) {
          sawX = true;
          break;
        }
        llvm::APInt operandVal = value.getAPInt();
        if (operandVal.getBitWidth() < targetWidth)
          operandVal = operandVal.zext(targetWidth);
        else if (operandVal.getBitWidth() > targetWidth)
          operandVal = operandVal.trunc(targetWidth);
        result *= operandVal;
      }
      if (sawX)
        finish(InterpretedValue::makeX(targetWidth));
      else
        finish(InterpretedValue(result));
      break;
    }
    case EvalKind::DivS: {
      auto divOp = current.getDefiningOp<comb::DivSOp>();
      InterpretedValue lhs = getCached(divOp.getLhs());
      InterpretedValue rhs = getCached(divOp.getRhs());
      unsigned targetWidth = getTypeWidth(current.getType());
      if (lhs.isX() || rhs.isX() || rhs.getAPInt().isZero()) {
        finish(InterpretedValue::makeX(targetWidth));
        break;
      }
      llvm::APInt lhsVal = lhs.getAPInt();
      llvm::APInt rhsVal = rhs.getAPInt();
      normalizeWidths(lhsVal, rhsVal, targetWidth);
      finish(InterpretedValue(lhsVal.sdiv(rhsVal)));
      break;
    }
    case EvalKind::DivU: {
      auto divOp = current.getDefiningOp<comb::DivUOp>();
      InterpretedValue lhs = getCached(divOp.getLhs());
      InterpretedValue rhs = getCached(divOp.getRhs());
      unsigned targetWidth = getTypeWidth(current.getType());
      if (lhs.isX() || rhs.isX() || rhs.getAPInt().isZero()) {
        finish(InterpretedValue::makeX(targetWidth));
        break;
      }
      llvm::APInt lhsVal = lhs.getAPInt();
      llvm::APInt rhsVal = rhs.getAPInt();
      normalizeWidths(lhsVal, rhsVal, targetWidth);
      finish(InterpretedValue(lhsVal.udiv(rhsVal)));
      break;
    }
    case EvalKind::ModS: {
      auto modOp = current.getDefiningOp<comb::ModSOp>();
      InterpretedValue lhs = getCached(modOp.getLhs());
      InterpretedValue rhs = getCached(modOp.getRhs());
      unsigned targetWidth = getTypeWidth(current.getType());
      if (lhs.isX() || rhs.isX() || rhs.getAPInt().isZero()) {
        finish(InterpretedValue::makeX(targetWidth));
        break;
      }
      llvm::APInt lhsVal = lhs.getAPInt();
      llvm::APInt rhsVal = rhs.getAPInt();
      normalizeWidths(lhsVal, rhsVal, targetWidth);
      finish(InterpretedValue(lhsVal.srem(rhsVal)));
      break;
    }
    case EvalKind::ModU: {
      auto modOp = current.getDefiningOp<comb::ModUOp>();
      InterpretedValue lhs = getCached(modOp.getLhs());
      InterpretedValue rhs = getCached(modOp.getRhs());
      unsigned targetWidth = getTypeWidth(current.getType());
      if (lhs.isX() || rhs.isX() || rhs.getAPInt().isZero()) {
        finish(InterpretedValue::makeX(targetWidth));
        break;
      }
      llvm::APInt lhsVal = lhs.getAPInt();
      llvm::APInt rhsVal = rhs.getAPInt();
      normalizeWidths(lhsVal, rhsVal, targetWidth);
      finish(InterpretedValue(lhsVal.urem(rhsVal)));
      break;
    }
    case EvalKind::None:
      finish(makeUnknown(current));
      break;
    }
  }

  auto it = cache.find(value);
  if (it != cache.end())
    return it->second;
  return makeUnknown(value);
}

//===----------------------------------------------------------------------===//
// Process Execution
//===----------------------------------------------------------------------===//

static void cacheWaitState(ProcessExecutionState &state,
                           const ProcessScheduler &scheduler,
                           const SensitivityList *waitList, bool hadDelay) {
  state.lastWaitHadDelay = hadDelay;
  state.lastWaitHasEdge = false;
  state.lastSensitivityEntries.clear();
  state.lastSensitivityValues.clear();
  state.lastSensitivityValid = false;

  if (!waitList || waitList->empty())
    return;

  state.lastSensitivityEntries = waitList->getEntries();
  state.lastSensitivityValues.reserve(state.lastSensitivityEntries.size());
  for (const auto &entry : state.lastSensitivityEntries) {
    state.lastSensitivityValues.push_back(
        scheduler.getSignalValue(entry.signalId));
    if (entry.edge != EdgeType::AnyEdge)
      state.lastWaitHasEdge = true;
  }
  state.lastSensitivityValid = true;
}

static bool canSkipCachedProcess(const ProcessExecutionState &state,
                                 const ProcessScheduler &scheduler) {
  if (!state.cacheable || !state.lastSensitivityValid ||
      state.lastWaitHadDelay || state.lastWaitHasEdge)
    return false;
  if (state.lastSensitivityEntries.empty())
    return false;
  if (state.lastSensitivityEntries.size() != state.lastSensitivityValues.size())
    return false;

  for (size_t i = 0; i < state.lastSensitivityEntries.size(); ++i) {
    SignalId sigId = state.lastSensitivityEntries[i].signalId;
    if (scheduler.getSignalValue(sigId) != state.lastSensitivityValues[i])
      return false;
  }

  return true;
}

static SensitivityList
buildSensitivityListFromState(const ProcessExecutionState &state) {
  SensitivityList list;
  for (const auto &entry : state.lastSensitivityEntries)
    list.addEdge(entry.signalId, entry.edge);
  return list;
}

void LLHDProcessInterpreter::checkMemoryEventWaiters() {
  if (memoryEventWaiters.empty())
    return;

  // Check each memory event waiter to see if the watched value has changed
  llvm::SmallVector<ProcessId, 4> toWake;

  for (auto &[procId, waiter] : memoryEventWaiters) {
    // Find the memory block containing this address
    MemoryBlock *block = nullptr;
    uint64_t offset = 0;
    uint64_t addr = waiter.address;

    // Check module-level allocas first (by address)
    for (auto &[val, memBlock] : moduleLevelAllocas) {
      auto addrIt = moduleInitValueMap.find(val);
      if (addrIt != moduleInitValueMap.end()) {
        uint64_t blockAddr = addrIt->second.getUInt64();
        if (addr >= blockAddr && addr < blockAddr + memBlock.size) {
          block = &memBlock;
          offset = addr - blockAddr;
          break;
        }
      }
    }

    // Check global and malloc blocks via O(log n) range index
    if (!block) {
      uint64_t rangeOffset = 0;
      block = findBlockByAddress(addr, rangeOffset);
      if (block) offset = rangeOffset;
    }

    // Also check process-local memory blocks
    if (!block) {
      auto procStateIt = processStates.find(procId);
      if (procStateIt != processStates.end()) {
        auto &procState = procStateIt->second;
        for (auto &[val, memBlock] : procState.memoryBlocks) {
          auto addrIt = procState.valueMap.find(val);
          if (addrIt != procState.valueMap.end()) {
            uint64_t blockAddr = addrIt->second.getUInt64();
            if (addr >= blockAddr && addr < blockAddr + memBlock.size) {
              block = &memBlock;
              offset = addr - blockAddr;
              break;
            }
          }
        }
      }
    }

    if (!block || !block->initialized) {
      LLVM_DEBUG(llvm::dbgs() << "  Memory event waiter: block not found for "
                                 "address 0x"
                              << llvm::format_hex(addr, 16) << "\n");
      continue;
    }

    // Read current value
    if (offset + waiter.valueSize > block->size)
      continue;

    uint64_t currentValue = 0;
    for (unsigned i = 0; i < waiter.valueSize; ++i) {
      currentValue |=
          static_cast<uint64_t>(block->data[offset + i]) << (i * 8);
    }

    // Check if value changed and matches the expected edge type.
    // For UVM events (!moore.event), we need to detect a "trigger" which is
    // a rising edge (0→1 transition). This is critical for wait_for_objection:
    // if no objection has been raised yet (value=0), we must wait for the
    // NEXT trigger (0→1), not just any change.
    bool shouldWake = false;
    if (currentValue != waiter.lastValue) {
      if (waiter.waitForRisingEdge) {
        // Only wake on rising edge (0→1)
        shouldWake = (waiter.lastValue == 0 && currentValue != 0);
        LLVM_DEBUG(llvm::dbgs()
                   << "  Memory event check for process " << procId
                   << ": address 0x" << llvm::format_hex(addr, 16) << " changed "
                   << waiter.lastValue << " -> " << currentValue
                   << (shouldWake ? " (rising edge - WAKE)" : " (not rising edge - continue waiting)") << "\n");
        // Update lastValue so we can detect the next rising edge
        waiter.lastValue = currentValue;
      } else {
        // Wake on any change
        shouldWake = true;
        LLVM_DEBUG(llvm::dbgs()
                   << "  Memory event triggered for process " << procId
                   << ": address 0x" << llvm::format_hex(addr, 16) << " changed "
                   << waiter.lastValue << " -> " << currentValue << "\n");
      }
    }
    if (shouldWake) {
      toWake.push_back(procId);
    }
  }

  // Wake the processes whose watched memory changed
  for (ProcessId procId : toWake) {
    memoryEventWaiters.erase(procId);
    auto it = processStates.find(procId);
    if (it != processStates.end()) {
      it->second.waiting = false;
      // Schedule the process to run now that the memory event triggered
      scheduler.scheduleProcess(procId, SchedulingRegion::Active);
    }
  }
}

LLHDProcessInterpreter::ProcessThunkInstallResult
LLHDProcessInterpreter::tryInstallProcessThunk(ProcessId procId,
                                               ProcessExecutionState &state) {
  if (!jitCompileManager)
    return ProcessThunkInstallResult::MissingThunk;

  if (!jitCompileManager->shouldAttemptProcessCompile(procId))
    return ProcessThunkInstallResult::MissingThunk;

  PeriodicToggleClockThunkSpec periodicSpec;
  bool isPeriodicToggleClock =
      tryBuildPeriodicToggleClockThunkSpec(state, periodicSpec);
  bool isTrivialCandidate =
      !isPeriodicToggleClock && isTrivialNativeThunkCandidate(state);
  if (!isPeriodicToggleClock && !isTrivialCandidate)
    return ProcessThunkInstallResult::UnsupportedOperation;

  bool installed =
      jitCompileManager->installProcessThunk(procId, [this, procId](
                                                         ProcessThunkExecutionState
                                                             &thunkState) {
        executeTrivialNativeThunk(procId, thunkState);
      });
  if (!installed)
    return ProcessThunkInstallResult::MissingThunk;

  if (isPeriodicToggleClock)
    periodicToggleClockThunkSpecs[procId] = std::move(periodicSpec);
  else
    periodicToggleClockThunkSpecs.erase(procId);

  jitCompileManager->noteCompile();
  return ProcessThunkInstallResult::Installed;
}

bool LLHDProcessInterpreter::snapshotJITDeoptState(
    ProcessId procId, JITDeoptStateSnapshot &snapshot) {
  auto it = processStates.find(procId);
  if (it == processStates.end())
    return false;
  ProcessExecutionState &state = it->second;
  snapshot.currentBlock = state.currentBlock;
  snapshot.currentOp = state.currentOp;
  snapshot.halted = state.halted;
  snapshot.waiting = state.waiting;
  snapshot.destBlock = state.destBlock;
  snapshot.resumeAtCurrentOp = state.resumeAtCurrentOp;
  snapshot.destOperands = state.destOperands;
  snapshot.callStack = state.callStack;
  snapshot.jitThunkResumeToken = state.jitThunkResumeToken;
  return true;
}

bool LLHDProcessInterpreter::restoreJITDeoptState(
    ProcessId procId, const JITDeoptStateSnapshot &snapshot) {
  auto it = processStates.find(procId);
  if (it == processStates.end())
    return false;
  ProcessExecutionState &state = it->second;
  state.currentBlock = snapshot.currentBlock;
  state.currentOp = snapshot.currentOp;
  state.halted = snapshot.halted;
  state.waiting = snapshot.waiting;
  state.destBlock = snapshot.destBlock;
  state.resumeAtCurrentOp = snapshot.resumeAtCurrentOp;
  state.destOperands = snapshot.destOperands;
  state.callStack = snapshot.callStack;
  state.jitThunkResumeToken = snapshot.jitThunkResumeToken;
  return true;
}

bool LLHDProcessInterpreter::isTrivialNativeThunkCandidate(
    const ProcessExecutionState &state) const {
  if (isResumableWaitThenHaltNativeThunkCandidate(state))
    return true;

  if (state.getProcessOp()) {
    auto processOp = state.getProcessOp();
    if (!processOp.getBody().hasOneBlock())
      return false;
    Block &body = processOp.getBody().front();
    if (body.empty())
      return false;
    auto it = body.begin();
    if (auto haltOp = dyn_cast<llhd::HaltOp>(*it)) {
      (void)haltOp;
      return std::next(it) == body.end();
    }
    if (auto printOp = dyn_cast<sim::PrintFormattedProcOp>(*it)) {
      (void)printOp;
      ++it;
      if (it == body.end())
        return false;
      if (!dyn_cast<llhd::HaltOp>(*it))
        return false;
      return std::next(it) == body.end();
    }
    return false;
  }

  if (state.getInitialOp()) {
    auto initialOp = state.getInitialOp();
    Block *body = initialOp.getBodyBlock();
    if (!body || body->empty())
      return false;
    Operation &lastOp = body->back();
    auto yieldOp = dyn_cast<seq::YieldOp>(lastOp);
    if (!yieldOp || !yieldOp.getOperands().empty())
      return false;
    if (llvm::hasSingleElement(*body))
      return true;

    auto rit = body->rbegin();
    ++rit;
    auto printOp = dyn_cast<sim::PrintFormattedProcOp>(*rit);
    if (!printOp)
      return false;

    for (auto it = body->begin(), e = std::prev(std::prev(body->end())); it != e;
         ++it) {
      Operation *op = &*it;
      if (op->getName().getStringRef().starts_with("sim.fmt."))
        continue;
      if (isa<hw::ConstantOp, arith::ConstantOp, LLVM::ConstantOp>(op))
        continue;
      return false;
    }
    return true;
  }

  return false;
}

bool LLHDProcessInterpreter::isResumableWaitThenHaltNativeThunkCandidate(
    const ProcessExecutionState &state) const {
  auto processOp = state.getProcessOp();
  if (!processOp)
    return false;
  Region &bodyRegion = processOp.getBody();
  if (!llvm::hasNItemsOrMore(bodyRegion, 2) || llvm::hasNItemsOrMore(bodyRegion, 3))
    return false;
  Block &entry = bodyRegion.front();
  if (entry.empty())
    return false;
  auto waitIt = std::prev(entry.end());
  auto waitOp = dyn_cast<llhd::WaitOp>(*waitIt);
  if (!waitOp || (!waitOp.getDelay() && waitOp.getObserved().empty()))
    return false;
  llvm::SmallVector<Operation *, 8> preWaitOps;
  llvm::SmallDenseSet<Value, 8> preWaitResults;
  for (auto it = entry.begin(); it != waitIt; ++it) {
    Operation *op = &*it;
    if (!isPureResumableWaitPreludeOp(op))
      return false;
    preWaitOps.push_back(op);
    for (Value result : op->getResults())
      preWaitResults.insert(result);
  }
  auto observed = waitOp.getObserved();
  if (preWaitOps.empty()) {
    if (!observed.empty())
      return false;
  } else {
    for (Value obs : observed) {
      if (!preWaitResults.contains(obs))
        return false;
    }
  }
  Block *dest = waitOp.getDest();
  if (!dest || dest == &entry || dest->empty())
    return false;
  auto opIt = dest->begin();
  if (auto printOp = dyn_cast<sim::PrintFormattedProcOp>(*opIt)) {
    (void)printOp;
    ++opIt;
  }
  if (opIt == dest->end())
    return false;
  auto haltOp = dyn_cast<llhd::HaltOp>(*opIt);
  if (!haltOp)
    return false;
  ++opIt;
  return opIt == dest->end();
}

void LLHDProcessInterpreter::executeTrivialNativeThunk(
    ProcessId procId, ProcessThunkExecutionState &thunkState) {
  if (forceJitThunkDeoptRequests) {
    thunkState.deoptRequested = true;
    return;
  }

  auto it = processStates.find(procId);
  if (it == processStates.end() || it->second.halted)
    return;

  if (executeResumableWaitThenHaltNativeThunk(procId, it->second, thunkState))
    return;

  if (executePeriodicToggleClockNativeThunk(procId, it->second, thunkState))
    return;

  if (auto processOp = it->second.getProcessOp()) {
    Block &body = processOp.getBody().front();
    auto opIt = body.begin();
    if (auto printOp = dyn_cast<sim::PrintFormattedProcOp>(*opIt)) {
      (void)interpretProcPrint(procId, printOp);
      ++opIt;
    }
    if (auto haltOp = dyn_cast<llhd::HaltOp>(*opIt)) {
      (void)interpretHalt(procId, haltOp);
      auto post = processStates.find(procId);
      if (post != processStates.end()) {
        thunkState.halted = post->second.halted;
        thunkState.waiting = post->second.waiting;
      }
      return;
    }
  }

  if (auto initialOp = it->second.getInitialOp()) {
    Block *body = initialOp.getBodyBlock();
    auto yieldOp = dyn_cast<seq::YieldOp>(body->back());
    if (!yieldOp)
      return;
    if (!llvm::hasSingleElement(*body)) {
      auto printIt = std::prev(body->end());
      --printIt;
      if (auto printOp = dyn_cast<sim::PrintFormattedProcOp>(*printIt))
        (void)interpretProcPrint(procId, printOp);
    }
    if (yieldOp) {
      (void)interpretSeqYield(procId, yieldOp);
      auto post = processStates.find(procId);
      if (post != processStates.end()) {
        thunkState.halted = post->second.halted;
        thunkState.waiting = post->second.waiting;
      }
      return;
    }
  }

  finalizeProcess(procId, /*killed=*/false);
  auto post = processStates.find(procId);
  if (post != processStates.end()) {
    thunkState.halted = post->second.halted;
    thunkState.waiting = post->second.waiting;
  }
}

bool LLHDProcessInterpreter::executeResumableWaitThenHaltNativeThunk(
    ProcessId procId, ProcessExecutionState &state,
    ProcessThunkExecutionState &thunkState) {
  if (!isResumableWaitThenHaltNativeThunkCandidate(state))
    return false;

  auto processOp = state.getProcessOp();
  Block &entry = processOp.getBody().front();
  auto waitIt = std::prev(entry.end());
  auto waitOp = dyn_cast<llhd::WaitOp>(*waitIt);
  if (!waitOp) {
    thunkState.deoptRequested = true;
    return true;
  }
  llvm::SmallVector<Operation *, 8> preWaitOps;
  llvm::SmallDenseSet<Value, 8> preWaitResults;
  for (auto it = entry.begin(); it != waitIt; ++it) {
    Operation *op = &*it;
    if (!isPureResumableWaitPreludeOp(op)) {
      thunkState.deoptRequested = true;
      return true;
    }
    preWaitOps.push_back(op);
    for (Value result : op->getResults())
      preWaitResults.insert(result);
  }
  auto observed = waitOp.getObserved();
  if (preWaitOps.empty()) {
    if (!observed.empty()) {
      thunkState.deoptRequested = true;
      return true;
    }
  } else {
    for (Value obs : observed) {
      if (!preWaitResults.contains(obs)) {
        thunkState.deoptRequested = true;
        return true;
      }
    }
  }
  Block *terminalBlock = waitOp.getDest();
  auto opIt = terminalBlock->begin();
  sim::PrintFormattedProcOp printOp;
  if (auto maybePrint = dyn_cast<sim::PrintFormattedProcOp>(*opIt)) {
    printOp = maybePrint;
    ++opIt;
  }
  auto haltOp = dyn_cast<llhd::HaltOp>(*opIt);
  if (!haltOp) {
    thunkState.deoptRequested = true;
    return true;
  }

  // Guard the compiled state machine token before any side effects.
  if (thunkState.resumeToken != state.jitThunkResumeToken) {
    thunkState.deoptRequested = true;
    return true;
  }

  // Token 0: first activation, execute pre-wait probes, then suspend on wait.
  if (state.jitThunkResumeToken == 0) {
    if (state.waiting || state.destBlock) {
      thunkState.deoptRequested = true;
      return true;
    }
    for (Operation *op : preWaitOps) {
      if (failed(interpretOperation(procId, op))) {
        thunkState.deoptRequested = true;
        return true;
      }
    }
    if (failed(interpretWait(procId, waitOp))) {
      thunkState.deoptRequested = true;
      return true;
    }
    state.jitThunkResumeToken = 1;
    thunkState.waiting = state.waiting;
    thunkState.halted = state.halted;
    thunkState.resumeToken = state.jitThunkResumeToken;
    return true;
  }

  // Token 1: resumed activation, run optional print and halt.
  if (state.jitThunkResumeToken == 1) {
    if (state.destBlock != terminalBlock) {
      thunkState.deoptRequested = true;
      return true;
    }

    if (state.destOperands.size() != terminalBlock->getNumArguments()) {
      thunkState.deoptRequested = true;
      return true;
    }
    for (auto [arg, val] :
         llvm::zip(terminalBlock->getArguments(), state.destOperands)) {
      state.valueMap[arg] = val;
      if (isa<llhd::RefType>(arg.getType()))
        state.refBlockArgSources.erase(arg);
    }
    state.destOperands.clear();
    state.destBlock = nullptr;
    state.resumeAtCurrentOp = false;
    state.waiting = false;
    if (printOp && failed(interpretProcPrint(procId, printOp))) {
      thunkState.deoptRequested = true;
      return true;
    }
    if (failed(interpretHalt(procId, haltOp))) {
      thunkState.deoptRequested = true;
      return true;
    }
    auto post = processStates.find(procId);
    if (post != processStates.end()) {
      post->second.jitThunkResumeToken = post->second.halted ? 0 : 1;
      thunkState.halted = post->second.halted;
      thunkState.waiting = post->second.waiting;
      thunkState.resumeToken = post->second.jitThunkResumeToken;
    }
    return true;
  }

  // Any unexpected shape/state transition requests deopt bridge fallback.
  thunkState.deoptRequested = true;
  return true;
}

bool LLHDProcessInterpreter::tryBuildPeriodicToggleClockThunkSpec(
    const ProcessExecutionState &state,
    PeriodicToggleClockThunkSpec &spec) const {
  auto processOp = state.getProcessOp();
  if (!processOp)
    return false;
  Region &bodyRegion = processOp.getBody();
  if (bodyRegion.empty())
    return false;

  spec = PeriodicToggleClockThunkSpec{};

  Block &entry = bodyRegion.front();
  if (entry.empty())
    return false;
  auto entryIt = entry.begin();
  if (auto initDrive = dyn_cast<llhd::DriveOp>(*entryIt)) {
    spec.hasInitialDrive = true;
    spec.initialDriveOp = initDrive;
    ++entryIt;
    if (entryIt == entry.end())
      return false;
  }

  auto entryBr = dyn_cast<mlir::cf::BranchOp>(*entryIt);
  if (!entryBr || std::next(entryIt) != entry.end() ||
      !entryBr.getDestOperands().empty())
    return false;

  Block *loopBlock = entryBr.getDest();
  if (!loopBlock || loopBlock == &entry)
    return false;
  if (!llvm::hasNItemsOrMore(*loopBlock, 2) ||
      llvm::hasNItemsOrMore(*loopBlock, 3))
    return false;

  auto loopIt = loopBlock->begin();
  auto intToTimeOp = dyn_cast<llhd::IntToTimeOp>(*loopIt++);
  auto waitOp = dyn_cast<llhd::WaitOp>(*loopIt);
  if (!intToTimeOp || !waitOp || waitOp.getDelay() != intToTimeOp.getResult() ||
      !waitOp.getObserved().empty() || !waitOp.getYieldOperands().empty() ||
      !waitOp.getDestOperands().empty())
    return false;

  auto extractConstU64 = [&](Value value, uint64_t &out) -> bool {
    out = 0;
    if (auto hwConst = value.getDefiningOp<hw::ConstantOp>()) {
      out = hwConst.getValue().getZExtValue();
      return true;
    }
    if (auto arithConst = value.getDefiningOp<arith::ConstantOp>()) {
      if (auto intAttr = dyn_cast<IntegerAttr>(arithConst.getValue())) {
        out = intAttr.getValue().getZExtValue();
        return true;
      }
      return false;
    }
    if (auto llvmConst = value.getDefiningOp<LLVM::ConstantOp>()) {
      if (auto intAttr = dyn_cast<IntegerAttr>(llvmConst.getValue())) {
        out = intAttr.getValue().getZExtValue();
        return true;
      }
      return false;
    }
    return false;
  };

  uint64_t delayFs = 0;
  if (!extractConstU64(intToTimeOp.getInput(), delayFs) || delayFs == 0)
    return false;

  Block *toggleBlock = waitOp.getDest();
  if (!toggleBlock || toggleBlock == loopBlock)
    return false;
  if (!llvm::hasNItemsOrMore(*toggleBlock, 4) ||
      llvm::hasNItemsOrMore(*toggleBlock, 5))
    return false;

  auto toggleIt = toggleBlock->begin();
  auto probeOp = dyn_cast<llhd::ProbeOp>(*toggleIt++);
  Operation *toggleOp = &*toggleIt++;
  auto toggleDriveOp = dyn_cast<llhd::DriveOp>(*toggleIt++);
  auto toggleBr = dyn_cast<mlir::cf::BranchOp>(*toggleIt);
  if (!probeOp || !toggleDriveOp || !toggleBr ||
      std::next(toggleIt) != toggleBlock->end() ||
      toggleBr.getDest() != loopBlock || !toggleBr.getDestOperands().empty())
    return false;

  if (toggleOp->getNumResults() != 1 ||
      toggleDriveOp.getValue() != toggleOp->getResult(0))
    return false;
  if (probeOp.getSignal() != toggleDriveOp.getSignal())
    return false;
  if (spec.hasInitialDrive &&
      spec.initialDriveOp.getSignal() != toggleDriveOp.getSignal())
    return false;
  if (isa<llhd::WaitOp, llhd::HaltOp, mlir::cf::BranchOp,
          mlir::cf::CondBranchOp, mlir::func::CallOp,
          mlir::func::CallIndirectOp, LLVM::CallOp>(toggleOp))
    return false;

  spec.intToTimeResult = intToTimeOp.getResult();
  spec.waitOp = waitOp;
  spec.waitDestBlock = toggleBlock;
  spec.probeOp = probeOp;
  spec.toggleOp = toggleOp;
  spec.toggleDriveOp = toggleDriveOp;
  spec.delayFs = delayFs;
  return true;
}

bool LLHDProcessInterpreter::executePeriodicToggleClockNativeThunk(
    ProcessId procId, ProcessExecutionState &state,
    ProcessThunkExecutionState &thunkState) {
  auto specIt = periodicToggleClockThunkSpecs.find(procId);
  if (specIt == periodicToggleClockThunkSpecs.end())
    return false;
  auto &spec = specIt->second;

  if (state.halted) {
    state.jitThunkResumeToken = 0;
    thunkState.halted = true;
    thunkState.waiting = false;
    thunkState.resumeToken = 0;
    return true;
  }

  // Guard the compiled state machine token before any side effects.
  if (thunkState.resumeToken != state.jitThunkResumeToken) {
    thunkState.deoptRequested = true;
    return true;
  }

  auto scheduleNextWait = [&]() -> bool {
    unsigned delayWidth = std::max(1u, getTypeWidth(spec.intToTimeResult.getType()));
    setValue(procId, spec.intToTimeResult,
             InterpretedValue(llvm::APInt(delayWidth, spec.delayFs)));
    if (failed(interpretWait(procId, spec.waitOp))) {
      thunkState.deoptRequested = true;
      return false;
    }
    state.jitThunkResumeToken = 1;
    thunkState.halted = state.halted;
    thunkState.waiting = state.waiting;
    thunkState.resumeToken = state.jitThunkResumeToken;
    return true;
  };

  // Token 0: first activation executes optional initial drive, then waits.
  if (state.jitThunkResumeToken == 0) {
    if (state.waiting || state.destBlock) {
      thunkState.deoptRequested = true;
      return true;
    }
    if (spec.hasInitialDrive &&
        failed(interpretDrive(procId, spec.initialDriveOp))) {
      thunkState.deoptRequested = true;
      return true;
    }
    (void)scheduleNextWait();
    return true;
  }

  // Token 1: resumed activation, toggle drive value, then wait again.
  if (state.jitThunkResumeToken == 1) {
    if (state.destBlock != spec.waitDestBlock) {
      thunkState.deoptRequested = true;
      return true;
    }
    state.waiting = false;
    if (failed(interpretProbe(procId, spec.probeOp)) ||
        failed(interpretOperation(procId, spec.toggleOp)) ||
        failed(interpretDrive(procId, spec.toggleDriveOp))) {
      thunkState.deoptRequested = true;
      return true;
    }
    (void)scheduleNextWait();
    return true;
  }

  thunkState.deoptRequested = true;
  return true;
}

void LLHDProcessInterpreter::executeProcess(ProcessId procId) {
  auto it = processStates.find(procId);
  if (it == processStates.end()) {
    LLVM_DEBUG(llvm::dbgs() << "LLHDProcessInterpreter: Unknown process ID "
                            << procId << "\n");
    return;
  }

  ProcessExecutionState &state = it->second;

  // Compile-mode entry hook: try native process thunk first, then attempt
  // on-demand install for currently supported trivial process shapes.
  if (compileModeEnabled && jitCompileManager) {
    JITDeoptStateSnapshot deoptSnapshot;
    bool hasDeoptSnapshot = snapshotJITDeoptState(procId, deoptSnapshot);
    auto noteProcessDeoptReason = [&](JITCompileManager::DeoptReason reason) {
      if (jitCompileManager)
        jitCompileManager->noteProcessDeoptOnce(procId, reason);
      if (!jitDeoptReasonByProcess.count(procId))
        jitDeoptReasonByProcess[procId] =
            JITCompileManager::getDeoptReasonName(reason).str();
    };
    auto maybeInvalidateThunkForNoCachePolicy = [&]() {
      if (llvm::StringRef(jitCompileManager->getConfig().cachePolicy)
              .equals_insensitive("none"))
        jitCompileManager->invalidateProcessThunk(procId);
    };

    ProcessThunkExecutionState thunkState;
    thunkState.resumeToken = state.jitThunkResumeToken;
    if (jitCompileManager->executeProcessThunk(procId, thunkState)) {
      if (!thunkState.deoptRequested) {
        state.jitThunkResumeToken = thunkState.resumeToken;
        maybeInvalidateThunkForNoCachePolicy();
        return;
      }
      if (hasDeoptSnapshot)
        (void)restoreJITDeoptState(procId, deoptSnapshot);
      noteProcessDeoptReason(JITCompileManager::DeoptReason::GuardFailed);
    } else {
      ProcessThunkInstallResult installResult =
          tryInstallProcessThunk(procId, state);
      if (installResult == ProcessThunkInstallResult::Installed) {
        ProcessThunkExecutionState installedThunkState;
        installedThunkState.resumeToken = state.jitThunkResumeToken;
        if (jitCompileManager->executeProcessThunk(procId, installedThunkState)) {
          if (!installedThunkState.deoptRequested) {
            state.jitThunkResumeToken = installedThunkState.resumeToken;
            maybeInvalidateThunkForNoCachePolicy();
            return;
          }
          if (hasDeoptSnapshot)
            (void)restoreJITDeoptState(procId, deoptSnapshot);
          noteProcessDeoptReason(JITCompileManager::DeoptReason::GuardFailed);
        } else {
          installResult = ProcessThunkInstallResult::MissingThunk;
        }
      }

      if (installResult != ProcessThunkInstallResult::Installed) {
        JITCompileManager::DeoptReason reason =
            JITCompileManager::DeoptReason::MissingThunk;
        if (installResult == ProcessThunkInstallResult::UnsupportedOperation)
          reason = JITCompileManager::DeoptReason::UnsupportedOperation;
        noteProcessDeoptReason(reason);
      }
    }
  }

  // Cache the active process state to avoid repeated std::map lookups
  // in executeStep/getValue/setValue on every operation.
  ProcessId savedActiveProcessId = activeProcessId;
  ProcessExecutionState *savedActiveProcessState = activeProcessState;
  activeProcessId = procId;
  activeProcessState = &state;

  // Check if this process is waiting on a memory event.
  // If so, check if the memory value has changed before proceeding.
  auto memWaiterIt = memoryEventWaiters.find(procId);
  if (memWaiterIt != memoryEventWaiters.end()) {
    MemoryEventWaiter &waiter = memWaiterIt->second;
    uint64_t addr = waiter.address;

    // Find the memory block containing this address
    MemoryBlock *block = nullptr;
    uint64_t offset = 0;

    // Check module-level allocas first (by address)
    for (auto &[val, memBlock] : moduleLevelAllocas) {
      auto addrIt = moduleInitValueMap.find(val);
      if (addrIt != moduleInitValueMap.end()) {
        uint64_t blockAddr = addrIt->second.getUInt64();
        if (addr >= blockAddr && addr < blockAddr + memBlock.size) {
          block = &memBlock;
          offset = addr - blockAddr;
          break;
        }
      }
    }

    // Check global and malloc blocks via O(log n) range index
    if (!block) {
      uint64_t rangeOffset = 0;
      block = findBlockByAddress(addr, rangeOffset);
      if (block) offset = rangeOffset;
    }

    // Also check process-local memory blocks
    if (!block) {
      auto &procState = processStates[procId];
      for (auto &[val, memBlock] : procState.memoryBlocks) {
        auto addrIt = procState.valueMap.find(val);
        if (addrIt != procState.valueMap.end()) {
          uint64_t blockAddr = addrIt->second.getUInt64();
          if (addr >= blockAddr && addr < blockAddr + memBlock.size) {
            block = &memBlock;
            offset = addr - blockAddr;
            break;
          }
        }
      }
    }

    if (block && block->initialized && offset + waiter.valueSize <= block->size) {
      // Read current value
      uint64_t currentValue = 0;
      for (unsigned i = 0; i < waiter.valueSize; ++i) {
        currentValue |=
            static_cast<uint64_t>(block->data[offset + i]) << (i * 8);
      }

      if (currentValue == waiter.lastValue) {
        // Value hasn't changed - keep waiting
        // Don't re-schedule - process will be checked when memory is written
        LLVM_DEBUG(llvm::dbgs()
                   << "  Memory event: value unchanged at 0x"
                   << llvm::format_hex(addr, 16) << " (value=" << currentValue
                   << "), process " << procId << " remains waiting\n");
        return;
      }

      // Value changed - wake up the process
      LLVM_DEBUG(llvm::dbgs()
                 << "  Memory event triggered for process " << procId
                 << ": address 0x" << llvm::format_hex(addr, 16) << " changed "
                 << waiter.lastValue << " -> " << currentValue << "\n");
      memoryEventWaiters.erase(memWaiterIt);
      state.waiting = false;
    } else {
      // Memory block not accessible - remove waiter and continue
      LLVM_DEBUG(llvm::dbgs()
                 << "  Memory event: block not accessible, removing waiter\n");
      memoryEventWaiters.erase(memWaiterIt);
      state.waiting = false;
    }
  }

  ScopedInstanceContext instScope(*this, state.instanceId);
  ScopedInputValueMap inputScope(*this, state.inputMap);

  if ((state.waiting || state.destBlock) &&
      canSkipCachedProcess(state, scheduler)) {
    SensitivityList waitList = buildSensitivityListFromState(state);
    if (!waitList.empty()) {
      ++state.cacheSkips;
      state.waiting = true;
      scheduler.suspendProcessForEvents(procId, waitList);
      return;
    }
  }

  // If resuming from a wait, set up the destination block
  // Note: waiting flag may already be cleared by resumeProcess, so check destBlock
  if (state.destBlock) {
    LLVM_DEBUG(llvm::dbgs() << "  Resuming to destination block\n");
    state.currentBlock = state.destBlock;

    // If resumeAtCurrentOp is set, keep currentOp as is (used for deferred
    // llhd.halt and sim.terminate). Otherwise, start from block beginning.
    if (!state.resumeAtCurrentOp) {
      state.currentOp = state.currentBlock->begin();
    }

    // Transfer destination operands to block arguments
    for (auto [arg, val] :
         llvm::zip(state.currentBlock->getArguments(), state.destOperands)) {
      state.valueMap[arg] = val;
      if (isa<llhd::RefType>(arg.getType()))
        state.refBlockArgSources.erase(arg);
    }

    state.waiting = false;
    state.destBlock = nullptr;
    state.destOperands.clear();
    state.resumeAtCurrentOp = false;
  } else if (state.waiting) {
    // Handle the case where a process was triggered by an event (via
    // triggerSensitiveProcesses) rather than by the delay callback
    // (resumeProcess). In this case, state.waiting may still be true but
    // destBlock is null because the scheduler directly scheduled the process.
    // This can happen when a process is triggered by a signal change while
    // it was waiting for that signal.
    //
    // IMPORTANT: If waitConditionRestartBlock is set, the process is waiting
    // on a wait(condition) that evaluated to false. In this case, we should
    // NOT resume the process - it should only resume when its poll callback
    // fires (which sets waiting=false before scheduling). This prevents an
    // infinite loop where the process is continuously re-scheduled, evaluates
    // the still-false condition, and sets waiting=true again, all at the same
    // simulation time.
    if (state.waitConditionRestartBlock) {
      LLVM_DEBUG(llvm::dbgs()
                 << "  Process triggered while waiting on wait(condition) - "
                    "ignoring spurious trigger, will resume via poll callback\n");
      return;
    }
    //
    // We need to clear the waiting flag so the execution loop will run.
    // The process will resume at its current position (which should be right
    // after the llhd.wait that set the waiting flag originally, or at the
    // wait's destination block if the process was waiting).
    LLVM_DEBUG(llvm::dbgs()
               << "  Warning: Process triggered while waiting but destBlock is "
                  "null. Clearing waiting flag and resuming.\n");
    state.waiting = false;
  }

  // Handle wait_condition restart: if we're resuming after a wait(condition)
  // that was false, we need to restart from the point where the condition
  // computation begins and invalidate only the relevant cached values.
  if (state.waitConditionRestartBlock) {
    LLVM_DEBUG(llvm::dbgs() << "  Restarting for wait_condition re-evaluation "
                            << "(invalidating " << state.waitConditionValuesToInvalidate.size()
                            << " cached values)\n");

    // Save the process body's position BEFORE overwriting with the function
    // body's restart point. Only save on the FIRST overwrite (when
    // waitConditionSavedBlock is null). On subsequent polls (when the condition
    // is still false), the saved position is already correct.
    //
    // IMPORTANT: When call stack frames are present, state.currentBlock may
    // have been overwritten by interpretFuncBody (which sets it to a
    // function-body block when detecting state.waiting). In that case, we
    // must derive the process-body position from the outermost call stack
    // frame's call site — the operation in the process body that started
    // the whole call chain.
    if (!state.waitConditionSavedBlock) {
      if (!state.callStack.empty()) {
        // Outermost frame is at the back. Its callOp is the call_indirect
        // in the process body. The process should resume AFTER that op.
        auto &outermostFrame = state.callStack.back();
        if (outermostFrame.callOp) {
          state.waitConditionSavedBlock = outermostFrame.callOp->getBlock();
          state.waitConditionSavedOp =
              std::next(outermostFrame.callOp->getIterator());
        } else {
          state.waitConditionSavedBlock = state.currentBlock;
          state.waitConditionSavedOp = state.currentOp;
        }
      } else {
        state.waitConditionSavedBlock = state.currentBlock;
        state.waitConditionSavedOp = state.currentOp;
      }
    }

    // Set the current block and operation to the restart point
    state.currentBlock = state.waitConditionRestartBlock;
    state.currentOp = state.waitConditionRestartOp;

    // Clear only the cached values that are part of the condition computation.
    // This avoids re-executing side effects like fork creation.
    for (Value v : state.waitConditionValuesToInvalidate) {
      state.valueMap.erase(v);
    }

    // Note: we don't clear waitConditionRestartBlock here - it will be
    // cleared by __moore_wait_condition when the condition becomes true.

    // When wait_condition is inside a function called via vtable dispatch
    // (e.g., uvm_phase_hopper::get), call stack frames are saved with their
    // resume position AFTER the wait_condition call. This is wrong for
    // wait_condition because the condition needs to be RE-EVALUATED on each
    // poll, not skipped. Fix: override the innermost frame's resume position
    // to the restart point (before the condition computation, e.g., before
    // __moore_queue_size). This way, each poll re-executes the condition
    // check from scratch.
    if (!state.callStack.empty()) {
      auto &innermostFrame = state.callStack.front();
      innermostFrame.resumeOp = state.waitConditionRestartOp;
    }
  }

  // Handle sequencer get retry: if the seq_item_pull_port::get interceptor
  // found an empty FIFO, the innermost call stack frame was saved pointing
  // AFTER the call_indirect. Override it to point TO the call_indirect so
  // the get is re-executed (allowing the interceptor to check the FIFO again).
  if (state.sequencerGetRetryCallOp && !state.callStack.empty()) {
    auto &innermostFrame = state.callStack.front();
    innermostFrame.resumeOp =
        state.sequencerGetRetryCallOp->getIterator();
    innermostFrame.resumeBlock = state.sequencerGetRetryCallOp->getBlock();
    LLVM_DEBUG(llvm::dbgs()
               << "  Overriding innermost frame for sequencer get retry\n");
    state.sequencerGetRetryCallOp = nullptr;
  } else if (state.sequencerGetRetryCallOp && state.callStack.empty()) {
    // At process top level (no function call stack): override currentOp
    // directly so the call_indirect is re-executed on the next activation.
    state.currentOp = state.sequencerGetRetryCallOp->getIterator();
    state.currentBlock = state.sequencerGetRetryCallOp->getBlock();
    LLVM_DEBUG(llvm::dbgs()
               << "  Overriding process-level currentOp for sequencer "
               << "get/finish_item retry\n");
    state.sequencerGetRetryCallOp = nullptr;
  }

  // Handle call stack frames: if we have saved call frames from a wait inside
  // a function, we need to resume execution inside those functions instead of
  // continuing at the process level.
  if (!state.callStack.empty()) {
    LLVM_DEBUG(llvm::dbgs()
               << "  Process has " << state.callStack.size()
               << " saved call stack frame(s), resuming from innermost\n");

    // Process call stack frames from INNERMOST to OUTERMOST.
    // Frames are stored [innermost, ..., outermost] in the vector (deepest
    // callee pushed first, each caller pushed after).  We pop from FRONT
    // (innermost first).
    //
    // Example: process_phase → sync_phase → wait_for_state suspends.
    // callStack = [wait_for_state, sync_phase, process_phase]
    //   1. Resume wait_for_state (innermost): condition true → returns results
    //   2. Set results on wait_for_state's callOp (call_indirect in sync_phase)
    //   3. Resume sync_phase: continues checking predecessors → completes
    //   4. Set results on sync_phase's callOp (call_indirect in process_phase)
    //   5. Resume process_phase: continues from after sync_phase → start→...
    //
    // This ensures nested functions complete before their callers continue,
    // which is critical for sync_phase to finish predecessor checking before
    // process_phase proceeds to start_phase.
    //
    // Save the outermost frame's call site for process-body position
    // restoration after all frames complete.  The outermost frame's callOp
    // is the call_indirect/call in the process body that originally started
    // the function call chain.  After all frames return, we resume from the
    // operation AFTER that call.
    Operation *outermostCallOp = state.callStack.back().callOp;
    while (!state.callStack.empty()) {
      CallStackFrame frame = std::move(state.callStack.front());
      state.callStack.erase(state.callStack.begin());

      // Track how many old (outer) frames remain before resuming.
      // If the function re-suspends, new frames are pushed to the back.
      // We need to distinguish old outer frames from new inner frames.
      size_t oldFrameCount = state.callStack.size();

      llvm::StringRef frameName =
          frame.isLLVM() ? frame.llvmFuncOp.getName()
                         : frame.funcOp.getName();
      LLVM_DEBUG(llvm::dbgs()
                 << "    Resuming " << (frame.isLLVM() ? "LLVM " : "")
                 << "function '" << frameName << "' (remaining old frames: "
                 << oldFrameCount << ")\n");

      // Resume the function from its saved position
      llvm::SmallVector<InterpretedValue, 4> results;
      ++state.callDepth;
      LogicalResult funcResult =
          frame.isLLVM()
              ? interpretLLVMFuncBody(procId, frame.llvmFuncOp, frame.args,
                                      results, frame.callOperands,
                                      frame.callOp, frame.resumeBlock,
                                      frame.resumeOp)
              : interpretFuncBody(procId, frame.funcOp, frame.args, results,
                                  frame.callOp, frame.resumeBlock,
                                  frame.resumeOp);
      --state.callDepth;

      if (failed(funcResult)) {
        LLVM_DEBUG(llvm::dbgs()
                   << "    Function '" << frameName
                   << "' failed during resume\n");
        finalizeProcess(procId, /*killed=*/false);
        return;
      }

      // Check if the function suspended again
      if (state.waiting) {
        LLVM_DEBUG(llvm::dbgs()
                   << "    Function '" << frameName
                   << "' suspended again during resume, "
                   << "callStack size=" << state.callStack.size()
                   << " (old outer: " << oldFrameCount << ")\n");

        // The function re-suspended.  New frames were pushed to the back
        // of callStack.  Old outer frames are still at the front (indices
        // 0..oldFrameCount-1).  The new inner frames are at the back
        // (indices oldFrameCount..).
        //
        // For next resume, we need innermost-first ordering:
        //   [new_inner_frames..., old_outer_frames...]
        // Currently the stack is:
        //   [old_outer_frames..., new_inner_frames...]
        // Rotate so new inner frames come first.
        if (oldFrameCount > 0 && state.callStack.size() > oldFrameCount) {
          std::rotate(state.callStack.begin(),
                      state.callStack.begin() + oldFrameCount,
                      state.callStack.end());
          LLVM_DEBUG(llvm::dbgs()
                     << "    Rotated stack: moved " << oldFrameCount
                     << " old frames after "
                     << (state.callStack.size() - oldFrameCount)
                     << " new frames\n");
        }

        // Schedule pending delay if any before returning
        if (state.pendingDelayFs > 0) {
          SimTime currentTime = scheduler.getCurrentTime();
          SimTime targetTime = currentTime.advanceTime(state.pendingDelayFs);
          LLVM_DEBUG(llvm::dbgs()
                     << "    Scheduling delay " << state.pendingDelayFs
                     << " fs from function suspend\n");
          state.pendingDelayFs = 0;
          scheduler.getEventScheduler().schedule(
              targetTime, SchedulingRegion::Active,
              Event([this, procId]() { resumeProcess(procId); }));
        }
        return;
      }

      // Function completed - set its results on the call operation
      if (frame.callOp) {
        if (auto callIndirectOp =
                dyn_cast<mlir::func::CallIndirectOp>(frame.callOp)) {
          for (auto [result, retVal] :
               llvm::zip(callIndirectOp.getResults(), results)) {
            setValue(procId, result, retVal);
          }
        } else if (auto callOp = dyn_cast<mlir::func::CallOp>(frame.callOp)) {
          for (auto [result, retVal] :
               llvm::zip(callOp.getResults(), results)) {
            setValue(procId, result, retVal);
          }
        } else if (auto llvmCallOp =
                       dyn_cast<LLVM::CallOp>(frame.callOp)) {
          for (auto [result, retVal] :
               llvm::zip(llvmCallOp.getResults(), results)) {
            setValue(procId, result, retVal);
          }
        }
      }

      LLVM_DEBUG(llvm::dbgs()
                 << "    Function '" << frameName
                 << "' completed, continuing to next frame\n");

      // If the completed frame's execution added new frames (from a
      // different call path than the original suspension), those new
      // frames belong to the completed function's call chain and are
      // now stale (the function already returned past them).  Remove
      // any frames that were added during this iteration.
      if (state.callStack.size() > oldFrameCount) {
        size_t newFrames = state.callStack.size() - oldFrameCount;
        LLVM_DEBUG(llvm::dbgs()
                   << "    Removing " << newFrames
                   << " stale frames added by completed function\n");
        // New frames are at the back (pushed during execution)
        state.callStack.resize(oldFrameCount);
      }
    }

    // All call stack frames processed — restore process body position.
    //
    // When functions are called from the process body's main loop (via
    // call_indirect, func.call, etc.) and they suspend, interpretFuncBody
    // overwrites state.currentBlock/currentOp with function-body positions.
    // After all frames complete, we MUST restore the process body position
    // so the main loop continues from the right place.
    //
    // Two sources for the correct position:
    // 1. waitConditionSavedBlock (set during wait_condition handling above)
    // 2. outermostCallOp (the call in the process body that started the chain)
    //
    // Use waitConditionSavedBlock if available (it was saved before the
    // restart block override). Otherwise, derive from outermostCallOp.
    if (state.waitConditionSavedBlock) {
      state.currentBlock = state.waitConditionSavedBlock;
      state.currentOp = state.waitConditionSavedOp;
      state.waitConditionSavedBlock = nullptr;
    } else if (outermostCallOp) {
      // Derive from the outermost frame's call operation in the process body.
      // Resume at the operation AFTER the call.
      state.currentBlock = outermostCallOp->getBlock();
      state.currentOp = std::next(outermostCallOp->getIterator());
    }
    // Clear any leftover wait_condition state.
    state.waitConditionRestartBlock = nullptr;

    LLVM_DEBUG(llvm::dbgs()
               << "  Call stack frames exhausted, continuing process\n");
  }

  LLVM_DEBUG(llvm::dbgs() << "LLHDProcessInterpreter: Executing process "
                          << procId << "\n");


  // Execute operations until we suspend or halt
  constexpr size_t kAbortCheckInterval = 1000;
  // Per-activation step limit: if a process runs this many steps in a single
  // activation without hitting llhd.wait, it's an infinite loop (e.g.,
  // combinational always blocks or deferred assertions like `assume #0`).
  constexpr size_t kMaxStepsPerActivation = 10000000;
  size_t localStepCount = 0;
  while (!state.halted && !state.waiting) {
    ++localStepCount;
    // Periodically check for abort or termination requests.
    // terminationRequested is set when sim.terminate fires (e.g., UVM die()
    // after UVM_FATAL). We must stop all processes promptly to avoid hanging
    // when forked children are stuck waiting for events that will never arrive
    // (e.g., missing BFMs in HVL-only AVIPs like AXI4Lite).
    if (localStepCount % kAbortCheckInterval == 0) {
      if (isAbortRequested()) {
        LLVM_DEBUG(llvm::dbgs() << "  Abort requested, halting process\n");
        finalizeProcess(procId, /*killed=*/false);
        if (abortCallback)
          abortCallback();
        break;
      }
      if (terminationRequested) {
        LLVM_DEBUG(llvm::dbgs()
                   << "  Termination requested, halting process " << procId
                   << "\n");
        finalizeProcess(procId, /*killed=*/false);
        break;
      }
    }
    // Per-activation infinite loop detection: if a process runs too many
    // steps without hitting llhd.wait (which sets state.waiting=true), it's
    // stuck in a combinational loop. Finalize it to prevent hanging.
    // UVM build_phase with complex config_db lookups can legitimately need
    // many steps, so set a generous limit.
    if (localStepCount > kMaxStepsPerActivation) {
      llvm::errs() << "[circt-sim] WARNING: Process " << procId;
      if (auto *proc = scheduler.getProcess(procId))
        llvm::errs() << " '" << proc->getName() << "'";
      llvm::errs() << " exceeded per-activation step limit ("
                   << kMaxStepsPerActivation << ") - killing\n";
      finalizeProcess(procId, /*killed=*/false);
      break;
    }
    LLVM_DEBUG({
      if (localStepCount <= 10 || localStepCount % 1000 == 0) {
        llvm::dbgs() << "[executeProcess] proc " << procId << " step "
                     << localStepCount;
        if (state.currentOp != state.currentBlock->end())
          llvm::dbgs() << " op: " << state.currentOp->getName().getStringRef();
        llvm::dbgs() << "\n";
      }
    });
    // Global step limit check (totalSteps includes func body ops)
    if (maxProcessSteps > 0 && state.totalSteps > maxProcessSteps) {
      llvm::errs() << "[circt-sim] ERROR(PROCESS_STEP_OVERFLOW): process "
                   << procId;
      if (auto *proc = scheduler.getProcess(procId))
        llvm::errs() << " '" << proc->getName() << "'";
      llvm::errs() << " exceeded " << maxProcessSteps << " total steps";
      llvm::errs() << " (totalSteps=" << state.totalSteps
                   << ", funcBodySteps=" << state.funcBodySteps << ")";
      if (!state.currentFuncName.empty())
        llvm::errs() << " [in " << state.currentFuncName << "]";
      if (state.lastOp)
        llvm::errs() << " (lastOp=" << state.lastOp->getName().getStringRef()
                     << ")";
      llvm::errs() << "\n";
      finalizeProcess(procId, /*killed=*/false);
      break;
    }
    if (!executeStep(procId))
      break;
  }


  // After the loop exits, check if we have pending delay from __moore_delay.
  // If so, schedule the resumption event with the accumulated delay.
  if (state.waiting && state.pendingDelayFs > 0) {
    SimTime currentTime = scheduler.getCurrentTime();
    SimTime targetTime = currentTime.advanceTime(state.pendingDelayFs);

    LLVM_DEBUG(llvm::dbgs() << "  Scheduling __moore_delay resumption: "
                            << state.pendingDelayFs << " fs from time "
                            << currentTime.realTime << " to "
                            << targetTime.realTime << "\n");

    // Reset the pending delay before scheduling
    state.pendingDelayFs = 0;

    // Schedule resumption at the target time
    scheduler.getEventScheduler().schedule(
        targetTime, SchedulingRegion::Active,
        Event([this, procId]() { resumeProcess(procId); }));
  }

  // Restore the previously active process state.
  activeProcessId = savedActiveProcessId;
  activeProcessState = savedActiveProcessState;
}

bool LLHDProcessInterpreter::executeStep(ProcessId procId) {
  // Use the cached active process state when available to avoid
  // an O(log n) std::map lookup on every single operation.
  ProcessExecutionState *statePtr;
  if (procId == activeProcessId && activeProcessState) {
    statePtr = activeProcessState;
  } else {
    auto it = processStates.find(procId);
    if (it == processStates.end())
      return false;
    statePtr = &it->second;
  }

  ProcessExecutionState &state = *statePtr;

  // Check if we've reached the end of the block
  if (state.currentOp == state.currentBlock->end()) {
    // Shouldn't happen - blocks should end with terminators
    return false;
  }

  Operation *op = &*state.currentOp;
  ++state.currentOp;
  state.lastOp = op;
  ++state.totalSteps;
  maybeSampleMemoryState(state.totalSteps);
  if (collectOpStats)
    ++opStats[op->getName().getStringRef()];

  LLVM_DEBUG(llvm::dbgs() << "  Executing: " << *op << "\n");

  // Interpret the operation
  if (failed(interpretOperation(procId, op))) {
    LLVM_DEBUG(llvm::dbgs() << "  Failed to interpret operation\n");
    // Always emit diagnostic for failed operations (not just in debug mode)
    llvm::errs() << "circt-sim: interpretOperation failed for process "
                 << procId << "\n";
    llvm::errs() << "  Operation: ";
    op->print(llvm::errs(), OpPrintingFlags().printGenericOpForm());
    llvm::errs() << "\n";
    llvm::errs() << "  Location: " << op->getLoc() << "\n";
    return false;
  }


  return !state.halted && !state.waiting;
}

void LLHDProcessInterpreter::resumeProcess(ProcessId procId) {
  auto it = processStates.find(procId);
  if (it == processStates.end())
    return;

  // Clear waiting state and schedule for execution
  it->second.waiting = false;
  scheduler.scheduleProcess(procId, SchedulingRegion::Active);
}

ProcessId LLHDProcessInterpreter::resolveProcessHandle(uint64_t handle) {
  if (handle == 0)
    return InvalidProcessId;

  auto it = processHandleToId.find(handle);
  if (it != processHandleToId.end())
    return it->second;

  for (auto &entry : processStates) {
    if (reinterpret_cast<uint64_t>(&entry.second) == handle) {
      processHandleToId[handle] = entry.first;
      return entry.first;
    }
  }

  return InvalidProcessId;
}

void LLHDProcessInterpreter::registerProcessState(
    ProcessId procId, ProcessExecutionState &&state,
    std::optional<uint32_t> initialSeed) {
  auto insertResult = processStates.try_emplace(procId, std::move(state));
  if (!insertResult.second)
    insertResult.first->second = std::move(state);

  // If an explicit seed was provided (e.g. from a parent RNG during fork),
  // use it; otherwise fall back to the default deterministic seed.
  uint32_t seed = initialSeed.value_or(static_cast<uint32_t>(procId) ^ 0xC0FFEEu);
  insertResult.first->second.randomGenerator.seed(seed);

  uint64_t handle =
      reinterpret_cast<uint64_t>(&insertResult.first->second);
  processHandleToId[handle] = procId;
}

void LLHDProcessInterpreter::notifyProcessAwaiters(ProcessId procId) {
  auto it = processAwaiters.find(procId);
  if (it == processAwaiters.end())
    return;

  for (ProcessId waiterId : it->second)
    resumeProcess(waiterId);

  processAwaiters.erase(it);
}

void LLHDProcessInterpreter::forwardPropagateOnSignalChange(
    SignalId signal, const SignalValue &value) {
  auto propIt = interfaceFieldPropagation.find(signal);
  if (propIt == interfaceFieldPropagation.end())
    return;

  InterpretedValue parentVal = InterpretedValue::fromSignalValue(value);
  for (SignalId childSigId : propIt->second) {
    const SignalValue &childCurrent = scheduler.getSignalValue(childSigId);
    unsigned childW = childCurrent.getWidth();
    InterpretedValue childDriveVal = parentVal;
    if (childDriveVal.isX()) {
      childDriveVal = InterpretedValue::makeX(childW);
    } else if (childDriveVal.getWidth() != childW) {
      APInt apVal = childDriveVal.getAPInt();
      if (apVal.getBitWidth() < childW)
        apVal = apVal.zext(childW);
      else if (apVal.getBitWidth() > childW)
        apVal = apVal.trunc(childW);
      childDriveVal = InterpretedValue(apVal);
    }
    scheduler.updateSignal(childSigId, childDriveVal.toSignalValue());

    auto childAddrIt = fieldSignalToAddr.find(childSigId);
    if (childAddrIt != fieldSignalToAddr.end()) {
      uint64_t childAddr = childAddrIt->second;
      uint64_t off = 0;
      MemoryBlock *block = findBlockByAddress(childAddr, off);
      unsigned storeSize = (childW + 7) / 8;
      if (block && off + storeSize <= block->size && !childDriveVal.isX()) {
        APInt bits = childDriveVal.getAPInt();
        if (bits.getBitWidth() < storeSize * 8)
          bits = bits.zext(storeSize * 8);
        for (unsigned i = 0; i < storeSize; ++i)
          block->data[off + i] = bits.extractBitsAsZExtValue(8, i * 8);
      }
    }
  }
}

void LLHDProcessInterpreter::finalizeProcess(ProcessId procId, bool killed) {
  if (auto *proc = scheduler.getProcess(procId)) {
    if (proc->getState() == ProcessState::Terminated) {
      notifyProcessAwaiters(procId);
      return;
    }
  }
  auto it = processStates.find(procId);
  if (it != processStates.end()) {
    it->second.halted = true;
    it->second.jitThunkResumeToken = 0;
    if (killed)
      it->second.killed = true;
    // Migrate memory blocks and value mappings to active child processes
    // before clearing.  Children reference parent memory via the
    // parentProcessId chain, so clearing a parent's memoryBlocks/valueMap
    // would make those blocks unreachable (causing stores through refs to
    // be silently skipped).  This is critical for UVM's phase hopper: the
    // run_phases function creates an alloca for the phase output variable,
    // then forks a loop child that calls get() which stores to that alloca
    // via a ref parameter.  If the parent halts first, the child can no
    // longer find the alloca's memory block.
    if (!it->second.memoryBlocks.empty()) {
      for (auto &[childProcId, childState] : processStates) {
        if (childState.parentProcessId == procId && !childState.halted) {
          for (auto &[val, block] : it->second.memoryBlocks) {
            if (childState.memoryBlocks.find(val) ==
                childState.memoryBlocks.end())
              childState.memoryBlocks[val] = std::move(block);
          }
          for (auto &[val, iv] : it->second.valueMap) {
            if (childState.valueMap.find(val) == childState.valueMap.end())
              childState.valueMap[val] = iv;
          }
          break; // adopt into first active child only
        }
      }
    }

    // Persist process results before clearing valueMap so that
    // module-level drives depending on process outputs still work.
    if (auto processOp = it->second.getProcessOp()) {
      for (auto result : processOp.getResults()) {
        auto valIt = it->second.valueMap.find(result);
        if (valIt != it->second.valueMap.end())
          persistedProcessResults[result] = valIt->second;
      }
    }

    // Free heavyweight data structures to prevent unbounded memory growth.
    // The entry itself is kept (with halted=true) so callers that check
    // the halted flag still work correctly.
    it->second.valueMap.clear();
    it->second.memoryBlocks.clear();
    it->second.funcResultCache.clear();
    it->second.recursionVisited.clear();
    it->second.waitSensitivityCache.clear();
    it->second.callStack.clear();
    it->second.refBlockArgSources.clear();
  }

  if (!finishItemWaiters.empty()) {
    llvm::SmallVector<uint64_t, 4> staleItems;
    for (const auto &entry : finishItemWaiters) {
      if (entry.second == procId)
        staleItems.push_back(entry.first);
    }
    for (uint64_t itemAddr : staleItems) {
      finishItemWaiters.erase(itemAddr);
      itemDoneReceived.erase(itemAddr);
      (void)takeUvmSequencerItemOwner(itemAddr);
    }
  }

  if (forkJoinManager.getForkGroupForChild(procId))
    forkJoinManager.markChildComplete(procId);

  scheduler.terminateProcess(procId);
  notifyProcessAwaiters(procId);
}

void LLHDProcessInterpreter::killProcessTree(ProcessId procId) {
  // First, recursively kill all fork children of this process.
  for (ForkId forkId : forkJoinManager.getForksForParent(procId)) {
    if (auto *group = forkJoinManager.getForkGroup(forkId)) {
      for (ProcessId childId : group->childProcesses) {
        auto childIt = processStates.find(childId);
        if (childIt != processStates.end() && !childIt->second.halted)
          killProcessTree(childId); // Recurse into grandchildren
      }
    }
  }
  // Then kill this process itself.
  finalizeProcess(procId, /*killed=*/true);
}

//===----------------------------------------------------------------------===//
// Time Conversion
//===----------------------------------------------------------------------===//

SimTime LLHDProcessInterpreter::convertTime(llhd::TimeAttr timeAttr) {
  // TimeAttr has: time value, time unit, delta, epsilon
  // We need to convert to femtoseconds

  uint64_t realTime = timeAttr.getTime();
  llvm::StringRef unit = timeAttr.getTimeUnit();

  // Convert to femtoseconds based on unit
  // 1 fs = 1
  // 1 ps = 1000 fs
  // 1 ns = 1000000 fs
  // 1 us = 1000000000 fs
  // 1 ms = 1000000000000 fs
  // 1 s  = 1000000000000000 fs

  uint64_t multiplier = 1;
  if (unit == "fs")
    multiplier = 1;
  else if (unit == "ps")
    multiplier = 1000;
  else if (unit == "ns")
    multiplier = 1000000;
  else if (unit == "us")
    multiplier = 1000000000;
  else if (unit == "ms")
    multiplier = 1000000000000ULL;
  else if (unit == "s")
    multiplier = 1000000000000000ULL;

  uint64_t timeFemtoseconds = realTime * multiplier;

  // Delta and epsilon are stored in the deltaStep and region
  unsigned delta = timeAttr.getDelta();
  unsigned epsilon = timeAttr.getEpsilon();

  // For now, we treat epsilon as additional delta steps
  // (This is a simplification - proper handling would need separate tracking)
  return SimTime(timeFemtoseconds, delta + epsilon);
}

SimTime LLHDProcessInterpreter::convertTimeValue(ProcessId procId,
                                                  Value timeValue) {
  // Look up the interpreted value for the time
  InterpretedValue val = getValue(procId, timeValue);

  // If it's from a constant_time op, we should have stored the TimeAttr
  if (auto constTimeOp = timeValue.getDefiningOp<llhd::ConstantTimeOp>()) {
    return convertTime(constTimeOp.getValueAttr());
  }

  // For other cases, treat as femtoseconds value
  return SimTime(val.getUInt64());
}

//===----------------------------------------------------------------------===//
// Operation Handlers
//===----------------------------------------------------------------------===//

LogicalResult LLHDProcessInterpreter::interpretOperation(ProcessId procId,
                                                          Operation *op) {
  g_lastOpName = op->getName().getStringRef().data();
  g_lastProcId = procId;
  // Fast-path: check dialect namespace to skip irrelevant dyn_cast chains.
  // 93%+ of ops in LLVM function bodies are LLVM/comb/arith dialect, but
  // without this check they'd fail 20+ LLHD/sim/seq/moore dyn_casts first.
  // A single pointer comparison routes to the correct section immediately.
  mlir::Dialect *dialect = op->getDialect();
  if (dialect) {
    llvm::StringRef dialectNS = dialect->getNamespace();
    // LLVM ops (22% call + 15% load + 15% extractvalue + 7% zext + ...)
    if (dialectNS == "llvm")
      goto llvm_dispatch;
    // comb ops (15% icmp + ...)
    if (dialectNS == "comb")
      goto comb_dispatch;
    // arith ops (15% trunci + ...)
    if (dialectNS == "arith")
      goto arith_dispatch;
  }

  // Dispatch to specific handlers based on operation type

  // LLHD operations
  if (auto probeOp = dyn_cast<llhd::ProbeOp>(op))
    return interpretProbe(procId, probeOp);

  if (auto driveOp = dyn_cast<llhd::DriveOp>(op))
    return interpretDrive(procId, driveOp);

  if (auto waitOp = dyn_cast<llhd::WaitOp>(op)) {
    return interpretWait(procId, waitOp);
  }

  if (auto haltOp = dyn_cast<llhd::HaltOp>(op))
    return interpretHalt(procId, haltOp);

  if (auto constTimeOp = dyn_cast<llhd::ConstantTimeOp>(op))
    return interpretConstantTime(procId, constTimeOp);

  // Handle llhd.sig.extract - extracts a bit range from a signal/ref.
  // For signal-backed refs, propagate the signal mapping.
  // For alloca-backed refs, just succeed - llhd.drv/llhd.prb trace the def chain.
  if (auto sigExtractOp = dyn_cast<llhd::SigExtractOp>(op)) {
    // Try to propagate signal mapping from input to result
    SignalId inputSigId = getSignalId(sigExtractOp.getInput());
    if (inputSigId == 0)
      inputSigId = resolveSignalId(sigExtractOp.getInput());
    if (inputSigId != 0) {
      valueToSignal[sigExtractOp.getResult()] = inputSigId;
    }
    // For alloca-backed refs, the result is just a narrowed ref.
    // The drv/prb handlers will trace back through this op to find
    // the alloca and compute the bit offset.
    return success();
  }

  // Handle llhd.sig.struct_extract - extracts a struct field from a signal/ref.
  // For signal-backed refs, propagate the signal mapping.
  // For alloca-backed refs (including function arguments), the drv/prb handlers
  // trace back through this op to find the memory block and compute offsets.
  if (auto sigStructExtractOp = dyn_cast<llhd::SigStructExtractOp>(op)) {
    SignalId inputSigId = getSignalId(sigStructExtractOp.getInput());
    if (inputSigId == 0)
      inputSigId = resolveSignalId(sigStructExtractOp.getInput());
    if (inputSigId != 0) {
      valueToSignal[sigStructExtractOp.getResult()] = inputSigId;
    }
    // For memory-backed refs, also propagate the address so that
    // getValue() on this result returns the parent address. This helps
    // the drv/prb memory-backed fallback paths.
    InterpretedValue inputVal = getValue(procId, sigStructExtractOp.getInput());
    if (!inputVal.isX() && inputVal.getUInt64() != 0) {
      setValue(procId, sigStructExtractOp.getResult(), inputVal);
    }
    return success();
  }

  // Handle llhd.sig.array_get - extracts an array element from a signal/ref.
  // NOTE: We do NOT map the result to the parent signal in valueToSignal.
  // The probe/drive paths handle SigArrayGetOp by tracing back via
  // getDefiningOp to find the parent signal and compute the element offset.
  // Mapping to the parent signal would cause block-arg propagation to
  // drive the ENTIRE parent array instead of the specific element.
  if (auto sigArrayGetOp = dyn_cast<llhd::SigArrayGetOp>(op)) {
    return success();
  }

  // Handle llhd.sig (runtime signal creation for local variables in initial blocks)
  // When global constructors or initial blocks execute, local variable declarations
  // produce llhd.sig operations at runtime. We need to dynamically register these
  // signals so that subsequent probe/drive operations can access them.
  if (auto sigOp = dyn_cast<llhd::SignalOp>(op)) {
    // Get the initial value from the process's value map
    InterpretedValue initVal = getValue(procId, sigOp.getInit());

    // Generate a unique name for this runtime signal
    std::string name = sigOp.getName().value_or("").str();
    if (name.empty()) {
      name = "runtime_sig_" + std::to_string(valueToSignal.size());
    }

    // Get the type width
    Type innerType = sigOp.getInit().getType();
    unsigned width = getTypeWidth(innerType);

    // Register with the scheduler
    SignalId sigId =
        scheduler.registerSignal(name, width, getSignalEncoding(innerType));

    // Store the mapping from the signal result to the signal ID
    valueToSignal[sigOp.getResult()] = sigId;
    signalIdToName[sigId] = name;
    signalIdToType[sigId] = innerType;

    // Set the initial value
    if (!initVal.isX()) {
      SignalValue sv = initVal.toSignalValue();
      scheduler.updateSignal(sigId, sv);
    }

    LLVM_DEBUG(llvm::dbgs() << "  Runtime signal '" << name << "' registered with ID "
                            << sigId << " (width=" << width << ", init="
                            << (initVal.isX() ? "X" : std::to_string(initVal.getUInt64()))
                            << ")\n");

    return success();
  }

  // Sim dialect operations - for $display support
  if (auto printOp = dyn_cast<sim::PrintFormattedProcOp>(op))
    return interpretProcPrint(procId, printOp);

  // Sim dialect operations - for $finish support
  if (auto terminateOp = dyn_cast<sim::TerminateOp>(op))
    return interpretTerminate(procId, terminateOp);

  // Sim dialect operations - for fork/join support
  if (auto forkOp = dyn_cast<sim::SimForkOp>(op))
    return interpretSimFork(procId, forkOp);

  if (auto forkTermOp = dyn_cast<sim::SimForkTerminatorOp>(op))
    return interpretSimForkTerminator(procId, forkTermOp);

  if (auto joinOp = dyn_cast<sim::SimJoinOp>(op))
    return interpretSimJoin(procId, joinOp);

  if (auto joinAnyOp = dyn_cast<sim::SimJoinAnyOp>(op))
    return interpretSimJoinAny(procId, joinAnyOp);

  if (auto waitForkOp = dyn_cast<sim::SimWaitForkOp>(op))
    return interpretSimWaitFork(procId, waitForkOp);

  if (auto disableForkOp = dyn_cast<sim::SimDisableForkOp>(op))
    return interpretSimDisableFork(procId, disableForkOp);

  // Seq dialect operations - seq.yield terminates seq.initial blocks
  if (auto yieldOp = dyn_cast<seq::YieldOp>(op))
    return interpretSeqYield(procId, yieldOp);

  // Moore dialect operations - wait_event suspends until signal change
  // These operations should have been converted to llhd.wait by the
  // MooreToCore pass, but when they appear in function bodies that haven't
  // been inlined, we need to handle them directly.
  if (auto waitEventOp = dyn_cast<moore::WaitEventOp>(op))
    return interpretMooreWaitEvent(procId, waitEventOp);

  // Moore detect_event ops inside wait_event bodies - handled by wait_event
  if (isa<moore::DetectEventOp>(op)) {
    // DetectEventOp is only meaningful inside WaitEventOp - it sets up
    // edge detection. When executed standalone, just skip it.
    return success();
  }

  // Format string operations are consumed by interpretProcPrint - just return
  // success as they don't need individual interpretation
  if (isa<sim::FormatLiteralOp, sim::FormatHexOp, sim::FormatDecOp,
          sim::FormatBinOp, sim::FormatOctOp, sim::FormatCharOp,
          sim::FormatStringConcatOp, sim::FormatDynStringOp>(op)) {
    // These ops are evaluated lazily when their results are used
    return success();
  }

  // HW constant operations
  if (auto constOp = dyn_cast<hw::ConstantOp>(op)) {
    APInt value = constOp.getValue();
    setValue(procId, constOp.getResult(),
             InterpretedValue(value));
    return success();
  }

  // Control flow operations
  if (auto branchOp = dyn_cast<mlir::cf::BranchOp>(op)) {
    auto *statePtr = (procId == activeProcessId && activeProcessState)
                         ? activeProcessState : &processStates[procId];
    statePtr->currentBlock = branchOp.getDest();
    statePtr->currentOp = statePtr->currentBlock->begin();

    // Transfer operands to block arguments
    for (auto [arg, operand] : llvm::zip(statePtr->currentBlock->getArguments(),
                                          branchOp.getDestOperands())) {
      statePtr->valueMap[arg] = getValue(procId, operand);
      if (isa<llhd::RefType>(arg.getType()))
        statePtr->refBlockArgSources[arg] = operand;
      else
        statePtr->refBlockArgSources.erase(arg);
      if (isa<llhd::RefType>(arg.getType())) {
        if (SignalId sigId = resolveSignalId(operand))
          valueToSignal[arg] = sigId;
        else
          valueToSignal.erase(arg);
      }
    }
    return success();
  }

  if (auto condBranchOp = dyn_cast<mlir::cf::CondBranchOp>(op)) {
    auto *statePtr = (procId == activeProcessId && activeProcessState)
                         ? activeProcessState : &processStates[procId];
    InterpretedValue cond = getValue(procId, condBranchOp.getCondition());

    if (!cond.isX() && cond.getUInt64() != 0) {
      // True branch
      statePtr->currentBlock = condBranchOp.getTrueDest();
      statePtr->currentOp = statePtr->currentBlock->begin();
      for (auto [arg, operand] :
           llvm::zip(statePtr->currentBlock->getArguments(),
                     condBranchOp.getTrueDestOperands())) {
        statePtr->valueMap[arg] = getValue(procId, operand);
        if (isa<llhd::RefType>(arg.getType()))
          statePtr->refBlockArgSources[arg] = operand;
        else
          statePtr->refBlockArgSources.erase(arg);
        if (isa<llhd::RefType>(arg.getType())) {
          if (SignalId sigId = resolveSignalId(operand))
            valueToSignal[arg] = sigId;
          else
            valueToSignal.erase(arg);
        }
      }
    } else {
      // False branch (or X treated as false)
      statePtr->currentBlock = condBranchOp.getFalseDest();
      statePtr->currentOp = statePtr->currentBlock->begin();
      for (auto [arg, operand] :
           llvm::zip(statePtr->currentBlock->getArguments(),
                     condBranchOp.getFalseDestOperands())) {
        statePtr->valueMap[arg] = getValue(procId, operand);
        if (isa<llhd::RefType>(arg.getType()))
          statePtr->refBlockArgSources[arg] = operand;
        else
          statePtr->refBlockArgSources.erase(arg);
        if (isa<llhd::RefType>(arg.getType())) {
          if (SignalId sigId = resolveSignalId(operand))
            valueToSignal[arg] = sigId;
          else
            valueToSignal.erase(arg);
        }
      }
    }
    return success();
  }

  // Arithmetic/comb operations - basic support
comb_dispatch:
  if (auto icmpOp = dyn_cast<comb::ICmpOp>(op)) {
    InterpretedValue lhs = getValue(procId, icmpOp.getLhs());
    InterpretedValue rhs = getValue(procId, icmpOp.getRhs());

    if (lhs.isX() || rhs.isX()) {
      setValue(procId, icmpOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(icmpOp.getType())));
      return success();
    }

    bool result = false;
    APInt lhsVal = lhs.getAPInt();
    APInt rhsVal = rhs.getAPInt();
    // Normalize widths for comparison - use the larger of the two widths
    unsigned compareWidth = std::max(lhsVal.getBitWidth(), rhsVal.getBitWidth());
    normalizeWidths(lhsVal, rhsVal, compareWidth);
    switch (icmpOp.getPredicate()) {
    case comb::ICmpPredicate::eq:
    case comb::ICmpPredicate::ceq:
    case comb::ICmpPredicate::weq:
      result = lhsVal == rhsVal;
      break;
    case comb::ICmpPredicate::ne:
    case comb::ICmpPredicate::cne:
    case comb::ICmpPredicate::wne:
      result = lhsVal != rhsVal;
      break;
    case comb::ICmpPredicate::slt:
      result = lhsVal.slt(rhsVal);
      break;
    case comb::ICmpPredicate::sle:
      result = lhsVal.sle(rhsVal);
      break;
    case comb::ICmpPredicate::sgt:
      result = lhsVal.sgt(rhsVal);
      break;
    case comb::ICmpPredicate::sge:
      result = lhsVal.sge(rhsVal);
      break;
    case comb::ICmpPredicate::ult:
      result = lhsVal.ult(rhsVal);
      break;
    case comb::ICmpPredicate::ule:
      result = lhsVal.ule(rhsVal);
      break;
    case comb::ICmpPredicate::ugt:
      result = lhsVal.ugt(rhsVal);
      break;
    case comb::ICmpPredicate::uge:
      result = lhsVal.uge(rhsVal);
      break;
    }

    setValue(procId, icmpOp.getResult(), InterpretedValue(result ? 1 : 0, 1));
    return success();
  }

  if (auto andOp = dyn_cast<comb::AndOp>(op)) {
    unsigned targetWidth = getTypeWidth(andOp.getType());
    if (targetWidth <= 64) {
      uint64_t result = ~0ULL;
      uint64_t mask =
          (targetWidth == 64) ? ~0ULL : ((1ULL << targetWidth) - 1);
      for (Value operand : andOp.getOperands()) {
        InterpretedValue value = getValue(procId, operand);
        uint64_t operandVal = 0;
        if (!getMaskedUInt64(value, targetWidth, operandVal)) {
          setValue(procId, andOp.getResult(),
                   InterpretedValue::makeX(targetWidth));
          return success();
        }
        if ((operandVal & mask) == mask)
          continue;
        result &= operandVal;
        if (result == 0)
          break;
      }
      if (targetWidth < 64)
        result &= mask;
      setValue(procId, andOp.getResult(),
               InterpretedValue(result, targetWidth));
      return success();
    }
    llvm::APInt result(targetWidth, 0);
    result.setAllBits(); // Start with all 1s for AND
    for (Value operand : andOp.getOperands()) {
      InterpretedValue value = getValue(procId, operand);
      if (value.isX()) {
        setValue(procId, andOp.getResult(),
                 InterpretedValue::makeX(targetWidth));
        return success();
      }
      APInt operandVal = value.getAPInt();
      // Normalize to target width
      if (operandVal.getBitWidth() < targetWidth)
        operandVal = operandVal.zext(targetWidth);
      else if (operandVal.getBitWidth() > targetWidth)
        operandVal = operandVal.trunc(targetWidth);
      if (operandVal.isAllOnes())
        continue;
      result &= operandVal;
      if (result.isZero())
        break;
    }
    setValue(procId, andOp.getResult(), InterpretedValue(result));
    return success();
  }

  if (auto orOp = dyn_cast<comb::OrOp>(op)) {
    unsigned targetWidth = getTypeWidth(orOp.getType());
    if (targetWidth <= 64) {
      uint64_t result = 0;
      uint64_t mask =
          (targetWidth == 64) ? ~0ULL : ((1ULL << targetWidth) - 1);
      for (Value operand : orOp.getOperands()) {
        InterpretedValue value = getValue(procId, operand);
        uint64_t operandVal = 0;
        if (!getMaskedUInt64(value, targetWidth, operandVal)) {
          setValue(procId, orOp.getResult(),
                   InterpretedValue::makeX(targetWidth));
          return success();
        }
        if (operandVal == 0)
          continue;
        result |= operandVal;
        if ((result & mask) == mask)
          break;
      }
      if (targetWidth < 64)
        result &= mask;
      setValue(procId, orOp.getResult(),
               InterpretedValue(result, targetWidth));
      return success();
    }
    llvm::APInt result(targetWidth, 0); // Start with all 0s for OR
    for (Value operand : orOp.getOperands()) {
      InterpretedValue value = getValue(procId, operand);
      if (value.isX()) {
        setValue(procId, orOp.getResult(),
                 InterpretedValue::makeX(targetWidth));
        return success();
      }
      APInt operandVal = value.getAPInt();
      // Normalize to target width
      if (operandVal.getBitWidth() < targetWidth)
        operandVal = operandVal.zext(targetWidth);
      else if (operandVal.getBitWidth() > targetWidth)
        operandVal = operandVal.trunc(targetWidth);
      if (operandVal.isZero())
        continue;
      result |= operandVal;
      if (result.isAllOnes())
        break;
    }
    setValue(procId, orOp.getResult(), InterpretedValue(result));
    return success();
  }

  if (auto xorOp = dyn_cast<comb::XorOp>(op)) {
    unsigned targetWidth = getTypeWidth(xorOp.getType());
    if (targetWidth <= 64) {
      uint64_t result = 0;
      uint64_t mask =
          (targetWidth == 64) ? ~0ULL : ((1ULL << targetWidth) - 1);
      bool invert = false;
      for (Value operand : xorOp.getOperands()) {
        InterpretedValue value = getValue(procId, operand);
        uint64_t operandVal = 0;
        if (!getMaskedUInt64(value, targetWidth, operandVal)) {
          setValue(procId, xorOp.getResult(),
                   InterpretedValue::makeX(targetWidth));
          return success();
        }
        operandVal &= mask;
        if (operandVal == 0)
          continue;
        if (operandVal == mask) {
          invert = !invert;
          continue;
        }
        result ^= operandVal;
      }
      if (invert)
        result ^= mask;
      if (targetWidth < 64)
        result &= mask;
      setValue(procId, xorOp.getResult(),
               InterpretedValue(result, targetWidth));
      return success();
    }
    llvm::APInt result(targetWidth, 0); // Start with all 0s for XOR
    bool invert = false;
    for (Value operand : xorOp.getOperands()) {
      InterpretedValue value = getValue(procId, operand);
      if (value.isX()) {
        setValue(procId, xorOp.getResult(),
                 InterpretedValue::makeX(targetWidth));
        return success();
      }
      APInt operandVal = value.getAPInt();
      // Normalize to target width
      if (operandVal.getBitWidth() < targetWidth)
        operandVal = operandVal.zext(targetWidth);
      else if (operandVal.getBitWidth() > targetWidth)
        operandVal = operandVal.trunc(targetWidth);
      if (operandVal.isZero())
        continue;
      if (operandVal.isAllOnes()) {
        invert = !invert;
        continue;
      }
      result ^= operandVal;
    }
    if (invert)
      result ^= APInt::getAllOnes(targetWidth);
    setValue(procId, xorOp.getResult(), InterpretedValue(result));
    return success();
  }

  if (auto shlOp = dyn_cast<comb::ShlOp>(op)) {
    InterpretedValue lhs = getValue(procId, shlOp.getLhs());
    InterpretedValue rhs = getValue(procId, shlOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, shlOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(shlOp.getType())));
      return success();
    }
    uint64_t shift = rhs.getAPInt().getLimitedValue();
    unsigned bitWidth = lhs.getAPInt().getBitWidth();
    if (shift >= bitWidth) {
      setValue(procId, shlOp.getResult(),
               InterpretedValue(APInt::getZero(bitWidth)));
    } else {
      setValue(procId, shlOp.getResult(),
               InterpretedValue(lhs.getAPInt().shl(shift)));
    }
    return success();
  }

  if (auto shruOp = dyn_cast<comb::ShrUOp>(op)) {
    InterpretedValue lhs = getValue(procId, shruOp.getLhs());
    InterpretedValue rhs = getValue(procId, shruOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, shruOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(shruOp.getType())));
      return success();
    }
    uint64_t shift = rhs.getAPInt().getLimitedValue();
    unsigned bitWidth = lhs.getAPInt().getBitWidth();
    if (shift >= bitWidth) {
      setValue(procId, shruOp.getResult(),
               InterpretedValue(APInt::getZero(bitWidth)));
    } else {
      setValue(procId, shruOp.getResult(),
               InterpretedValue(lhs.getAPInt().lshr(shift)));
    }
    return success();
  }

  if (auto shrsOp = dyn_cast<comb::ShrSOp>(op)) {
    InterpretedValue lhs = getValue(procId, shrsOp.getLhs());
    InterpretedValue rhs = getValue(procId, shrsOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, shrsOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(shrsOp.getType())));
      return success();
    }
    uint64_t shift = rhs.getAPInt().getLimitedValue();
    unsigned bitWidth = lhs.getAPInt().getBitWidth();
    if (shift >= bitWidth) {
      setValue(procId, shrsOp.getResult(),
               InterpretedValue(
                   lhs.getAPInt().isNegative()
                       ? APInt::getAllOnes(bitWidth)
                       : APInt::getZero(bitWidth)));
    } else {
      setValue(procId, shrsOp.getResult(),
               InterpretedValue(lhs.getAPInt().ashr(shift)));
    }
    return success();
  }

  if (auto subOp = dyn_cast<comb::SubOp>(op)) {
    InterpretedValue lhs = getValue(procId, subOp.getLhs());
    InterpretedValue rhs = getValue(procId, subOp.getRhs());
    unsigned targetWidth = getTypeWidth(subOp.getType());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, subOp.getResult(),
               InterpretedValue::makeX(targetWidth));
      return success();
    }
    APInt lhsVal = lhs.getAPInt();
    APInt rhsVal = rhs.getAPInt();
    normalizeWidths(lhsVal, rhsVal, targetWidth);
    setValue(procId, subOp.getResult(),
             InterpretedValue(lhsVal - rhsVal));
    return success();
  }

  if (auto mulOp = dyn_cast<comb::MulOp>(op)) {
    unsigned targetWidth = getTypeWidth(mulOp.getType());
    llvm::APInt result(targetWidth, 1); // Start with 1 for multiplication
    for (Value operand : mulOp.getOperands()) {
      InterpretedValue value = getValue(procId, operand);
      if (value.isX()) {
        setValue(procId, mulOp.getResult(),
                 InterpretedValue::makeX(targetWidth));
        return success();
      }
      APInt operandVal = value.getAPInt();
      // Normalize to target width
      if (operandVal.getBitWidth() < targetWidth)
        operandVal = operandVal.zext(targetWidth);
      else if (operandVal.getBitWidth() > targetWidth)
        operandVal = operandVal.trunc(targetWidth);
      result *= operandVal;
    }
    setValue(procId, mulOp.getResult(), InterpretedValue(result));
    return success();
  }

  if (auto divsOp = dyn_cast<comb::DivSOp>(op)) {
    InterpretedValue lhs = getValue(procId, divsOp.getLhs());
    InterpretedValue rhs = getValue(procId, divsOp.getRhs());
    unsigned targetWidth = getTypeWidth(divsOp.getType());
    if (lhs.isX() || rhs.isX() || rhs.getAPInt().isZero()) {
      setValue(procId, divsOp.getResult(),
               InterpretedValue::makeX(targetWidth));
      return success();
    }
    APInt lhsVal = lhs.getAPInt();
    APInt rhsVal = rhs.getAPInt();
    normalizeWidths(lhsVal, rhsVal, targetWidth);
    setValue(procId, divsOp.getResult(),
             InterpretedValue(lhsVal.sdiv(rhsVal)));
    return success();
  }

  if (auto divuOp = dyn_cast<comb::DivUOp>(op)) {
    InterpretedValue lhs = getValue(procId, divuOp.getLhs());
    InterpretedValue rhs = getValue(procId, divuOp.getRhs());
    unsigned targetWidth = getTypeWidth(divuOp.getType());
    if (lhs.isX() || rhs.isX() || rhs.getAPInt().isZero()) {
      setValue(procId, divuOp.getResult(),
               InterpretedValue::makeX(targetWidth));
      return success();
    }
    APInt lhsVal = lhs.getAPInt();
    APInt rhsVal = rhs.getAPInt();
    normalizeWidths(lhsVal, rhsVal, targetWidth);
    setValue(procId, divuOp.getResult(),
             InterpretedValue(lhsVal.udiv(rhsVal)));
    return success();
  }

  if (auto modsOp = dyn_cast<comb::ModSOp>(op)) {
    InterpretedValue lhs = getValue(procId, modsOp.getLhs());
    InterpretedValue rhs = getValue(procId, modsOp.getRhs());
    unsigned targetWidth = getTypeWidth(modsOp.getType());
    if (lhs.isX() || rhs.isX() || rhs.getAPInt().isZero()) {
      setValue(procId, modsOp.getResult(),
               InterpretedValue::makeX(targetWidth));
      return success();
    }
    APInt lhsVal = lhs.getAPInt();
    APInt rhsVal = rhs.getAPInt();
    normalizeWidths(lhsVal, rhsVal, targetWidth);
    setValue(procId, modsOp.getResult(),
             InterpretedValue(lhsVal.srem(rhsVal)));
    return success();
  }

  if (auto moduOp = dyn_cast<comb::ModUOp>(op)) {
    InterpretedValue lhs = getValue(procId, moduOp.getLhs());
    InterpretedValue rhs = getValue(procId, moduOp.getRhs());
    unsigned targetWidth = getTypeWidth(moduOp.getType());
    if (lhs.isX() || rhs.isX() || rhs.getAPInt().isZero()) {
      setValue(procId, moduOp.getResult(),
               InterpretedValue::makeX(targetWidth));
      return success();
    }
    APInt lhsVal = lhs.getAPInt();
    APInt rhsVal = rhs.getAPInt();
    normalizeWidths(lhsVal, rhsVal, targetWidth);
    setValue(procId, moduOp.getResult(),
             InterpretedValue(lhsVal.urem(rhsVal)));
    return success();
  }

  if (auto muxOp = dyn_cast<comb::MuxOp>(op)) {
    InterpretedValue cond = getValue(procId, muxOp.getCond());
    if (cond.isX()) {
      InterpretedValue trueVal = getValue(procId, muxOp.getTrueValue());
      InterpretedValue falseVal = getValue(procId, muxOp.getFalseValue());
      if (!trueVal.isX() && !falseVal.isX() &&
          trueVal.getAPInt() == falseVal.getAPInt()) {
        setValue(procId, muxOp.getResult(), trueVal);
      } else {
        setValue(procId, muxOp.getResult(),
                 InterpretedValue::makeX(getTypeWidth(muxOp.getType())));
      }
      return success();
    }
    InterpretedValue selected =
        cond.getUInt64() != 0 ? getValue(procId, muxOp.getTrueValue())
                              : getValue(procId, muxOp.getFalseValue());
    setValue(procId, muxOp.getResult(), selected);
    return success();
  }

  if (auto replOp = dyn_cast<comb::ReplicateOp>(op)) {
    InterpretedValue input = getValue(procId, replOp.getInput());
    if (input.isX()) {
      setValue(procId, replOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(replOp.getType())));
      return success();
    }
    unsigned inputWidth = input.getWidth();
    unsigned multiple = replOp.getMultiple();
    llvm::APInt result(getTypeWidth(replOp.getType()), 0);
    for (unsigned i = 0; i < multiple; ++i) {
      llvm::APInt chunk = input.getAPInt().zext(result.getBitWidth());
      result = result.shl(inputWidth) | chunk;
    }
    setValue(procId, replOp.getResult(), InterpretedValue(result));
    return success();
  }

  if (auto ttOp = dyn_cast<comb::TruthTableOp>(op)) {
    auto inputs = ttOp.getInputs();
    auto table = ttOp.getLookupTable();
    size_t inputCount = inputs.size();
    auto values = table;
    if (values.size() != (1ULL << inputCount)) {
      setValue(procId, ttOp.getResult(), InterpretedValue::makeX(1));
      return success();
    }

    llvm::SmallVector<int8_t, 8> bits;
    bits.reserve(inputCount);
    bool hasUnknown = false;
    for (Value input : inputs) {
      InterpretedValue value = getValue(procId, input);
      if (value.isX()) {
        bits.push_back(-1);
        hasUnknown = true;
      } else {
        bits.push_back(value.getUInt64() & 0x1);
      }
    }

    auto tableValueAt = [&](uint64_t index) -> bool {
      return values[index];
    };

    if (!hasUnknown) {
      uint64_t index = 0;
      for (int8_t bit : bits)
        index = (index << 1) | static_cast<uint8_t>(bit);
      setValue(procId, ttOp.getResult(), InterpretedValue(tableValueAt(index), 1));
      return success();
    }

    bool init = false;
    bool combined = false;
    for (uint64_t mask = 0; mask < (1ULL << inputCount); ++mask) {
      bool matches = true;
      for (size_t idx = 0; idx < inputCount; ++idx) {
        int8_t bit = bits[idx];
        if (bit < 0)
          continue;
        uint8_t current = (mask >> (inputCount - 1 - idx)) & 1;
        if (current != static_cast<uint8_t>(bit)) {
          matches = false;
          break;
        }
      }
      if (!matches)
        continue;
      bool value = tableValueAt(mask);
      if (!init) {
        combined = value;
        init = true;
      } else if (combined != value) {
        setValue(procId, ttOp.getResult(), InterpretedValue::makeX(1));
        return success();
      }
    }

    if (!init) {
      setValue(procId, ttOp.getResult(), InterpretedValue::makeX(1));
      return success();
    }

    setValue(procId, ttOp.getResult(), InterpretedValue(combined, 1));
    return success();
  }

  if (auto reverseOp = dyn_cast<comb::ReverseOp>(op)) {
    InterpretedValue input = getValue(procId, reverseOp.getInput());
    if (input.isX()) {
      setValue(procId, reverseOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(reverseOp.getType())));
      return success();
    }
    setValue(procId, reverseOp.getResult(),
             InterpretedValue(input.getAPInt().reverseBits()));
    return success();
  }

  if (auto parityOp = dyn_cast<comb::ParityOp>(op)) {
    InterpretedValue input = getValue(procId, parityOp.getInput());
    if (input.isX()) {
      setValue(procId, parityOp.getResult(), InterpretedValue::makeX(1));
      return success();
    }
    bool parity = (input.getAPInt().popcount() & 1) != 0;
    setValue(procId, parityOp.getResult(), InterpretedValue(parity, 1));
    return success();
  }

  if (auto extractOp = dyn_cast<comb::ExtractOp>(op)) {
    InterpretedValue input = getValue(procId, extractOp.getInput());
    if (input.isX()) {
      setValue(procId, extractOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(extractOp.getType())));
      return success();
    }
    uint32_t lowBit = extractOp.getLowBit();
    uint32_t width = getTypeWidth(extractOp.getType());
    if (lowBit + width > input.getWidth()) {
      setValue(procId, extractOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(extractOp.getType())));
      return success();
    }
    if (width <= 64 && lowBit + width <= 64) {
      uint64_t inputVal = input.getUInt64();
      uint64_t mask = (width == 64) ? ~0ULL : ((1ULL << width) - 1);
      uint64_t result = (inputVal >> lowBit) & mask;
      setValue(procId, extractOp.getResult(),
               InterpretedValue(result, width));
      return success();
    }
    if (width == 1 && input.getWidth() > 64) {
      bool bit = input.getAPInt()[lowBit];
      setValue(procId, extractOp.getResult(), InterpretedValue(bit, 1));
      return success();
    }
    if (width <= 64 && input.getWidth() <= 64) {
      uint64_t inputVal = input.getUInt64();
      uint64_t mask = (width == 64) ? ~0ULL : ((1ULL << width) - 1);
      uint64_t result = (inputVal >> lowBit) & mask;
      setValue(procId, extractOp.getResult(),
               InterpretedValue(result, width));
      return success();
    }
    llvm::APInt result = input.getAPInt().lshr(lowBit).trunc(width);
    setValue(procId, extractOp.getResult(), InterpretedValue(result));
    return success();
  }

  if (auto concatOp = dyn_cast<comb::ConcatOp>(op)) {
    llvm::APInt result;
    bool hasResult = false;
    for (Value operand : concatOp.getOperands()) {
      InterpretedValue value = getValue(procId, operand);
      if (value.isX()) {
        setValue(procId, concatOp.getResult(),
                 InterpretedValue::makeX(getTypeWidth(concatOp.getType())));
        return success();
      }
      if (!hasResult) {
        result = value.getAPInt();
        hasResult = true;
        continue;
      }
      unsigned rhsWidth = value.getWidth();
      llvm::APInt chunk = value.getAPInt().zext(result.getBitWidth() + rhsWidth);
      result = result.zext(result.getBitWidth() + rhsWidth);
      result = (result.shl(rhsWidth)) | chunk;
    }
    unsigned expectedWidth = getTypeWidth(concatOp.getType());
    if (!hasResult) {
      result = llvm::APInt(expectedWidth, 0);
    } else if (result.getBitWidth() < expectedWidth) {
      result = result.zext(expectedWidth);
    } else if (result.getBitWidth() > expectedWidth) {
      result = result.trunc(expectedWidth);
    }
    setValue(procId, concatOp.getResult(), InterpretedValue(result));
    return success();
  }

  if (auto addOp = dyn_cast<comb::AddOp>(op)) {
    unsigned targetWidth = getTypeWidth(addOp.getType());
    // comb.add is variadic - handle N operands (canonicalization merges nested adds)
    APInt result = APInt::getZero(targetWidth);
    for (Value operand : addOp.getOperands()) {
      InterpretedValue val = getValue(procId, operand);
      if (val.isX()) {
        setValue(procId, addOp.getResult(),
                 InterpretedValue::makeX(targetWidth));
        return success();
      }
      APInt v = val.getAPInt();
      if (v.getBitWidth() != targetWidth)
        v = v.zextOrTrunc(targetWidth);
      result += v;
    }
    setValue(procId, addOp.getResult(), InterpretedValue(result));
    return success();
  }

  //===--------------------------------------------------------------------===//
  // Arith Dialect Operations
  //===--------------------------------------------------------------------===//
arith_dispatch:
  if (auto arithConstOp = dyn_cast<mlir::arith::ConstantOp>(op)) {
    if (auto intAttr = dyn_cast<IntegerAttr>(arithConstOp.getValue())) {
      setValue(procId, arithConstOp.getResult(),
               InterpretedValue(intAttr.getValue()));
    } else {
      setValue(procId, arithConstOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(arithConstOp.getType())));
    }
    return success();
  }

  if (auto arithAddIOp = dyn_cast<mlir::arith::AddIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithAddIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithAddIOp.getRhs());
    unsigned targetWidth = getTypeWidth(arithAddIOp.getType());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, arithAddIOp.getResult(),
               InterpretedValue::makeX(targetWidth));
    } else {
      APInt lhsVal = lhs.getAPInt();
      APInt rhsVal = rhs.getAPInt();
      normalizeWidths(lhsVal, rhsVal, targetWidth);
      setValue(procId, arithAddIOp.getResult(),
               InterpretedValue(lhsVal + rhsVal));
    }
    return success();
  }

  if (auto arithSubIOp = dyn_cast<mlir::arith::SubIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithSubIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithSubIOp.getRhs());
    unsigned targetWidth = getTypeWidth(arithSubIOp.getType());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, arithSubIOp.getResult(),
               InterpretedValue::makeX(targetWidth));
    } else {
      APInt lhsVal = lhs.getAPInt();
      APInt rhsVal = rhs.getAPInt();
      normalizeWidths(lhsVal, rhsVal, targetWidth);
      setValue(procId, arithSubIOp.getResult(),
               InterpretedValue(lhsVal - rhsVal));
    }
    return success();
  }

  if (auto arithMulIOp = dyn_cast<mlir::arith::MulIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithMulIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithMulIOp.getRhs());
    unsigned targetWidth = getTypeWidth(arithMulIOp.getType());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, arithMulIOp.getResult(),
               InterpretedValue::makeX(targetWidth));
    } else {
      APInt lhsVal = lhs.getAPInt();
      APInt rhsVal = rhs.getAPInt();
      normalizeWidths(lhsVal, rhsVal, targetWidth);
      setValue(procId, arithMulIOp.getResult(),
               InterpretedValue(lhsVal * rhsVal));
    }
    return success();
  }

  if (auto arithDivSIOp = dyn_cast<mlir::arith::DivSIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithDivSIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithDivSIOp.getRhs());
    unsigned targetWidth = getTypeWidth(arithDivSIOp.getType());
    if (lhs.isX() || rhs.isX() || rhs.getAPInt().isZero()) {
      setValue(procId, arithDivSIOp.getResult(),
               InterpretedValue::makeX(targetWidth));
    } else {
      APInt lhsVal = lhs.getAPInt();
      APInt rhsVal = rhs.getAPInt();
      normalizeWidths(lhsVal, rhsVal, targetWidth);
      setValue(procId, arithDivSIOp.getResult(),
               InterpretedValue(lhsVal.sdiv(rhsVal)));
    }
    return success();
  }

  if (auto arithDivUIOp = dyn_cast<mlir::arith::DivUIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithDivUIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithDivUIOp.getRhs());
    unsigned targetWidth = getTypeWidth(arithDivUIOp.getType());
    if (lhs.isX() || rhs.isX() || rhs.getAPInt().isZero()) {
      setValue(procId, arithDivUIOp.getResult(),
               InterpretedValue::makeX(targetWidth));
    } else {
      APInt lhsVal = lhs.getAPInt();
      APInt rhsVal = rhs.getAPInt();
      normalizeWidths(lhsVal, rhsVal, targetWidth);
      setValue(procId, arithDivUIOp.getResult(),
               InterpretedValue(lhsVal.udiv(rhsVal)));
    }
    return success();
  }

  if (auto arithRemSIOp = dyn_cast<mlir::arith::RemSIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithRemSIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithRemSIOp.getRhs());
    unsigned targetWidth = getTypeWidth(arithRemSIOp.getType());
    if (lhs.isX() || rhs.isX() || rhs.getAPInt().isZero()) {
      setValue(procId, arithRemSIOp.getResult(),
               InterpretedValue::makeX(targetWidth));
    } else {
      APInt lhsVal = lhs.getAPInt();
      APInt rhsVal = rhs.getAPInt();
      normalizeWidths(lhsVal, rhsVal, targetWidth);
      setValue(procId, arithRemSIOp.getResult(),
               InterpretedValue(lhsVal.srem(rhsVal)));
    }
    return success();
  }

  if (auto arithRemUIOp = dyn_cast<mlir::arith::RemUIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithRemUIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithRemUIOp.getRhs());
    unsigned targetWidth = getTypeWidth(arithRemUIOp.getType());
    if (lhs.isX() || rhs.isX() || rhs.getAPInt().isZero()) {
      setValue(procId, arithRemUIOp.getResult(),
               InterpretedValue::makeX(targetWidth));
    } else {
      APInt lhsVal = lhs.getAPInt();
      APInt rhsVal = rhs.getAPInt();
      normalizeWidths(lhsVal, rhsVal, targetWidth);
      setValue(procId, arithRemUIOp.getResult(),
               InterpretedValue(lhsVal.urem(rhsVal)));
    }
    return success();
  }

  if (auto arithAndIOp = dyn_cast<mlir::arith::AndIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithAndIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithAndIOp.getRhs());
    unsigned targetWidth = getTypeWidth(arithAndIOp.getType());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, arithAndIOp.getResult(),
               InterpretedValue::makeX(targetWidth));
    } else {
      APInt lhsVal = lhs.getAPInt();
      APInt rhsVal = rhs.getAPInt();
      normalizeWidths(lhsVal, rhsVal, targetWidth);
      setValue(procId, arithAndIOp.getResult(),
               InterpretedValue(lhsVal & rhsVal));
    }
    return success();
  }

  if (auto arithOrIOp = dyn_cast<mlir::arith::OrIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithOrIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithOrIOp.getRhs());
    unsigned targetWidth = getTypeWidth(arithOrIOp.getType());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, arithOrIOp.getResult(),
               InterpretedValue::makeX(targetWidth));
    } else {
      APInt lhsVal = lhs.getAPInt();
      APInt rhsVal = rhs.getAPInt();
      normalizeWidths(lhsVal, rhsVal, targetWidth);
      setValue(procId, arithOrIOp.getResult(),
               InterpretedValue(lhsVal | rhsVal));
    }
    return success();
  }

  if (auto arithXOrIOp = dyn_cast<mlir::arith::XOrIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithXOrIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithXOrIOp.getRhs());
    unsigned targetWidth = getTypeWidth(arithXOrIOp.getType());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, arithXOrIOp.getResult(),
               InterpretedValue::makeX(targetWidth));
    } else {
      APInt lhsVal = lhs.getAPInt();
      APInt rhsVal = rhs.getAPInt();
      normalizeWidths(lhsVal, rhsVal, targetWidth);
      setValue(procId, arithXOrIOp.getResult(),
               InterpretedValue(lhsVal ^ rhsVal));
    }
    return success();
  }

  if (auto arithShLIOp = dyn_cast<mlir::arith::ShLIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithShLIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithShLIOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, arithShLIOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(arithShLIOp.getType())));
    } else {
      uint64_t shift = rhs.getAPInt().getLimitedValue();
      setValue(procId, arithShLIOp.getResult(),
               InterpretedValue(lhs.getAPInt().shl(shift)));
    }
    return success();
  }

  if (auto arithShRUIOp = dyn_cast<mlir::arith::ShRUIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithShRUIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithShRUIOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, arithShRUIOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(arithShRUIOp.getType())));
    } else {
      uint64_t shift = rhs.getAPInt().getLimitedValue();
      setValue(procId, arithShRUIOp.getResult(),
               InterpretedValue(lhs.getAPInt().lshr(shift)));
    }
    return success();
  }

  if (auto arithShRSIOp = dyn_cast<mlir::arith::ShRSIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithShRSIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithShRSIOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, arithShRSIOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(arithShRSIOp.getType())));
    } else {
      uint64_t shift = rhs.getAPInt().getLimitedValue();
      setValue(procId, arithShRSIOp.getResult(),
               InterpretedValue(lhs.getAPInt().ashr(shift)));
    }
    return success();
  }

  if (auto arithCmpIOp = dyn_cast<mlir::arith::CmpIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithCmpIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithCmpIOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, arithCmpIOp.getResult(), InterpretedValue::makeX(1));
      return success();
    }

    bool result = false;
    APInt lhsVal = lhs.getAPInt();
    APInt rhsVal = rhs.getAPInt();
    // Normalize widths for comparison - use the larger of the two widths
    unsigned compareWidth = std::max(lhsVal.getBitWidth(), rhsVal.getBitWidth());
    normalizeWidths(lhsVal, rhsVal, compareWidth);
    switch (arithCmpIOp.getPredicate()) {
    case mlir::arith::CmpIPredicate::eq:
      result = lhsVal == rhsVal;
      break;
    case mlir::arith::CmpIPredicate::ne:
      result = lhsVal != rhsVal;
      break;
    case mlir::arith::CmpIPredicate::slt:
      result = lhsVal.slt(rhsVal);
      break;
    case mlir::arith::CmpIPredicate::sle:
      result = lhsVal.sle(rhsVal);
      break;
    case mlir::arith::CmpIPredicate::sgt:
      result = lhsVal.sgt(rhsVal);
      break;
    case mlir::arith::CmpIPredicate::sge:
      result = lhsVal.sge(rhsVal);
      break;
    case mlir::arith::CmpIPredicate::ult:
      result = lhsVal.ult(rhsVal);
      break;
    case mlir::arith::CmpIPredicate::ule:
      result = lhsVal.ule(rhsVal);
      break;
    case mlir::arith::CmpIPredicate::ugt:
      result = lhsVal.ugt(rhsVal);
      break;
    case mlir::arith::CmpIPredicate::uge:
      result = lhsVal.uge(rhsVal);
      break;
    }
    setValue(procId, arithCmpIOp.getResult(), InterpretedValue(result ? 1 : 0, 1));
    return success();
  }

  if (auto arithSelectOp = dyn_cast<mlir::arith::SelectOp>(op)) {
    InterpretedValue cond = getValue(procId, arithSelectOp.getCondition());
    if (cond.isX()) {
      InterpretedValue trueVal =
          getValue(procId, arithSelectOp.getTrueValue());
      InterpretedValue falseVal =
          getValue(procId, arithSelectOp.getFalseValue());
      if (!trueVal.isX() && !falseVal.isX() &&
          trueVal.getAPInt() == falseVal.getAPInt()) {
        setValue(procId, arithSelectOp.getResult(), trueVal);
      } else {
        setValue(
            procId, arithSelectOp.getResult(),
            InterpretedValue::makeX(getTypeWidth(arithSelectOp.getType())));
      }
      return success();
    }
    InterpretedValue selected =
        cond.getUInt64() != 0
            ? getValue(procId, arithSelectOp.getTrueValue())
            : getValue(procId, arithSelectOp.getFalseValue());
    setValue(procId, arithSelectOp.getResult(), selected);
    return success();
  }

  if (auto arithExtUIOp = dyn_cast<mlir::arith::ExtUIOp>(op)) {
    InterpretedValue input = getValue(procId, arithExtUIOp.getIn());
    if (input.isX()) {
      setValue(procId, arithExtUIOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(arithExtUIOp.getType())));
    } else {
      unsigned outWidth = getTypeWidth(arithExtUIOp.getType());
      setValue(procId, arithExtUIOp.getResult(),
               InterpretedValue(input.getAPInt().zext(outWidth)));
    }
    return success();
  }

  if (auto arithExtSIOp = dyn_cast<mlir::arith::ExtSIOp>(op)) {
    InterpretedValue input = getValue(procId, arithExtSIOp.getIn());
    if (input.isX()) {
      setValue(procId, arithExtSIOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(arithExtSIOp.getType())));
    } else {
      unsigned outWidth = getTypeWidth(arithExtSIOp.getType());
      setValue(procId, arithExtSIOp.getResult(),
               InterpretedValue(input.getAPInt().sext(outWidth)));
    }
    return success();
  }

  if (auto arithTruncIOp = dyn_cast<mlir::arith::TruncIOp>(op)) {
    InterpretedValue input = getValue(procId, arithTruncIOp.getIn());
    if (input.isX()) {
      setValue(procId, arithTruncIOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(arithTruncIOp.getType())));
    } else {
      unsigned outWidth = getTypeWidth(arithTruncIOp.getType());
      setValue(procId, arithTruncIOp.getResult(),
               InterpretedValue(input.getAPInt().trunc(outWidth)));
    }
    return success();
  }

  if (auto arithMinSIOp = dyn_cast<mlir::arith::MinSIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithMinSIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithMinSIOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, arithMinSIOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(arithMinSIOp.getType())));
    } else {
      APInt lhsVal = lhs.getAPInt();
      APInt rhsVal = rhs.getAPInt();
      unsigned w = std::max(lhsVal.getBitWidth(), rhsVal.getBitWidth());
      normalizeWidths(lhsVal, rhsVal, w);
      setValue(procId, arithMinSIOp.getResult(),
               InterpretedValue(lhsVal.slt(rhsVal) ? lhsVal : rhsVal));
    }
    return success();
  }

  if (auto arithMaxSIOp = dyn_cast<mlir::arith::MaxSIOp>(op)) {
    InterpretedValue lhs = getValue(procId, arithMaxSIOp.getLhs());
    InterpretedValue rhs = getValue(procId, arithMaxSIOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, arithMaxSIOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(arithMaxSIOp.getType())));
    } else {
      APInt lhsVal = lhs.getAPInt();
      APInt rhsVal = rhs.getAPInt();
      unsigned w = std::max(lhsVal.getBitWidth(), rhsVal.getBitWidth());
      normalizeWidths(lhsVal, rhsVal, w);
      setValue(procId, arithMaxSIOp.getResult(),
               InterpretedValue(lhsVal.sgt(rhsVal) ? lhsVal : rhsVal));
    }
    return success();
  }

  if (auto arithIndexCastOp = dyn_cast<mlir::arith::IndexCastOp>(op)) {
    InterpretedValue input = getValue(procId, arithIndexCastOp.getIn());
    if (input.isX()) {
      setValue(procId, arithIndexCastOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(arithIndexCastOp.getType())));
    } else {
      unsigned outWidth = getTypeWidth(arithIndexCastOp.getType());
      if (outWidth > input.getWidth()) {
        setValue(procId, arithIndexCastOp.getResult(),
                 InterpretedValue(input.getAPInt().zext(outWidth)));
      } else if (outWidth < input.getWidth()) {
        setValue(procId, arithIndexCastOp.getResult(),
                 InterpretedValue(input.getAPInt().trunc(outWidth)));
      } else {
        setValue(procId, arithIndexCastOp.getResult(), input);
      }
    }
    return success();
  }

  if (auto arithIndexCastUIOp = dyn_cast<mlir::arith::IndexCastUIOp>(op)) {
    InterpretedValue input = getValue(procId, arithIndexCastUIOp.getIn());
    if (input.isX()) {
      setValue(procId, arithIndexCastUIOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(arithIndexCastUIOp.getType())));
    } else {
      unsigned outWidth = getTypeWidth(arithIndexCastUIOp.getType());
      if (outWidth > input.getWidth()) {
        setValue(procId, arithIndexCastUIOp.getResult(),
                 InterpretedValue(input.getAPInt().zext(outWidth)));
      } else if (outWidth < input.getWidth()) {
        setValue(procId, arithIndexCastUIOp.getResult(),
                 InterpretedValue(input.getAPInt().trunc(outWidth)));
      } else {
        setValue(procId, arithIndexCastUIOp.getResult(), input);
      }
    }
    return success();
  }

  //===--------------------------------------------------------------------===//
  // SCF Dialect Operations (control flow for loops/conditionals)
  //===--------------------------------------------------------------------===//

  if (auto scfIfOp = dyn_cast<mlir::scf::IfOp>(op)) {
    return interpretSCFIf(procId, scfIfOp);
  }

  if (auto scfForOp = dyn_cast<mlir::scf::ForOp>(op)) {
    return interpretSCFFor(procId, scfForOp);
  }

  if (auto scfWhileOp = dyn_cast<mlir::scf::WhileOp>(op)) {
    return interpretSCFWhile(procId, scfWhileOp);
  }

  if (auto scfYieldOp = dyn_cast<mlir::scf::YieldOp>(op)) {
    // scf.yield is handled within the parent op interpretation
    return success();
  }

  if (auto scfConditionOp = dyn_cast<mlir::scf::ConditionOp>(op)) {
    // scf.condition is handled within the while loop interpretation
    return success();
  }

  //===--------------------------------------------------------------------===//
  // Func Dialect Operations (function calls)
  //===--------------------------------------------------------------------===//

  if (auto callOp = dyn_cast<mlir::func::CallOp>(op)) {
    return interpretFuncCall(procId, callOp);
  }

  // Handle func.call_indirect for virtual method calls
  if (auto callIndirectOp = dyn_cast<mlir::func::CallIndirectOp>(op)) {
    // The callee is the first operand (function pointer)
    Value calleeValue = callIndirectOp.getCallee();
    InterpretedValue funcPtrVal = getValue(procId, calleeValue);
    bool traceSeq = traceSeqEnabled;

    // Early trace: log every call_indirect to detect analysis_port writes.
    if (traceAnalysisEnabled) {
      // Try to identify the callee from the SSA chain (GEP → vtable)
      auto castOp0 = calleeValue.getDefiningOp<mlir::UnrealizedConversionCastOp>();
      if (castOp0 && castOp0.getInputs().size() == 1) {
        auto loadOp0 = castOp0.getInputs()[0].getDefiningOp<LLVM::LoadOp>();
        if (loadOp0) {
          auto gepOp0 = loadOp0.getAddr().getDefiningOp<LLVM::GEPOp>();
          if (gepOp0) {
            auto baseLoad0 = gepOp0.getBase().getDefiningOp<LLVM::LoadOp>();
            if (baseLoad0) {
              auto objGep0 = baseLoad0.getAddr().getDefiningOp<LLVM::GEPOp>();
              if (objGep0) {
                if (auto structTy0 = dyn_cast<LLVM::LLVMStructType>(
                        objGep0.getElemType())) {
                  if (structTy0.isIdentified() &&
                      structTy0.getName().contains("analysis_port")) {
                    auto indices0 = gepOp0.getIndices();
                    int64_t slot0 = -1;
                    if (indices0.size() >= 2) {
                      if (auto ia = llvm::dyn_cast_if_present<IntegerAttr>(
                              indices0[indices0.size() - 1]))
                        slot0 = ia.getInt();
                    }
                    llvm::errs() << "[ANALYSIS-CI-ENTRY] struct="
                                 << structTy0.getName() << " slot=" << slot0
                                 << " funcPtrIsX=" << funcPtrVal.isX()
                                 << " funcAddr=0x"
                                 << (funcPtrVal.isX()
                                         ? std::string("X")
                                         : llvm::utohexstr(funcPtrVal.getUInt64()))
                                 << "\n";
                  }
                }
              }
            }
          }
        }
      }
    }

    // Throttle vtable dispatch warnings to prevent flooding stderr during
    // UVM initialization. Both X function pointers and unmapped addresses
    // share a single counter.
    auto emitVtableWarning = [&](StringRef reason) {
      static unsigned vtableWarnCount = 0;
      if (vtableWarnCount < 30) {
        ++vtableWarnCount;
        llvm::errs() << "[circt-sim] WARNING: virtual method call "
                     << "(func.call_indirect) failed: " << reason
                     << ". Callee operand: ";
        calleeValue.print(llvm::errs(), OpPrintingFlags().printGenericOpForm());
        llvm::errs() << " (type: " << calleeValue.getType() << ")\n";
      } else if (vtableWarnCount == 30) {
        ++vtableWarnCount;
        llvm::errs() << "[circt-sim] (suppressing further vtable warnings)\n";
      }
    };

    if (funcPtrVal.isX()) {
      LLVM_DEBUG(llvm::dbgs() << "  func.call_indirect: callee is X "
                              << "(uninitialized vtable pointer)\n");

      // Fallback: try to resolve the virtual method statically by tracing
      // the SSA chain back to the vtable GEP pattern:
      //   calleeValue = unrealized_conversion_cast(llvm.load(llvm.getelementptr(
      //                     vtablePtr, [0, methodIndex])))
      // where vtablePtr = llvm.load(llvm.getelementptr(objPtr, [0, ..., 1]))
      // From the outer GEP's struct type we get the class name, construct
      // "ClassName::__vtable__", and read the function address at methodIndex.
      bool resolved = false;
      do {
        // Step 1: trace calleeValue -> unrealized_conversion_cast input
        auto castOp =
            calleeValue.getDefiningOp<mlir::UnrealizedConversionCastOp>();
        if (!castOp || castOp.getInputs().size() != 1)
          break;
        Value rawPtr = castOp.getInputs()[0];

        // Step 2: rawPtr should come from llvm.load (loads func ptr from vtable)
        auto funcPtrLoad = rawPtr.getDefiningOp<LLVM::LoadOp>();
        if (!funcPtrLoad)
          break;

        // Step 3: the load address comes from a GEP into the vtable array
        auto vtableGEP = funcPtrLoad.getAddr().getDefiningOp<LLVM::GEPOp>();
        if (!vtableGEP)
          break;

        // Extract the method index from the GEP indices (last index)
        auto vtableIndices = vtableGEP.getIndices();
        if (vtableIndices.size() < 2)
          break;
        auto lastIdx = vtableIndices[vtableIndices.size() - 1];
        int64_t methodIndex = -1;
        if (auto intAttr = llvm::dyn_cast_if_present<IntegerAttr>(lastIdx))
          methodIndex = intAttr.getInt();
        else if (auto dynIdx = llvm::dyn_cast_if_present<Value>(lastIdx)) {
          InterpretedValue dynVal = getValue(procId, dynIdx);
          if (!dynVal.isX())
            methodIndex = static_cast<int64_t>(dynVal.getUInt64());
        }
        if (methodIndex < 0)
          break;

        // Step 4: vtableGEP base = vtable pointer from llvm.load
        auto vtablePtrLoad =
            vtableGEP.getBase().getDefiningOp<LLVM::LoadOp>();
        if (!vtablePtrLoad)
          break;

        // Step 5: the vtable pointer load address comes from GEP on the object
        auto objGEP =
            vtablePtrLoad.getAddr().getDefiningOp<LLVM::GEPOp>();
        if (!objGEP)
          break;

        // Extract the struct type name from the outer GEP's element type
        std::string vtableGlobalName;
        if (auto structTy =
                dyn_cast<LLVM::LLVMStructType>(objGEP.getElemType())) {
          if (structTy.isIdentified()) {
            vtableGlobalName = structTy.getName().str() + "::__vtable__";
          }
        }
        if (vtableGlobalName.empty())
          break;

        // Runtime vtable override: read the actual vtable pointer from the
        // object's memory to find the correct derived-class vtable. The
        // compile-time struct type from the GEP may point to a base class
        // vtable with stubs, while the runtime object is a derived class
        // with real overrides.
        if (!callIndirectOp.getArgOperands().empty()) {
          InterpretedValue selfVal =
              getValue(procId, callIndirectOp.getArgOperands()[0]);
          if (!selfVal.isX()) {
            uint64_t objAddr = selfVal.getUInt64();
            uint64_t vtableOff = 0;
            MemoryBlock *objBlock = findBlockByAddress(objAddr, vtableOff);
            // Vtable ptr is at byte offset 4 (after i32 class ID at offset 0)
            if (objBlock && objBlock->initialized &&
                objBlock->data.size() >= vtableOff + 12) {
              uint64_t runtimeVtableAddr = 0;
              for (unsigned i = 0; i < 8; ++i)
                runtimeVtableAddr |= static_cast<uint64_t>(
                                         objBlock->data[vtableOff + 4 + i])
                                     << (i * 8);
              auto globalIt2 = addressToGlobal.find(runtimeVtableAddr);
              if (globalIt2 != addressToGlobal.end()) {
                std::string runtimeVtableName = globalIt2->second;
                if (runtimeVtableName != vtableGlobalName &&
                    globalMemoryBlocks.count(runtimeVtableName)) {
                  LLVM_DEBUG(llvm::dbgs()
                             << "  call_indirect: runtime vtable override: "
                             << vtableGlobalName << " -> "
                             << runtimeVtableName << "\n");
                  vtableGlobalName = runtimeVtableName;
                }
              }
            }
          }
        }

        // Step 6: find the vtable global and read the function address
        auto globalIt = globalMemoryBlocks.find(vtableGlobalName);
        if (globalIt == globalMemoryBlocks.end())
          break;

        auto &vtableBlock = globalIt->second;
        unsigned slotOffset = methodIndex * 8;
        if (slotOffset + 8 > vtableBlock.size)
          break;

        // Read 8-byte function address (little-endian) from vtable memory
        uint64_t resolvedFuncAddr = 0;
        for (unsigned i = 0; i < 8; ++i)
          resolvedFuncAddr |=
              static_cast<uint64_t>(vtableBlock.data[slotOffset + i]) << (i * 8);

        if (resolvedFuncAddr == 0)
          break; // Slot is empty (no function registered)

        auto funcIt = addressToFunction.find(resolvedFuncAddr);
        if (funcIt == addressToFunction.end())
          break;

        StringRef resolvedName = funcIt->second;
        // [CI-XFALLBACK] diagnostic removed
        LLVM_DEBUG(llvm::dbgs()
                   << "  func.call_indirect: fallback vtable resolution: "
                   << vtableGlobalName << "[" << methodIndex << "] -> "
                   << resolvedName << "\n");

        // Look up the function
        auto &state = processStates[procId];
        Operation *parent = state.processOrInitialOp;
        while (parent && !isa<ModuleOp>(parent))
          parent = parent->getParentOp();
        ModuleOp moduleOp = parent ? cast<ModuleOp>(parent) : rootModule;
        auto funcOp = moduleOp.lookupSymbol<func::FuncOp>(resolvedName);
        if (!funcOp)
          break;

        // Gather arguments
        SmallVector<InterpretedValue, 4> args;
        for (Value arg : callIndirectOp.getArgOperands())
          args.push_back(getValue(procId, arg));

        // Intercept UVM phase/objection methods in the X-fallback path.
        if ((resolvedName.contains("uvm_phase::raise_objection") ||
             resolvedName.contains("uvm_phase::drop_objection")) &&
            !resolvedName.contains("phase_hopper") &&
            !args.empty() && !args[0].isX()) {
          uint64_t phaseAddr = args[0].getUInt64();
          InterpretedValue countVal =
              args.size() > 3 ? args[3] : InterpretedValue(llvm::APInt(32, 1));
          int64_t count = countVal.isX() ? 1 : static_cast<int64_t>(countVal.getUInt64());
          auto objIt = phaseObjectionHandles.find(phaseAddr);
          MooreObjectionHandle handle;
          if (objIt != phaseObjectionHandles.end()) {
            handle = objIt->second;
          } else {
            std::string phaseName = "phase_" + std::to_string(phaseAddr);
            handle = __moore_objection_create(
                phaseName.c_str(), static_cast<int64_t>(phaseName.size()));
            phaseObjectionHandles[phaseAddr] = handle;
          }
          if (resolvedName.contains("raise_objection")) {
            raisePhaseObjection(handle, count);
          } else {
            dropPhaseObjection(handle, count);
          }
          resolved = true;
          break;
        }

        // Record port connect() in X-fallback path and bypass UVM body.
        // This avoids uvm_port_base phase checks rejecting valid native
        // connections as "late" while still preserving routing info.
        if (resolvedName.contains("uvm_port_base") &&
            resolvedName.contains("::connect") &&
            !resolvedName.contains("connect_phase") && args.size() >= 2) {
          uint64_t selfAddr2 = args[0].isX() ? 0 : args[0].getUInt64();
          uint64_t providerAddr2 = args[1].isX() ? 0 : args[1].getUInt64();
          if (selfAddr2 != 0 && providerAddr2 != 0) {
            auto &conns = analysisPortConnections[selfAddr2];
            if (std::find(conns.begin(), conns.end(), providerAddr2) ==
                conns.end()) {
              conns.push_back(providerAddr2);
              invalidateUvmSequencerQueueCache(selfAddr2);
            }
          }
          // [SEQ-CONN] X-fallback connect diagnostic removed
          resolved = true;
          break;
        }

        // Intercept analysis_port::write in X-fallback path.
        // The UVM write() body iterates m_imp_list via get_if(i), but
        // m_if is empty because we skip resolve_bindings. Use our native
        // analysisPortConnections map to dispatch to terminal imps.
        if (resolvedName.contains("analysis_port") &&
            resolvedName.contains("::write") &&
            !resolvedName.contains("write_m_") && args.size() >= 2) {
          uint64_t portAddr = args[0].isX() ? 0 : args[0].getUInt64();
          if (traceAnalysisEnabled)
            llvm::errs() << "[ANALYSIS-WRITE-XFALLBACK] " << resolvedName
                         << " portAddr=0x" << llvm::format_hex(portAddr, 0)
                         << " inMap=" << analysisPortConnections.count(portAddr)
                         << "\n";
          // Flatten the connection chain to find all terminal imps.
          llvm::SmallVector<uint64_t, 4> terminals;
          llvm::SmallVector<uint64_t, 8> worklist;
          llvm::DenseSet<uint64_t> visited;
          auto seedIt = analysisPortConnections.find(portAddr);
          if (seedIt != analysisPortConnections.end()) {
            for (uint64_t a : seedIt->second)
              worklist.push_back(a);
          }
          while (!worklist.empty()) {
            uint64_t addr = worklist.pop_back_val();
            if (!visited.insert(addr).second)
              continue;
            auto chainIt = analysisPortConnections.find(addr);
            if (chainIt != analysisPortConnections.end() &&
                !chainIt->second.empty()) {
              for (uint64_t next : chainIt->second)
                worklist.push_back(next);
            } else {
              terminals.push_back(addr);
            }
          }
          if (!terminals.empty()) {
            if (traceAnalysisEnabled)
              llvm::errs() << "[ANALYSIS-WRITE-XFALLBACK] " << terminals.size()
                           << " terminal(s) found\n";
            for (uint64_t impAddr : terminals) {
              // Read vtable pointer at byte offset 4 from the imp object.
              uint64_t vtableOff2 = 0;
              MemoryBlock *impBlock = findBlockByAddress(impAddr, vtableOff2);
              if (!impBlock || vtableOff2 + 4 + 8 > impBlock->size)
                continue;
              uint64_t vtableAddr2 = 0;
              for (unsigned i = 0; i < 8; ++i)
                vtableAddr2 |= static_cast<uint64_t>(
                                   impBlock->data[vtableOff2 + 4 + i])
                               << (i * 8);
              auto globalIt2 = addressToGlobal.find(vtableAddr2);
              if (globalIt2 == addressToGlobal.end())
                continue;
              // Read write function pointer from vtable slot 11.
              auto vtableBlockIt = globalMemoryBlocks.find(globalIt2->second);
              if (vtableBlockIt == globalMemoryBlocks.end())
                continue;
              auto &vtableBlock2 = vtableBlockIt->second;
              unsigned writeSlot = 11;
              unsigned slotOff = writeSlot * 8;
              if (slotOff + 8 > vtableBlock2.size)
                continue;
              uint64_t writeFuncAddr = 0;
              for (unsigned i = 0; i < 8; ++i)
                writeFuncAddr |=
                    static_cast<uint64_t>(vtableBlock2.data[slotOff + i])
                    << (i * 8);
              auto funcIt2 = addressToFunction.find(writeFuncAddr);
              if (funcIt2 == addressToFunction.end())
                continue;
              auto impWriteFunc = moduleOp.lookupSymbol<func::FuncOp>(
                  funcIt2->second);
              if (!impWriteFunc)
                continue;
              if (traceAnalysisEnabled)
                llvm::errs() << "[ANALYSIS-WRITE-XFALLBACK] dispatching to "
                             << funcIt2->second << "\n";
              SmallVector<InterpretedValue, 2> impArgs;
              impArgs.push_back(InterpretedValue(llvm::APInt(64, impAddr)));
              impArgs.push_back(args[1]); // transaction object
              SmallVector<InterpretedValue, 2> impResults;
              auto &cState2 = processStates[procId];
              ++cState2.callDepth;
              (void)interpretFuncBody(procId, impWriteFunc, impArgs, impResults,
                                     callIndirectOp);
              --cState2.callDepth;
            }
            resolved = true;
            break;
          }
          // If no native connections, fall through to normal UVM body dispatch.
        }

        // Intercept resolve_bindings in X-fallback path — skip it.
        if (resolvedName.contains("uvm_port_base") &&
            resolvedName.contains("::resolve_bindings")) {
          resolved = true;
          break;
        }

        // Dispatch the call
        // [SEQ-XFALLBACK] diagnostic removed
        auto &callState = processStates[procId];
        ++callState.callDepth;
        SmallVector<InterpretedValue, 4> results;
        auto callResult = interpretFuncBody(procId, funcOp, args, results,
                                            callIndirectOp);
        --callState.callDepth;

        if (failed(callResult)) {
          break;
        }

        // Set return values
        for (auto [result, val] :
             llvm::zip(callIndirectOp.getResults(), results))
          setValue(procId, result, val);

        resolved = true;
      } while (false);

      if (!resolved) {
        emitVtableWarning("function pointer is X (uninitialized)");
        // Return zero/null instead of X to prevent cascading X-propagation
        // in UVM code paths that check return values for null.
        for (Value result : callIndirectOp.getResults()) {
          unsigned width = getTypeWidth(result.getType());
          setValue(procId, result, InterpretedValue(llvm::APInt(width, 0)));
        }
      }
      return success();
    }

    // Look up the function name from the vtable
    uint64_t funcAddr = funcPtrVal.getUInt64();
    auto it = addressToFunction.find(funcAddr);
    if (it == addressToFunction.end()) {
      // Runtime vtable pointer is corrupt or unmapped. Try static resolution
      // by tracing the SSA chain back to the vtable global, which is always
      // correct regardless of runtime memory corruption.
      bool staticResolved = false;
      do {
        auto castOp =
            calleeValue.getDefiningOp<mlir::UnrealizedConversionCastOp>();
        if (!castOp || castOp.getInputs().size() != 1)
          break;
        Value rawPtr = castOp.getInputs()[0];
        auto funcPtrLoad = rawPtr.getDefiningOp<LLVM::LoadOp>();
        if (!funcPtrLoad)
          break;
        auto vtableGEP =
            funcPtrLoad.getAddr().getDefiningOp<LLVM::GEPOp>();
        if (!vtableGEP)
          break;
        auto vtableIndices = vtableGEP.getIndices();
        if (vtableIndices.size() < 2)
          break;
        auto lastIdx = vtableIndices[vtableIndices.size() - 1];
        int64_t methodIndex = -1;
        if (auto intAttr = llvm::dyn_cast_if_present<IntegerAttr>(lastIdx))
          methodIndex = intAttr.getInt();
        else if (auto dynIdx = llvm::dyn_cast_if_present<Value>(lastIdx)) {
          InterpretedValue dynVal = getValue(procId, dynIdx);
          if (!dynVal.isX())
            methodIndex = static_cast<int64_t>(dynVal.getUInt64());
        }
        if (methodIndex < 0)
          break;
        auto vtablePtrLoad =
            vtableGEP.getBase().getDefiningOp<LLVM::LoadOp>();
        if (!vtablePtrLoad)
          break;
        auto objGEP =
            vtablePtrLoad.getAddr().getDefiningOp<LLVM::GEPOp>();
        if (!objGEP)
          break;
        std::string vtableGlobalName;
        if (auto structTy =
                dyn_cast<LLVM::LLVMStructType>(objGEP.getElemType())) {
          if (structTy.isIdentified())
            vtableGlobalName = structTy.getName().str() + "::__vtable__";
        }
        if (vtableGlobalName.empty())
          break;

        // Runtime vtable override (same as X-fallback path above)
        if (!callIndirectOp.getArgOperands().empty()) {
          InterpretedValue selfVal2 =
              getValue(procId, callIndirectOp.getArgOperands()[0]);
          if (!selfVal2.isX()) {
            uint64_t objAddr2 = selfVal2.getUInt64();
            uint64_t vtableOff2 = 0;
            MemoryBlock *objBlock2 = findBlockByAddress(objAddr2, vtableOff2);
            if (objBlock2 && objBlock2->initialized &&
                objBlock2->data.size() >= vtableOff2 + 12) {
              uint64_t runtimeVtableAddr2 = 0;
              for (unsigned i = 0; i < 8; ++i)
                runtimeVtableAddr2 |=
                    static_cast<uint64_t>(
                        objBlock2->data[vtableOff2 + 4 + i])
                    << (i * 8);
              auto globalIt3 = addressToGlobal.find(runtimeVtableAddr2);
              if (globalIt3 != addressToGlobal.end()) {
                std::string runtimeVtableName2 = globalIt3->second;
                if (runtimeVtableName2 != vtableGlobalName &&
                    globalMemoryBlocks.count(runtimeVtableName2)) {
                  vtableGlobalName = runtimeVtableName2;
                }
              }
            }
          }
        }

        auto globalIt = globalMemoryBlocks.find(vtableGlobalName);
        if (globalIt == globalMemoryBlocks.end())
          break;
        auto &vtableBlock = globalIt->second;
        unsigned slotOffset = methodIndex * 8;
        if (slotOffset + 8 > vtableBlock.size)
          break;
        uint64_t resolvedFuncAddr = 0;
        for (unsigned i = 0; i < 8; ++i)
          resolvedFuncAddr |=
              static_cast<uint64_t>(vtableBlock.data[slotOffset + i])
              << (i * 8);
        if (resolvedFuncAddr == 0)
          break;
        auto funcIt2 = addressToFunction.find(resolvedFuncAddr);
        if (funcIt2 == addressToFunction.end())
          break;
        StringRef resolvedName = funcIt2->second;

        LLVM_DEBUG(llvm::dbgs()
                   << "  func.call_indirect: static fallback: "
                   << vtableGlobalName << "[" << methodIndex << "] -> "
                   << resolvedName << "\n");
        auto &st2 = processStates[procId];
        Operation *par = st2.processOrInitialOp;
        while (par && !isa<ModuleOp>(par))
          par = par->getParentOp();
        ModuleOp modOp = par ? cast<ModuleOp>(par) : rootModule;
        auto fOp = modOp.lookupSymbol<func::FuncOp>(resolvedName);
        if (!fOp)
          break;
        SmallVector<InterpretedValue, 4> sArgs;
        for (Value arg : callIndirectOp.getArgOperands())
          sArgs.push_back(getValue(procId, arg));

        // Intercept UVM phase/objection methods in non-X static fallback.
        if ((resolvedName.contains("uvm_phase::raise_objection") ||
             resolvedName.contains("uvm_phase::drop_objection")) &&
            !resolvedName.contains("phase_hopper") &&
            !sArgs.empty() && !sArgs[0].isX()) {
          uint64_t phaseAddr = sArgs[0].getUInt64();
          InterpretedValue countVal =
              sArgs.size() > 3 ? sArgs[3] : InterpretedValue(llvm::APInt(32, 1));
          int64_t cnt = countVal.isX() ? 1 : static_cast<int64_t>(countVal.getUInt64());
          auto objIt = phaseObjectionHandles.find(phaseAddr);
          MooreObjectionHandle handle;
          if (objIt != phaseObjectionHandles.end()) {
            handle = objIt->second;
          } else {
            std::string phaseName = "phase_" + std::to_string(phaseAddr);
            handle = __moore_objection_create(
                phaseName.c_str(), static_cast<int64_t>(phaseName.size()));
            phaseObjectionHandles[phaseAddr] = handle;
          }
          if (resolvedName.contains("raise_objection")) {
            raisePhaseObjection(handle, cnt);
          } else {
            dropPhaseObjection(handle, cnt);
          }
          staticResolved = true;
          break;
        }

        // Record port connect() in static fallback path and bypass UVM body.
        // This mirrors the direct call_indirect connect interceptor behavior.
        if (resolvedName.contains("uvm_port_base") &&
            resolvedName.contains("::connect") &&
            !resolvedName.contains("connect_phase") && sArgs.size() >= 2) {
          uint64_t selfAddr3 = sArgs[0].isX() ? 0 : sArgs[0].getUInt64();
          uint64_t providerAddr3 = sArgs[1].isX() ? 0 : sArgs[1].getUInt64();
          if (selfAddr3 != 0 && providerAddr3 != 0) {
            auto &conns = analysisPortConnections[selfAddr3];
            if (std::find(conns.begin(), conns.end(), providerAddr3) ==
                conns.end()) {
              conns.push_back(providerAddr3);
              invalidateUvmSequencerQueueCache(selfAddr3);
            }
          }
          // [SEQ-CONN] static-fallback connect diagnostic removed
          staticResolved = true;
          break;
        }

        // Intercept resource_db in static fallback path.
        if (resolvedName.contains("resource_db") &&
            resolvedName.contains("implementation") &&
            (resolvedName.contains("::set") ||
             resolvedName.contains("::read_by_name"))) {

          auto readStr2 = [&](unsigned argIdx) -> std::string {
            if (argIdx >= sArgs.size())
              return "";
            InterpretedValue val = sArgs[argIdx];
            if (val.isX() || val.getWidth() < 128)
              return "";
            llvm::APInt bits = val.getAPInt();
            uint64_t strPtr = bits.extractBits(64, 0).getZExtValue();
            int64_t strLen = bits.extractBits(64, 64).getSExtValue();
            if (strPtr == 0 || strLen <= 0)
              return "";
            auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
            if (dynIt != dynamicStrings.end() && dynIt->second.first &&
                dynIt->second.second > 0)
              return std::string(
                  dynIt->second.first,
                  std::min(static_cast<size_t>(strLen),
                           static_cast<size_t>(dynIt->second.second)));
            uint64_t off2 = 0;
            MemoryBlock *gBlock2 = findBlockByAddress(strPtr, off2);
            if (gBlock2 && gBlock2->initialized) {
              size_t avail = std::min(
                  static_cast<size_t>(strLen),
                  gBlock2->data.size() - static_cast<size_t>(off2));
              if (avail > 0)
                return std::string(
                    reinterpret_cast<const char *>(gBlock2->data.data() + off2),
                    avail);
            }
            if (strPtr >= 0x10000) {
              const char *p = reinterpret_cast<const char *>(strPtr);
              return std::string(p, static_cast<size_t>(strLen));
            }
            return "";
          };

          if (resolvedName.contains("::set") &&
              !resolvedName.contains("set_default") &&
              !resolvedName.contains("set_override") &&
              !resolvedName.contains("set_anonymous")) {
            if (sArgs.size() >= 4) {
              std::string scope = readStr2(1);
              std::string fieldName = readStr2(2);
              std::string key = scope + "." + fieldName;
              InterpretedValue &valueArg = sArgs[3];
              unsigned valueBits = valueArg.getWidth();
              unsigned valueBytes = (valueBits + 7) / 8;
              std::vector<uint8_t> valueData(valueBytes, 0);
              if (!valueArg.isX()) {
                llvm::APInt valBits = valueArg.getAPInt();
                for (unsigned i = 0; i < valueBytes; ++i)
                  valueData[i] = static_cast<uint8_t>(
                      valBits.extractBits(8, i * 8).getZExtValue());
              }
              configDbEntries[key] = std::move(valueData);
            }
            staticResolved = true;
            break;
          }

          if (resolvedName.contains("::read_by_name") &&
              sArgs.size() >= 4 &&
              callIndirectOp.getNumResults() >= 1) {
            std::string scope = readStr2(1);
            std::string fieldName = readStr2(2);
            std::string key = scope + "." + fieldName;

            auto entryIt = configDbEntries.find(key);
            if (entryIt == configDbEntries.end()) {
              for (auto &[k, v] : configDbEntries) {
                size_t dotPos = k.rfind('.');
                if (dotPos != std::string::npos &&
                    k.substr(dotPos + 1) == fieldName) {
                  entryIt = configDbEntries.find(k);
                  break;
                }
              }
            }

            if (entryIt != configDbEntries.end()) {
              Value outputRef = callIndirectOp.getArgOperands()[3];
              const std::vector<uint8_t> &valueData = entryIt->second;
              Type refType = outputRef.getType();

              if (auto refT = dyn_cast<llhd::RefType>(refType)) {
                Type innerType = refT.getNestedType();
                unsigned innerBits = getTypeWidth(innerType);
                unsigned innerBytes = (innerBits + 7) / 8;
                llvm::APInt valueBits2(innerBits, 0);
                for (unsigned i = 0;
                     i < std::min(innerBytes, (unsigned)valueData.size()); ++i)
                  safeInsertBits(valueBits2,llvm::APInt(8, valueData[i]), i * 8);
                SignalId sigId3 = resolveSignalId(outputRef);
                if (sigId3 != 0)
                  pendingEpsilonDrives[sigId3] = InterpretedValue(valueBits2);
                // Also write to memory (same as direct-resolution path).
                InterpretedValue refAddr3 = getValue(procId, outputRef);
                if (!refAddr3.isX()) {
                  uint64_t addr3 = refAddr3.getUInt64();
                  uint64_t off4 = 0;
                  MemoryBlock *blk3 =
                      findMemoryBlockByAddress(addr3, procId, &off4);
                  if (!blk3)
                    blk3 = findBlockByAddress(addr3, off4);
                  if (blk3) {
                    writeConfigDbBytesToMemoryBlock(
                        blk3, off4, valueData, innerBytes,
                        /*zeroFillMissing=*/true);
                  } else {
                    uint64_t nativeOff = 0;
                    size_t nativeSize = 0;
                    if (findNativeMemoryBlockByAddress(addr3, &nativeOff,
                                                       &nativeSize)) {
                      writeConfigDbBytesToNativeMemory(
                          addr3, nativeOff, nativeSize, valueData, innerBytes,
                          /*zeroFillMissing=*/true);
                    }
                  }
                }
              } else if (isa<LLVM::LLVMPointerType>(refType)) {
                if (!sArgs[3].isX()) {
                  uint64_t outputAddr = sArgs[3].getUInt64();
                  uint64_t outOff2 = 0;
                  MemoryBlock *outBlock =
                      findMemoryBlockByAddress(outputAddr, procId, &outOff2);
                  if (!outBlock)
                    outBlock = findBlockByAddress(outputAddr, outOff2);
                  if (outBlock) {
                    writeConfigDbBytesToMemoryBlock(
                        outBlock, outOff2, valueData,
                        static_cast<unsigned>(valueData.size()),
                        /*zeroFillMissing=*/false);
                  } else {
                    uint64_t nativeOff = 0;
                    size_t nativeSize = 0;
                    if (findNativeMemoryBlockByAddress(outputAddr, &nativeOff,
                                                       &nativeSize)) {
                      writeConfigDbBytesToNativeMemory(
                          outputAddr, nativeOff, nativeSize, valueData,
                          static_cast<unsigned>(valueData.size()),
                          /*zeroFillMissing=*/false);
                    }
                  }
                }
              }

              setValue(procId, callIndirectOp.getResult(0),
                      InterpretedValue(llvm::APInt(1, 1)));
              staticResolved = true;
              break;
            }

            setValue(procId, callIndirectOp.getResult(0),
                    InterpretedValue(llvm::APInt(1, 0)));
            staticResolved = true;
            break;
          }
        }

        // Intercept analysis_port::write in non-X static fallback path.
        if (resolvedName.contains("analysis_port") &&
            resolvedName.contains("::write") &&
            !resolvedName.contains("write_m_") && sArgs.size() >= 2) {
          uint64_t portAddr3 = sArgs[0].isX() ? 0 : sArgs[0].getUInt64();
          if (traceAnalysisEnabled)
            llvm::errs() << "[ANALYSIS-WRITE-STATIC] " << resolvedName
                         << " portAddr=0x" << llvm::format_hex(portAddr3, 0)
                         << " inMap=" << analysisPortConnections.count(portAddr3)
                         << "\n";
          llvm::SmallVector<uint64_t, 4> terminals3;
          llvm::SmallVector<uint64_t, 8> worklist3;
          llvm::DenseSet<uint64_t> visited3;
          auto seedIt3 = analysisPortConnections.find(portAddr3);
          if (seedIt3 != analysisPortConnections.end()) {
            for (uint64_t a : seedIt3->second)
              worklist3.push_back(a);
          }
          while (!worklist3.empty()) {
            uint64_t addr = worklist3.pop_back_val();
            if (!visited3.insert(addr).second)
              continue;
            auto chainIt = analysisPortConnections.find(addr);
            if (chainIt != analysisPortConnections.end() &&
                !chainIt->second.empty()) {
              for (uint64_t next : chainIt->second)
                worklist3.push_back(next);
            } else {
              terminals3.push_back(addr);
            }
          }
          if (!terminals3.empty()) {
            if (traceAnalysisEnabled)
              llvm::errs() << "[ANALYSIS-WRITE-STATIC] " << terminals3.size()
                           << " terminal(s) found\n";
            for (uint64_t impAddr : terminals3) {
              uint64_t vtableOff3 = 0;
              MemoryBlock *impBlock3 = findBlockByAddress(impAddr, vtableOff3);
              if (!impBlock3 || vtableOff3 + 4 + 8 > impBlock3->size)
                continue;
              uint64_t vtableAddr3 = 0;
              for (unsigned i = 0; i < 8; ++i)
                vtableAddr3 |= static_cast<uint64_t>(
                                   impBlock3->data[vtableOff3 + 4 + i])
                               << (i * 8);
              auto gIt = addressToGlobal.find(vtableAddr3);
              if (gIt == addressToGlobal.end())
                continue;
              auto vbIt = globalMemoryBlocks.find(gIt->second);
              if (vbIt == globalMemoryBlocks.end())
                continue;
              auto &vb = vbIt->second;
              unsigned writeSlot3 = 11;
              unsigned slotOff3 = writeSlot3 * 8;
              if (slotOff3 + 8 > vb.size)
                continue;
              uint64_t wfa = 0;
              for (unsigned i = 0; i < 8; ++i)
                wfa |= static_cast<uint64_t>(vb.data[slotOff3 + i]) << (i * 8);
              auto fi = addressToFunction.find(wfa);
              if (fi == addressToFunction.end())
                continue;
              auto iwf = modOp.lookupSymbol<func::FuncOp>(fi->second);
              if (!iwf)
                continue;
              if (traceAnalysisEnabled)
                llvm::errs() << "[ANALYSIS-WRITE-STATIC] dispatching to "
                             << fi->second << "\n";
              SmallVector<InterpretedValue, 2> iArgs;
              iArgs.push_back(InterpretedValue(llvm::APInt(64, impAddr)));
              iArgs.push_back(sArgs[1]);
              SmallVector<InterpretedValue, 2> iRes;
              auto &cs3 = processStates[procId];
              ++cs3.callDepth;
              (void)interpretFuncBody(procId, iwf, iArgs, iRes, callIndirectOp);
              --cs3.callDepth;
            }
            staticResolved = true;
            break;
          }
          // If no native connections, fall through to normal UVM body dispatch.
        }

        // Intercept resolve_bindings in non-X static fallback path.
        if (resolvedName.contains("uvm_port_base") &&
            resolvedName.contains("::resolve_bindings")) {
          staticResolved = true;
          break;
        }

        // [SEQ-UNMAPPED] diagnostic removed
        auto &cs2 = processStates[procId];
        ++cs2.callDepth;
        SmallVector<InterpretedValue, 4> sResults;
        auto callRes = interpretFuncBody(procId, fOp, sArgs, sResults,
                                         callIndirectOp);
        --cs2.callDepth;
        if (failed(callRes))
          break;
        for (auto [result, val] :
             llvm::zip(callIndirectOp.getResults(), sResults))
          setValue(procId, result, val);
        staticResolved = true;
      } while (false);
      if (!staticResolved) {
        LLVM_DEBUG(llvm::dbgs()
                   << "  func.call_indirect: address 0x"
                   << llvm::format_hex(funcAddr, 16)
                   << " not in vtable map\n");
        std::string reason = "address " +
            llvm::utohexstr(funcAddr) + " not found in vtable map";
        emitVtableWarning(reason);
        for (Value result : callIndirectOp.getResults()) {
          unsigned width = getTypeWidth(result.getType());
          setValue(procId, result, InterpretedValue(llvm::APInt(width, 0)));
        }
      }
      return success();
    }

    StringRef calleeName = it->second;
    std::string overriddenCalleeName;
    // [CI-DISPATCH] diagnostic removed
    LLVM_DEBUG(llvm::dbgs() << "  func.call_indirect: resolved 0x"
                            << llvm::format_hex(funcAddr, 16)
                            << " -> " << calleeName << "\n");

    if (profilingEnabled)
      ++funcCallProfile[calleeName];

    // Runtime vtable override for the direct resolution path.
    // When the static function address maps to a base-class method, check
    // the self object's actual runtime vtable and resolve to the derived
    // class's override if it differs.
    do {
      // Trace the SSA chain: cast → load → GEP to find the method index
      auto castOp = calleeValue.getDefiningOp<mlir::UnrealizedConversionCastOp>();
      if (!castOp || castOp.getInputs().size() != 1)
        break;
      auto funcPtrLoad = castOp.getInputs()[0].getDefiningOp<LLVM::LoadOp>();
      if (!funcPtrLoad)
        break;
      auto vtableGEP = funcPtrLoad.getAddr().getDefiningOp<LLVM::GEPOp>();
      if (!vtableGEP)
        break;
      auto vtableIndices = vtableGEP.getIndices();
      int64_t methodIndex = -1;
      if (vtableIndices.size() >= 2) {
        auto lastIdx = vtableIndices[vtableIndices.size() - 1];
        if (auto intAttr = llvm::dyn_cast_if_present<IntegerAttr>(lastIdx))
          methodIndex = intAttr.getInt();
        else if (auto dynIdx = llvm::dyn_cast_if_present<Value>(lastIdx)) {
          InterpretedValue dynVal = getValue(procId, dynIdx);
          if (!dynVal.isX())
            methodIndex = static_cast<int64_t>(dynVal.getUInt64());
        }
      }
      if (methodIndex < 0)
        break;

      // Read the self object's runtime vtable pointer
      if (callIndirectOp.getArgOperands().empty())
        break;
      InterpretedValue selfVal = getValue(procId, callIndirectOp.getArgOperands()[0]);
      if (selfVal.isX())
        break;
      uint64_t objAddr = selfVal.getUInt64();
      uint64_t vtableOff = 0;
      MemoryBlock *objBlock = findBlockByAddress(objAddr, vtableOff);
      if (!objBlock || !objBlock->initialized ||
          objBlock->data.size() < vtableOff + 12)
        break;

      // Read vtable pointer (8 bytes at offset 4, after i32 class_id)
      uint64_t runtimeVtableAddr = 0;
      for (unsigned i = 0; i < 8; ++i)
        runtimeVtableAddr |= static_cast<uint64_t>(
                                 objBlock->data[vtableOff + 4 + i])
                             << (i * 8);
      auto globalIt = addressToGlobal.find(runtimeVtableAddr);
      if (globalIt == addressToGlobal.end())
        break;
      std::string runtimeVtableName = globalIt->second;

      // Read the function pointer from the runtime vtable at the same slot
      auto vtableBlockIt = globalMemoryBlocks.find(runtimeVtableName);
      if (vtableBlockIt == globalMemoryBlocks.end())
        break;
      auto &vtableBlock = vtableBlockIt->second;
      unsigned slotOffset = methodIndex * 8;
      if (slotOffset + 8 > vtableBlock.size)
        break;
      uint64_t runtimeFuncAddr = 0;
      for (unsigned i = 0; i < 8; ++i)
        runtimeFuncAddr |=
            static_cast<uint64_t>(vtableBlock.data[slotOffset + i]) << (i * 8);
      if (runtimeFuncAddr == 0 || runtimeFuncAddr == funcAddr)
        break;

      // The runtime vtable has a different function at this slot — override
      auto runtimeFuncIt = addressToFunction.find(runtimeFuncAddr);
      if (runtimeFuncIt == addressToFunction.end())
        break;

      overriddenCalleeName = runtimeFuncIt->second;
      LLVM_DEBUG(llvm::dbgs()
                 << "  func.call_indirect: runtime vtable override: "
                 << calleeName << " -> " << overriddenCalleeName
                 << " (vtable=" << runtimeVtableName
                 << " slot=" << methodIndex << ")\n");
      calleeName = overriddenCalleeName;
    } while (false);

    // Intercept uvm_default_factory::register — fast-path native
    // registration. The original MLIR calls get_type_name 3-7 times via
    // vtable, does string comparisons, assoc array lookups, and override
    // scanning (~2300 steps each × 1078 types = 2.5M steps = ~80s).
    // We call get_type_name once (~6 ops) and store in a C++ map.
    if (calleeName == "uvm_pkg::uvm_default_factory::register" ||
        calleeName == "uvm_pkg::uvm_factory::register") {
      bool registered = false;
      do {
        if (callIndirectOp.getArgOperands().size() < 2)
          break;
        InterpretedValue wrapperVal =
            getValue(procId, callIndirectOp.getArgOperands()[1]);
        if (wrapperVal.isX() || wrapperVal.getUInt64() == 0)
          break;
        uint64_t wrapperAddr = wrapperVal.getUInt64();

        // Read wrapper's vtable pointer: struct uvm_void { i32, ptr }
        // vtable ptr is at offset 4 (after i32 __class_handle)
        uint64_t off = 0;
        MemoryBlock *blk = findBlockByAddress(wrapperAddr + 4, off);
        if (!blk || !blk->initialized || off + 8 > blk->data.size())
          break;
        uint64_t vtableAddr = 0;
        for (unsigned i = 0; i < 8; ++i)
          vtableAddr |= static_cast<uint64_t>(blk->data[off + i]) << (i * 8);
        if (vtableAddr == 0)
          break;

        // Read vtable entry [2] = get_type_name
        uint64_t off2 = 0;
        MemoryBlock *vtableBlk =
            findBlockByAddress(vtableAddr + 2 * 8, off2);
        if (!vtableBlk || !vtableBlk->initialized ||
            off2 + 8 > vtableBlk->data.size())
          break;
        uint64_t funcAddr = 0;
        for (unsigned i = 0; i < 8; ++i)
          funcAddr |=
              static_cast<uint64_t>(vtableBlk->data[off2 + i]) << (i * 8);
        auto funcIt = addressToFunction.find(funcAddr);
        if (funcIt == addressToFunction.end())
          break;

        // Call get_type_name(wrapper) → struct<(ptr, i64)>
        auto funcOp =
            rootModule.lookupSymbol<mlir::func::FuncOp>(funcIt->second);
        if (!funcOp)
          break;
        SmallVector<InterpretedValue, 1> results;
        if (failed(interpretFuncBody(procId, funcOp, {wrapperVal}, results)) ||
            results.empty())
          break;

        // Extract (ptr, length) from 128-bit struct<(ptr, i64)>
        InterpretedValue nameStruct = results[0];
        if (nameStruct.isX() || nameStruct.getWidth() < 128)
          break;
        APInt nameAPInt = nameStruct.getAPInt();
        uint64_t strAddr = nameAPInt.extractBits(64, 0).getZExtValue();
        uint64_t strLen = nameAPInt.extractBits(64, 64).getZExtValue();
        if (strLen == 0 || strLen > 1024 || strAddr == 0)
          break;

        // Read the string content from the packed string global
        uint64_t strOff = 0;
        MemoryBlock *strBlk = findBlockByAddress(strAddr, strOff);
        if (!strBlk || !strBlk->initialized ||
            strOff + strLen > strBlk->data.size())
          break;
        std::string typeName(
            reinterpret_cast<const char *>(strBlk->data.data() + strOff),
            strLen);

        // Store in native factory map
        nativeFactoryTypeNames[typeName] = wrapperAddr;
        registered = true;
      } while (false);
      if (registered) {
        return success();
      }
      // Fast-path failed, fall through to normal MLIR interpretation
      // so the type still gets registered. Critical for test classes.
      // Don't return — fall through to normal call handling so
      // the type still gets registered. Critical for test classes.
    }

    // Intercept create_component_by_name — since factory.register was
    // fast-pathed (skipping MLIR-side data population), the MLIR-side
    // create_component_by_name won't find registered types. This
    // intercept looks up the wrapper from the C++ map and calls
    // create_component via the wrapper's vtable slot 1.
    // Signature: (this, requested_type_name: struct<(ptr,i64)>,
    //             parent_inst_path: struct<(ptr,i64)>,
    //             name: struct<(ptr,i64)>, parent: ptr) -> ptr
    if ((calleeName ==
             "uvm_pkg::uvm_default_factory::create_component_by_name" ||
         calleeName == "uvm_pkg::uvm_factory::create_component_by_name") &&
        callIndirectOp.getNumResults() >= 1 &&
        callIndirectOp.getArgOperands().size() >= 5) {
      // Extract the requested type name string (arg1).
      InterpretedValue nameVal =
          getValue(procId, callIndirectOp.getArgOperands()[1]);
      std::string requestedName;
      bool nameExtracted = false;
      if (!nameVal.isX() && nameVal.getWidth() >= 128) {
        APInt nameAPInt = nameVal.getAPInt();
        uint64_t strAddr = nameAPInt.extractBits(64, 0).getZExtValue();
        int64_t strLen =
            static_cast<int64_t>(nameAPInt.extractBits(64, 64).getZExtValue());
        if (strLen > 0 && strLen <= 1024 && strAddr != 0) {
          nameExtracted =
              tryReadStringKey(procId, strAddr, strLen, requestedName);
        }
      }
      if (nameExtracted && !requestedName.empty()) {
        auto it = nativeFactoryTypeNames.find(requestedName);
        if (it != nativeFactoryTypeNames.end()) {
          uint64_t wrapperAddr = it->second;
          // Read wrapper's vtable pointer (at offset 4 after i32).
          uint64_t off = 0;
          MemoryBlock *blk = findBlockByAddress(wrapperAddr + 4, off);
          if (blk && blk->initialized && off + 8 <= blk->data.size()) {
            uint64_t vtableAddr = 0;
            for (unsigned i = 0; i < 8; ++i)
              vtableAddr |=
                  static_cast<uint64_t>(blk->data[off + i]) << (i * 8);
            // Read vtable slot 1 = create_component.
            uint64_t off2 = 0;
            MemoryBlock *vtBlk =
                findBlockByAddress(vtableAddr + 1 * 8, off2);
            if (vtBlk && vtBlk->initialized &&
                off2 + 8 <= vtBlk->data.size()) {
              uint64_t funcAddr = 0;
              for (unsigned i = 0; i < 8; ++i)
                funcAddr |= static_cast<uint64_t>(vtBlk->data[off2 + i])
                            << (i * 8);
              auto funcIt = addressToFunction.find(funcAddr);
              if (funcIt != addressToFunction.end()) {
                auto funcOp = rootModule.lookupSymbol<mlir::func::FuncOp>(
                    funcIt->second);
                if (funcOp) {
                  // create_component(wrapper, name, parent) -> ptr
                  InterpretedValue wrapperVal(wrapperAddr, 64);
                  InterpretedValue nameArg =
                      getValue(procId, callIndirectOp.getArgOperands()[3]);
                  InterpretedValue parentArg =
                      getValue(procId, callIndirectOp.getArgOperands()[4]);
                  SmallVector<InterpretedValue, 1> results;
                  if (succeeded(interpretFuncBody(
                          procId, funcOp,
                          {wrapperVal, nameArg, parentArg}, results)) &&
                      !results.empty()) {
                    setValue(procId, callIndirectOp.getResults()[0],
                             results[0]);
                    return success();
                  }
                }
              }
            }
          }
        }
      }
      // Fall through to MLIR interpretation if fast-path fails.
    }

    // Intercept find_wrapper_by_name — uses nativeFactoryTypeNames to look
    // up a type name registered by the fast-path factory.register above.
    // This is needed for +UVM_TESTNAME to find the test class wrapper.
    if ((calleeName == "uvm_pkg::uvm_default_factory::find_wrapper_by_name" ||
         calleeName == "uvm_pkg::uvm_factory::find_wrapper_by_name") &&
        callIndirectOp.getNumResults() >= 1 &&
        callIndirectOp.getArgOperands().size() >= 2) {
      InterpretedValue nameVal =
          getValue(procId, callIndirectOp.getArgOperands()[1]);
      uint64_t wrapperResult = 0;
      if (!nameVal.isX() && nameVal.getWidth() >= 128 &&
          !nativeFactoryTypeNames.empty()) {
        APInt nameAPInt = nameVal.getAPInt();
        uint64_t strAddr = nameAPInt.extractBits(64, 0).getZExtValue();
        int64_t strLen = static_cast<int64_t>(
            nameAPInt.extractBits(64, 64).getZExtValue());
        std::string searchName;
        if (strLen > 0 && strLen <= 1024 && strAddr != 0 &&
            tryReadStringKey(procId, strAddr, strLen, searchName)) {
          auto it = nativeFactoryTypeNames.find(searchName);
          if (it != nativeFactoryTypeNames.end())
            wrapperResult = it->second;
        }
      }
      setValue(procId, callIndirectOp.getResults()[0],
               InterpretedValue(wrapperResult, 64));
      return success();
    }

    // Intercept is_type_name_registered — checks if a type name was
    // registered by the fast-path factory.register above.
    if ((calleeName == "uvm_pkg::uvm_default_factory::is_type_name_registered" ||
         calleeName == "uvm_pkg::uvm_factory::is_type_name_registered") &&
        callIndirectOp.getNumResults() >= 1 &&
        callIndirectOp.getArgOperands().size() >= 2) {
      InterpretedValue nameVal =
          getValue(procId, callIndirectOp.getArgOperands()[1]);
      bool found = false;
      if (!nameVal.isX() && nameVal.getWidth() >= 128 &&
          !nativeFactoryTypeNames.empty()) {
        APInt nameAPInt = nameVal.getAPInt();
        uint64_t strAddr = nameAPInt.extractBits(64, 0).getZExtValue();
        int64_t strLen = static_cast<int64_t>(
            nameAPInt.extractBits(64, 64).getZExtValue());
        std::string searchName;
        if (strLen > 0 && strLen <= 1024 && strAddr != 0 &&
            tryReadStringKey(procId, strAddr, strLen, searchName)) {
          found = nativeFactoryTypeNames.count(searchName) > 0;
        }
      }
      setValue(procId, callIndirectOp.getResults()[0],
               InterpretedValue(llvm::APInt(1, found ? 1 : 0)));
      return success();
    }

    // Intercept is_type_registered — checks if a wrapper ptr was registered.
    if ((calleeName == "uvm_pkg::uvm_default_factory::is_type_registered" ||
         calleeName == "uvm_pkg::uvm_factory::is_type_registered") &&
        callIndirectOp.getNumResults() >= 1 &&
        callIndirectOp.getArgOperands().size() >= 2) {
      InterpretedValue wrapperVal =
          getValue(procId, callIndirectOp.getArgOperands()[1]);
      bool found = false;
      if (!wrapperVal.isX() && wrapperVal.getUInt64() != 0) {
        uint64_t addr = wrapperVal.getUInt64();
        for (auto &[name, wAddr] : nativeFactoryTypeNames) {
          if (wAddr == addr) {
            found = true;
            break;
          }
        }
      }
      setValue(procId, callIndirectOp.getResults()[0],
               InterpretedValue(llvm::APInt(1, found ? 1 : 0)));
      return success();
    }

    if (handleUvmCallIndirectFastPath(procId, callIndirectOp, calleeName))
      return success();

    // Intercept end_of_elaboration_phase for any class whose EOE function
    // body calls uvm_driver::end_of_elaboration_phase (which checks
    // seq_item_port.size() and emits DRVCONNECT). We intercept at this
    // level for direct uvm_driver dispatches, and also suppress derived
    // class overrides that call super.end_of_elaboration_phase via func.call.
    if (calleeName.contains("end_of_elaboration_phase") &&
        calleeName.contains("uvm_driver") &&
        !calleeName.contains("driver_proxy")) {
      LLVM_DEBUG(llvm::dbgs()
                 << "  call_indirect: end_of_elaboration_phase "
                 << "intercepted (no-op, suppresses DRVCONNECT): "
                 << calleeName << "\n");
      return success();
    }

    // Intercept m_set_full_name to avoid O(N^2) recursive children traversal.
    // During UVM build_phase, each component's constructor calls
    // m_set_full_name on itself. The function computes
    //   self.full_name = parent.get_full_name() + "." + self.get_name()
    // then recursively calls m_set_full_name on every child. The recursive
    // update is redundant because each child calls m_set_full_name on itself
    // during its own construction. We compute the name natively and skip the
    // children loop, turning O(N^2) into O(N).
    if (calleeName.contains("m_set_full_name")) {
      if (!callIndirectOp.getArgOperands().empty()) {
        InterpretedValue selfVal =
            getValue(procId, callIndirectOp.getArgOperands()[0]);
        if (!selfVal.isX() && selfVal.getUInt64() >= 0x1000) {
          uint64_t selfAddr = selfVal.getUInt64();

          // Byte offsets in the uvm_component struct, computed from the
          // interpreter's packed layout (getLLVMTypeSize sums getTypeWidth
          // bits per field, then rounds to bytes).
          //   field[0] uvm_report_object: 41 bytes
          //     field[0][0] uvm_object: 32 bytes
          //       field[0][0][0] uvm_void(i32,ptr): 12 bytes
          //       field[0][0][1] struct<(ptr,i64)> m_inst_name: 16 bytes
          //       field[0][0][2] i32: 4 bytes
          //     field[0][1] ptr: 8 bytes
          //     field[0][2] i1: 1 byte (ceil to 1 byte)
          //   field[1] i1: 1 byte
          //   fields[2-6] ptr x5: 40 bytes
          //   field[7] i1: 1 byte
          //   field[8] i32: 4 bytes
          //   field[9] ptr m_parent: offset 87
          //   field[10] ptr m_children: offset 95
          //   fields[11-13] ptr x3: 24 bytes
          //   field[14] struct<(ptr,i64)> full_name: offset 127
          constexpr uint64_t kParentOff = 87;
          constexpr uint64_t kInstNameOff = 12;
          constexpr uint64_t kFullNameOff = 127;

          // Read 8 little-endian bytes from a memory address.
          auto readU64 = [&](uint64_t addr) -> uint64_t {
            uint64_t off = 0;
            MemoryBlock *blk = findBlockByAddress(addr, off);
            if (!blk)
              blk = findMemoryBlockByAddress(addr, procId, &off);
            if (!blk || !blk->initialized || off + 8 > blk->data.size())
              return 0;
            uint64_t val = 0;
            for (unsigned i = 0; i < 8; ++i)
              val |= static_cast<uint64_t>(blk->data[off + i]) << (i * 8);
            return val;
          };

          // Read a string from a struct<(ptr, i64)> stored at addr.
          auto readStr = [&](uint64_t addr) -> std::string {
            uint64_t strPtr = readU64(addr);
            int64_t strLen = static_cast<int64_t>(readU64(addr + 8));
            if (strPtr == 0 || strLen <= 0)
              return "";
            auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
            if (dynIt != dynamicStrings.end() && dynIt->second.first &&
                dynIt->second.second > 0)
              return std::string(
                  dynIt->second.first,
                  std::min(static_cast<size_t>(strLen),
                           static_cast<size_t>(dynIt->second.second)));
            uint64_t off = 0;
            MemoryBlock *gBlock = findBlockByAddress(strPtr, off);
            if (gBlock && gBlock->initialized) {
              size_t avail =
                  std::min(static_cast<size_t>(strLen),
                           gBlock->data.size() - static_cast<size_t>(off));
              if (avail > 0)
                return std::string(
                    reinterpret_cast<const char *>(gBlock->data.data() + off),
                    avail);
            }
            return "";
          };

          // Write a struct<(ptr, i64)> string to addr.
          auto writeStr = [&](uint64_t addr, uint64_t strPtr, int64_t strLen) {
            uint64_t off = 0;
            MemoryBlock *blk = findBlockByAddress(addr, off);
            if (!blk)
              blk = findMemoryBlockByAddress(addr, procId, &off);
            if (!blk || off + 16 > blk->data.size())
              return;
            for (unsigned i = 0; i < 8; ++i) {
              blk->data[off + i] =
                  static_cast<uint8_t>((strPtr >> (i * 8)) & 0xFF);
              blk->data[off + 8 + i] = static_cast<uint8_t>(
                  (static_cast<uint64_t>(strLen) >> (i * 8)) & 0xFF);
            }
            blk->initialized = true;
          };

          uint64_t parentAddr = readU64(selfAddr + kParentOff);
          std::string instName = readStr(selfAddr + kInstNameOff);

          std::string fullName;
          if (parentAddr == 0) {
            fullName = instName;
          } else {
            // Check if parent IS-A uvm_root (class_id target = 93).
            uint64_t cidOff = 0;
            MemoryBlock *pBlk = findBlockByAddress(parentAddr, cidOff);
            if (!pBlk)
              pBlk = findMemoryBlockByAddress(parentAddr, procId, &cidOff);
            bool isRoot = false;
            if (pBlk && pBlk->initialized &&
                cidOff + 4 <= pBlk->data.size()) {
              int32_t cid = 0;
              for (unsigned i = 0; i < 4; ++i)
                cid |= static_cast<int32_t>(pBlk->data[cidOff + i])
                       << (i * 8);
              isRoot = checkRTTICast(cid, 93);
            }
            if (isRoot) {
              fullName = instName;
            } else {
              std::string parentFull = readStr(parentAddr + kFullNameOff);
              fullName = parentFull + "." + instName;
            }
          }

          // Persist the string and register in dynamicStrings.
          interpreterStrings.push_back(std::move(fullName));
          const std::string &stored = interpreterStrings.back();
          int64_t pv = reinterpret_cast<int64_t>(stored.data());
          int64_t lv = static_cast<int64_t>(stored.size());
          dynamicStrings[pv] = {stored.data(), lv};

          writeStr(selfAddr + kFullNameOff, static_cast<uint64_t>(pv), lv);

          LLVM_DEBUG(llvm::dbgs()
                     << "  call_indirect: m_set_full_name intercepted -> \""
                     << stored << "\"\n");
          return success();
        }
      }
    }

    // Intercept get_full_name on uvm_component (and subclasses).
    // Returns the stored full_name field at offset 127 directly,
    // avoiding vtable dispatch, string comparison, and alloca ops.
    if (calleeName.contains("get_full_name") &&
        calleeName.contains("uvm_component") &&
        callIndirectOp.getNumResults() >= 1 &&
        !callIndirectOp.getArgOperands().empty()) {
      InterpretedValue selfVal =
          getValue(procId, callIndirectOp.getArgOperands()[0]);
      if (!selfVal.isX() && selfVal.getUInt64() >= 0x1000) {
        uint64_t selfAddr = selfVal.getUInt64();
        constexpr uint64_t kFullNameOff2 = 127;
        auto readU64L = [&](uint64_t addr) -> uint64_t {
          uint64_t off = 0;
          MemoryBlock *blk = findBlockByAddress(addr, off);
          if (!blk)
            blk = findMemoryBlockByAddress(addr, procId, &off);
          if (!blk || !blk->initialized || off + 8 > blk->data.size())
            return 0;
          uint64_t val = 0;
          for (unsigned i = 0; i < 8; ++i)
            val |= static_cast<uint64_t>(blk->data[off + i]) << (i * 8);
          return val;
        };
        uint64_t strPtr = readU64L(selfAddr + kFullNameOff2);
        uint64_t strLen = readU64L(selfAddr + kFullNameOff2 + 8);
        if (strPtr != 0 && strLen > 0) {
          uint64_t words[2] = {strPtr, strLen};
          llvm::APInt resultVal(128, llvm::ArrayRef<uint64_t>(words, 2));
          setValue(procId, callIndirectOp.getResult(0),
                   InterpretedValue(resultVal));
          return success();
        }
      }
    }

    // Intercept get_name on uvm_object - returns m_inst_name at offset 12.
    if (calleeName.contains("get_name") &&
        calleeName.contains("uvm_object") &&
        !calleeName.contains("get_name_constraint") &&
        !calleeName.contains("get_name_enabled") &&
        callIndirectOp.getNumResults() >= 1 &&
        !callIndirectOp.getArgOperands().empty()) {
      InterpretedValue selfVal =
          getValue(procId, callIndirectOp.getArgOperands()[0]);
      if (!selfVal.isX() && selfVal.getUInt64() >= 0x1000) {
        uint64_t selfAddr = selfVal.getUInt64();
        constexpr uint64_t kInstNameOff2 = 12;
        auto readU64L = [&](uint64_t addr) -> uint64_t {
          uint64_t off = 0;
          MemoryBlock *blk = findBlockByAddress(addr, off);
          if (!blk)
            blk = findMemoryBlockByAddress(addr, procId, &off);
          if (!blk || !blk->initialized || off + 8 > blk->data.size())
            return 0;
          uint64_t val = 0;
          for (unsigned i = 0; i < 8; ++i)
            val |= static_cast<uint64_t>(blk->data[off + i]) << (i * 8);
          return val;
        };
        uint64_t strPtr = readU64L(selfAddr + kInstNameOff2);
        uint64_t strLen = readU64L(selfAddr + kInstNameOff2 + 8);
        uint64_t words[2] = {strPtr, strLen};
        llvm::APInt resultVal(128, llvm::ArrayRef<uint64_t>(words, 2));
        setValue(procId, callIndirectOp.getResult(0),
                 InterpretedValue(resultVal));
        return success();
      }
    }

    // Intercept uvm_get_report_object - trivially returns self.
    if (calleeName.contains("uvm_get_report_object") &&
        callIndirectOp.getNumResults() >= 1 &&
        !callIndirectOp.getArgOperands().empty()) {
      setValue(procId, callIndirectOp.getResult(0),
               getValue(procId, callIndirectOp.getArgOperands()[0]));
      return success();
    }

    // Intercept get_parent on uvm_component - returns field[9] at offset 87.
    if (calleeName.contains("get_parent") &&
        calleeName.contains("uvm_component") &&
        callIndirectOp.getNumResults() >= 1 &&
        !callIndirectOp.getArgOperands().empty()) {
      InterpretedValue selfVal =
          getValue(procId, callIndirectOp.getArgOperands()[0]);
      if (!selfVal.isX() && selfVal.getUInt64() >= 0x1000) {
        constexpr uint64_t kParentOff2 = 87;
        uint64_t off = 0;
        MemoryBlock *blk = findBlockByAddress(selfVal.getUInt64() + kParentOff2, off);
        if (!blk)
          blk = findMemoryBlockByAddress(selfVal.getUInt64() + kParentOff2, procId, &off);
        if (blk && blk->initialized && off + 8 <= blk->data.size()) {
          uint64_t parentAddr = 0;
          for (unsigned i = 0; i < 8; ++i)
            parentAddr |= static_cast<uint64_t>(blk->data[off + i]) << (i * 8);
          setValue(procId, callIndirectOp.getResult(0),
                   InterpretedValue(parentAddr, 64));
          return success();
        }
      }
    }

    // Look up the function
    auto &state = processStates[procId];
    Operation *parent = state.processOrInitialOp;
    while (parent && !isa<ModuleOp>(parent))
      parent = parent->getParentOp();

    // Use rootModule as fallback for global constructors
    ModuleOp moduleOp = parent ? cast<ModuleOp>(parent) : rootModule;
    auto funcOp = moduleOp.lookupSymbol<func::FuncOp>(calleeName);
    if (!funcOp) {
      LLVM_DEBUG(llvm::dbgs() << "  func.call_indirect: function '" << calleeName
                              << "' not found\n");
      for (Value result : callIndirectOp.getResults()) {
        setValue(procId, result,
                 InterpretedValue::makeX(getTypeWidth(result.getType())));
      }
      return success();
    }


    // Gather argument values (use getArgOperands to get just the arguments, not callee)
    SmallVector<InterpretedValue, 4> args;
    for (Value arg : callIndirectOp.getArgOperands()) {
      args.push_back(getValue(procId, arg));
    }

    auto writePointerToOutRef = [&](Value outRef, uint64_t ptrValue) {
      InterpretedValue refAddr = getValue(procId, outRef);
      if (refAddr.isX())
        return;
      uint64_t addr = refAddr.getUInt64();
      if (!addr)
        return;

      uint64_t offset = 0;
      MemoryBlock *refBlock = findMemoryBlockByAddress(addr, procId, &offset);
      if (refBlock && offset + 8 <= refBlock->data.size()) {
        for (unsigned i = 0; i < 8; ++i)
          refBlock->data[offset + i] =
              static_cast<uint8_t>((ptrValue >> (i * 8)) & 0xFF);
        refBlock->initialized = true;
        return;
      }

      uint64_t nativeOffset = 0;
      size_t nativeSize = 0;
      if (findNativeMemoryBlockByAddress(addr, &nativeOffset, &nativeSize) &&
          nativeOffset + 8 <= nativeSize)
        std::memcpy(reinterpret_cast<void *>(addr), &ptrValue, 8);
    };

    auto waitOnHopperDataForCallIndirect = [&](uint64_t hopperAddr) {
      auto &pState = processStates[procId];
      pState.waiting = true;
      pState.sequencerGetRetryCallOp = callIndirectOp.getOperation();
      auto &waiters = phaseHopperWaiters[hopperAddr];
      if (std::find(waiters.begin(), waiters.end(), procId) == waiters.end())
        waiters.push_back(procId);
    };

    auto wakeHopperWaiters = [&](uint64_t hopperAddr) {
      auto waitIt = phaseHopperWaiters.find(hopperAddr);
      if (waitIt == phaseHopperWaiters.end())
        return;
      auto waiters = waitIt->second;
      phaseHopperWaiters.erase(waitIt);
      for (ProcessId waiterProc : waiters) {
        auto stateIt = processStates.find(waiterProc);
        if (stateIt == processStates.end())
          continue;
        if (!stateIt->second.waiting)
          continue;
        stateIt->second.waiting = false;
        scheduler.scheduleProcess(waiterProc, SchedulingRegion::Active);
      }
    };

    // Native queue fast path for phase hopper calls dispatched via vtable.
    if (calleeName.ends_with("uvm_phase_hopper::try_put") && args.size() >= 2 &&
        callIndirectOp.getNumResults() >= 1) {
      uint64_t hopperAddr = args[0].isX() ? 0 : args[0].getUInt64();
      uint64_t phaseAddr = args[1].isX() ? 0 : args[1].getUInt64();
      phaseHopperQueue[hopperAddr].push_back(phaseAddr);
      wakeHopperWaiters(hopperAddr);

      if (hopperAddr != 0) {
        auto it = phaseObjectionHandles.find(hopperAddr);
        int64_t handle = 0;
        if (it != phaseObjectionHandles.end()) {
          handle = it->second;
        } else {
          std::string hopperName = "phase_hopper_" + std::to_string(hopperAddr);
          handle = __moore_objection_create(
              hopperName.c_str(), static_cast<int64_t>(hopperName.size()));
          phaseObjectionHandles[hopperAddr] = handle;
        }
        raisePhaseObjection(handle, 1);
      }

      unsigned width = getTypeWidth(callIndirectOp.getResult(0).getType());
      setValue(procId, callIndirectOp.getResult(0),
               InterpretedValue(llvm::APInt(width, 1)));
      return success();
    }

    if (calleeName.ends_with("uvm_phase_hopper::try_get") && args.size() >= 2 &&
        callIndirectOp.getNumResults() >= 1) {
      uint64_t hopperAddr = args[0].isX() ? 0 : args[0].getUInt64();
      uint64_t phaseAddr = 0;
      bool hasPhase = false;
      auto it = phaseHopperQueue.find(hopperAddr);
      if (it != phaseHopperQueue.end() && !it->second.empty()) {
        phaseAddr = it->second.front();
        it->second.pop_front();
        hasPhase = true;
      }
      writePointerToOutRef(callIndirectOp.getArgOperands()[1], phaseAddr);
      unsigned width = getTypeWidth(callIndirectOp.getResult(0).getType());
      setValue(procId, callIndirectOp.getResult(0),
               InterpretedValue(llvm::APInt(width, hasPhase ? 1 : 0)));
      return success();
    }

    if (calleeName.ends_with("uvm_phase_hopper::try_peek") && args.size() >= 2 &&
        callIndirectOp.getNumResults() >= 1) {
      uint64_t hopperAddr = args[0].isX() ? 0 : args[0].getUInt64();
      uint64_t phaseAddr = 0;
      bool hasPhase = false;
      auto it = phaseHopperQueue.find(hopperAddr);
      if (it != phaseHopperQueue.end() && !it->second.empty()) {
        phaseAddr = it->second.front();
        hasPhase = true;
      }
      writePointerToOutRef(callIndirectOp.getArgOperands()[1], phaseAddr);
      unsigned width = getTypeWidth(callIndirectOp.getResult(0).getType());
      setValue(procId, callIndirectOp.getResult(0),
               InterpretedValue(llvm::APInt(width, hasPhase ? 1 : 0)));
      return success();
    }

    if (calleeName.ends_with("uvm_phase_hopper::peek") && args.size() >= 2) {
      uint64_t hopperAddr = args[0].isX() ? 0 : args[0].getUInt64();
      auto it = phaseHopperQueue.find(hopperAddr);
      if (it != phaseHopperQueue.end() && !it->second.empty()) {
        writePointerToOutRef(callIndirectOp.getArgOperands()[1], it->second.front());
        return success();
      }
      waitOnHopperDataForCallIndirect(hopperAddr);
      return success();
    }

    if (calleeName.ends_with("uvm_phase_hopper::get") && args.size() >= 2) {
      uint64_t hopperAddr = args[0].isX() ? 0 : args[0].getUInt64();
      auto it = phaseHopperQueue.find(hopperAddr);
      if (it != phaseHopperQueue.end() && !it->second.empty()) {
        uint64_t phaseAddr = it->second.front();
        it->second.pop_front();
        writePointerToOutRef(callIndirectOp.getArgOperands()[1], phaseAddr);
        return success();
      }
      waitOnHopperDataForCallIndirect(hopperAddr);
      return success();
    }

    // Intercept uvm_port_base::size() and report count from native
    // analysisPortConnections, not UVM's m_imp_list bookkeeping.
    if (calleeName.contains("uvm_port_base") &&
        calleeName.ends_with("::size") &&
        callIndirectOp.getNumResults() >= 1) {
      uint64_t selfAddr =
          (!args.empty() && !args[0].isX()) ? args[0].getUInt64() : 0;
      int32_t count = getNativeUvmPortSize(analysisPortConnections, selfAddr);
      Value result = callIndirectOp.getResult(0);
      unsigned width = getTypeWidth(result.getType());
      setValue(procId, result,
               InterpretedValue(
                   llvm::APInt(width, static_cast<uint64_t>(count), false)));
      LLVM_DEBUG(llvm::dbgs() << "  call_indirect: uvm_port_base::size self=0x"
                              << llvm::format_hex(selfAddr, 16) << " -> "
                              << count << "\n");
      return success();
    }

    // Intercept resource_db_implementation via call_indirect (vtable dispatch).
    // resource_db#(T) is parametric, so each specialization has its own vtable
    // and calls go through call_indirect, not func.call.
    if (calleeName.contains("resource_db") && calleeName.contains("implementation") &&
        (calleeName.contains("::set") || calleeName.contains("::read_by_name"))) {

      auto readStr = [&](unsigned argIdx) -> std::string {
        if (argIdx >= args.size())
          return "";
        InterpretedValue val = args[argIdx];
        if (val.isX() || val.getWidth() < 128)
          return "";
        llvm::APInt bits = val.getAPInt();
        uint64_t strPtr = bits.extractBits(64, 0).getZExtValue();
        int64_t strLen = bits.extractBits(64, 64).getSExtValue();
        if (strPtr == 0 || strLen <= 0)
          return "";
        auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
        if (dynIt != dynamicStrings.end() && dynIt->second.first &&
            dynIt->second.second > 0)
          return std::string(dynIt->second.first,
                             std::min(static_cast<size_t>(strLen),
                                      static_cast<size_t>(dynIt->second.second)));
        uint64_t off = 0;
        MemoryBlock *gBlock = findBlockByAddress(strPtr, off);
        if (gBlock && gBlock->initialized) {
          size_t avail = std::min(static_cast<size_t>(strLen),
                                  gBlock->data.size() - static_cast<size_t>(off));
          if (avail > 0)
            return std::string(
                reinterpret_cast<const char *>(gBlock->data.data() + off), avail);
        }
        if (strPtr >= 0x10000) {
          const char *p = reinterpret_cast<const char *>(strPtr);
          return std::string(p, static_cast<size_t>(strLen));
        }
        return "";
      };

      if (calleeName.contains("::set") && !calleeName.contains("set_default") &&
          !calleeName.contains("set_override") &&
          !calleeName.contains("set_anonymous")) {
        // set(self, scope, field_name, value, ...)
        if (args.size() >= 4) {
          std::string scope = readStr(1);
          std::string fieldName = readStr(2);
          std::string key = scope + "." + fieldName;
          InterpretedValue &valueArg = args[3];
          unsigned valueBits = valueArg.getWidth();
          unsigned valueBytes = (valueBits + 7) / 8;
          std::vector<uint8_t> valueData(valueBytes, 0);
          if (!valueArg.isX()) {
            llvm::APInt valBits = valueArg.getAPInt();
            for (unsigned i = 0; i < valueBytes; ++i)
              valueData[i] = static_cast<uint8_t>(
                  valBits.extractBits(8, i * 8).getZExtValue());
          }
          configDbEntries[key] = std::move(valueData);
        }
        return success();
      }

      if (calleeName.contains("::read_by_name")) {
        // read_by_name(self, scope, field_name, output_ref, ...) -> i1
        if (args.size() >= 4 && callIndirectOp.getNumResults() >= 1) {
          std::string scope = readStr(1);
          std::string fieldName = readStr(2);
          std::string key = scope + "." + fieldName;

          auto it = configDbEntries.find(key);
          if (it == configDbEntries.end()) {
            for (auto &[k, v] : configDbEntries) {
              size_t dotPos = k.rfind('.');
              if (dotPos != std::string::npos &&
                  k.substr(dotPos + 1) == fieldName) {
                it = configDbEntries.find(k);
                break;
              }
            }
          }

          if (it != configDbEntries.end()) {
            // Write value to output_ref (arg 3)
            Value outputRef = callIndirectOp.getArgOperands()[3];
            const std::vector<uint8_t> &valueData = it->second;
            Type refType = outputRef.getType();

            if (auto refT = dyn_cast<llhd::RefType>(refType)) {
              Type innerType = refT.getNestedType();
              unsigned innerBits = getTypeWidth(innerType);
              unsigned innerBytes = (innerBits + 7) / 8;
              llvm::APInt valueBits(innerBits, 0);
              for (unsigned i = 0;
                   i < std::min(innerBytes, (unsigned)valueData.size()); ++i)
                safeInsertBits(valueBits,llvm::APInt(8, valueData[i]), i * 8);
              SignalId sigId2 = resolveSignalId(outputRef);
              if (sigId2 != 0)
                pendingEpsilonDrives[sigId2] = InterpretedValue(valueBits);
              // Also write directly to memory so that llvm.load can read it.
              // The ref value holds the address of the backing memory.
              InterpretedValue refAddr = getValue(procId, outputRef);
          if (!refAddr.isX()) {
            uint64_t addr = refAddr.getUInt64();
            uint64_t off3 = 0;
            MemoryBlock *blk =
                findMemoryBlockByAddress(addr, procId, &off3);
            if (!blk)
              blk = findBlockByAddress(addr, off3);
            if (blk) {
                  writeConfigDbBytesToMemoryBlock(
                      blk, off3, valueData, innerBytes,
                      /*zeroFillMissing=*/true);
                } else {
                  uint64_t nativeOff = 0;
                  size_t nativeSize = 0;
                  if (findNativeMemoryBlockByAddress(addr, &nativeOff,
                                                     &nativeSize)) {
                    writeConfigDbBytesToNativeMemory(
                        addr, nativeOff, nativeSize, valueData, innerBytes,
                        /*zeroFillMissing=*/true);
                  }
                }
              }
            } else if (isa<LLVM::LLVMPointerType>(refType)) {
              // Pointer output: write directly to memory
              if (!args[3].isX()) {
                uint64_t outputAddr = args[3].getUInt64();
                uint64_t outOff = 0;
                MemoryBlock *outBlock =
                    findMemoryBlockByAddress(outputAddr, procId, &outOff);
                if (!outBlock)
                  outBlock = findBlockByAddress(outputAddr, outOff);
                if (outBlock) {
                  writeConfigDbBytesToMemoryBlock(
                      outBlock, outOff, valueData,
                      static_cast<unsigned>(valueData.size()),
                      /*zeroFillMissing=*/false);
                } else {
                  uint64_t nativeOff = 0;
                  size_t nativeSize = 0;
                  if (findNativeMemoryBlockByAddress(outputAddr, &nativeOff,
                                                     &nativeSize)) {
                    writeConfigDbBytesToNativeMemory(
                        outputAddr, nativeOff, nativeSize, valueData,
                        static_cast<unsigned>(valueData.size()),
                        /*zeroFillMissing=*/false);
                  }
                }
              }
            }

            setValue(procId, callIndirectOp.getResult(0),
                    InterpretedValue(llvm::APInt(1, 1)));
            return success();
          }

          setValue(procId, callIndirectOp.getResult(0),
                  InterpretedValue(llvm::APInt(1, 0)));
          return success();
        }
      }
    }

    // Intercept config_db implementation via call_indirect (vtable dispatch).
    // config_db#(T) is parametric, so each specialization has its own vtable
    // and calls go through call_indirect, not func.call. Without this
    // interceptor, the stub functions (which just return false/void) execute
    // instead of our key-value store, causing BFM handle lookup failures.
    // Note: class name is "config_db_default_implementation_t", so we match
    // on "config_db" + "implementation" separately (not as one substring).
    if (calleeName.contains("config_db") && calleeName.contains("implementation") &&
        (calleeName.contains("::set") || calleeName.contains("::get"))) {

      auto readStr = [&](unsigned argIdx) -> std::string {
        if (argIdx >= args.size())
          return "";
        InterpretedValue val = args[argIdx];
        if (val.isX() || val.getWidth() < 128)
          return "";
        llvm::APInt bits = val.getAPInt();
        uint64_t strPtr = bits.extractBits(64, 0).getZExtValue();
        int64_t strLen = bits.extractBits(64, 64).getSExtValue();
        if (strPtr == 0 || strLen <= 0)
          return "";
        auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
        if (dynIt != dynamicStrings.end() && dynIt->second.first &&
            dynIt->second.second > 0)
          return std::string(dynIt->second.first,
                             std::min(static_cast<size_t>(strLen),
                                      static_cast<size_t>(dynIt->second.second)));
        uint64_t off = 0;
        MemoryBlock *gBlock = findBlockByAddress(strPtr, off);
        if (gBlock && gBlock->initialized) {
          size_t avail = std::min(static_cast<size_t>(strLen),
                                  gBlock->data.size() - static_cast<size_t>(off));
          if (avail > 0)
            return std::string(
                reinterpret_cast<const char *>(gBlock->data.data() + off), avail);
        }
        if (strPtr >= 0x10000) {
          const char *p = reinterpret_cast<const char *>(strPtr);
          return std::string(p, static_cast<size_t>(strLen));
        }
        return "";
      };

      if (calleeName.contains("::set") && !calleeName.contains("set_default") &&
          !calleeName.contains("set_override") &&
          !calleeName.contains("set_anonymous")) {
        // The implementation's set signature is:
        //   (self, computed_inst, sv_inst_name, sv_field_name, value, ...)
        // We want key = sv_inst_name + "." + sv_field_name
        if (args.size() >= 5) {
          // The implementation's set signature:
          //   (self, computed_inst, sv_inst_name, sv_field_name, value, ...)
          // Use sv_inst_name + "." + sv_field_name as key.
          std::string str1 = readStr(1);
          std::string str2 = readStr(2);
          std::string str3 = readStr(3);

          std::string instName = str2;
          std::string fieldName = str3;
          // Fallback: if str3 is empty, try old layout (str1=inst, str2=field)
          if (fieldName.empty()) {
            instName = str1;
            fieldName = str2;
          }
          std::string key = instName + "." + fieldName;

          InterpretedValue &valueArg = args[4];
          unsigned valueBits = valueArg.getWidth();
          unsigned valueBytes = (valueBits + 7) / 8;
          std::vector<uint8_t> valueData(valueBytes, 0);
          if (!valueArg.isX()) {
            llvm::APInt valBits = valueArg.getAPInt();
            for (unsigned i = 0; i < valueBytes; ++i)
              valueData[i] = static_cast<uint8_t>(
                  valBits.extractBits(8, i * 8).getZExtValue());
          }
          configDbEntries[key] = std::move(valueData);
        }
        return success();
      }

      if (calleeName.contains("::get") && !calleeName.contains("get_default")) {
        // get(self, context_ptr, sv_inst_name, sv_field_name, value_ref) -> i1
        if (args.size() >= 5 && callIndirectOp.getNumResults() >= 1) {
          // The implementation's get signature:
          //   (self, context_ptr, sv_inst_name, sv_field_name, value_ref)
          // Use sv_inst_name + "." + sv_field_name as key.
          std::string str1 = readStr(1);
          std::string str2 = readStr(2);
          std::string str3 = readStr(3);

          std::string instName = str2;
          std::string fieldName = str3;
          // Fallback: if str3 empty, try old layout
          if (fieldName.empty()) {
            instName = str1;
            fieldName = str2;
          }
          std::string key = instName + "." + fieldName;

          auto it = configDbEntries.find(key);
          if (it == configDbEntries.end()) {
            // Wildcard match: look for entries where field name matches
            for (auto &[k, v] : configDbEntries) {
              size_t dotPos = k.rfind('.');
              if (dotPos != std::string::npos &&
                  k.substr(dotPos + 1) == fieldName) {
                it = configDbEntries.find(k);
                break;
              }
            }
          }
          // Fuzzy match: if fieldName ends with "_x" (unresolved index),
          // try matching entries where the base name matches with any
          // numeric suffix (e.g., "bfm_x" matches "bfm_0").
          if (it == configDbEntries.end() && fieldName.size() > 2 &&
              fieldName.back() == 'x' &&
              fieldName[fieldName.size() - 2] == '_') {
            std::string baseName = fieldName.substr(0, fieldName.size() - 1);
            for (auto &[k, v] : configDbEntries) {
              size_t dotPos = k.rfind('.');
              if (dotPos != std::string::npos) {
                std::string storedField = k.substr(dotPos + 1);
                if (storedField.size() > baseName.size() &&
                    storedField.substr(0, baseName.size()) == baseName &&
                    std::isdigit(storedField[baseName.size()])) {
                  it = configDbEntries.find(k);
                  LLVM_DEBUG(llvm::dbgs()
                             << "  config_db fuzzy match: '" << fieldName
                             << "' -> '" << storedField << "'\n");
                  break;
                }
              }
            }
          }

          if (it != configDbEntries.end()) {
            Value outputRef = callIndirectOp.getArgOperands()[4];
            const std::vector<uint8_t> &valueData = it->second;
            Type refType = outputRef.getType();


            if (auto refT = dyn_cast<llhd::RefType>(refType)) {
              Type innerType = refT.getNestedType();
              unsigned innerBits = getTypeWidth(innerType);
              unsigned innerBytes = (innerBits + 7) / 8;
              llvm::APInt valueBits(innerBits, 0);
              for (unsigned i = 0;
                   i < std::min(innerBytes, (unsigned)valueData.size()); ++i)
                safeInsertBits(valueBits,llvm::APInt(8, valueData[i]), i * 8);
              SignalId sigId2 = resolveSignalId(outputRef);
              if (sigId2 != 0)
                pendingEpsilonDrives[sigId2] = InterpretedValue(valueBits);
              // Also write directly to memory (use procId-aware lookup
              // to find alloca-backed refs)
              InterpretedValue refAddr = getValue(procId, outputRef);
              if (!refAddr.isX()) {
                uint64_t addr = refAddr.getUInt64();
                uint64_t off3 = 0;
                MemoryBlock *blk =
                    findMemoryBlockByAddress(addr, procId, &off3);
                if (blk) {
                  writeConfigDbBytesToMemoryBlock(
                      blk, off3, valueData, innerBytes,
                      /*zeroFillMissing=*/true);
                } else {
                  // Fallback: write to native memory (heap-allocated blocks)
                  uint64_t nativeOff = 0;
                  size_t nativeSize = 0;
                  if (findNativeMemoryBlockByAddress(addr, &nativeOff,
                                                     &nativeSize)) {
                    writeConfigDbBytesToNativeMemory(
                        addr, nativeOff, nativeSize, valueData, innerBytes,
                        /*zeroFillMissing=*/true);
                  }
                }
              }
            } else if (isa<LLVM::LLVMPointerType>(refType)) {
              if (!args[4].isX()) {
                uint64_t outputAddr = args[4].getUInt64();
                uint64_t outOff = 0;
                MemoryBlock *outBlock =
                    findMemoryBlockByAddress(outputAddr, procId, &outOff);
                if (outBlock) {
                  writeConfigDbBytesToMemoryBlock(
                      outBlock, outOff, valueData,
                      static_cast<unsigned>(valueData.size()),
                      /*zeroFillMissing=*/false);
                } else {
                  // Fallback: write to native memory
                  uint64_t nativeOff = 0;
                  size_t nativeSize = 0;
                  if (findNativeMemoryBlockByAddress(outputAddr, &nativeOff,
                                                     &nativeSize)) {
                    writeConfigDbBytesToNativeMemory(
                        outputAddr, nativeOff, nativeSize, valueData,
                        static_cast<unsigned>(valueData.size()),
                        /*zeroFillMissing=*/false);
                  }
                }
              }
            }

            setValue(procId, callIndirectOp.getResult(0),
                    InterpretedValue(llvm::APInt(1, 1)));
            LLVM_DEBUG(llvm::dbgs()
                       << "  config_db::get(\"" << key << "\") -> found ("
                       << valueData.size() << " bytes) via call_indirect\n");
            return success();
          }

          setValue(procId, callIndirectOp.getResult(0),
                  InterpretedValue(llvm::APInt(1, 0)));
          LLVM_DEBUG(llvm::dbgs()
                     << "  config_db::get(\"" << key
                     << "\") -> not found via call_indirect\n");
          return success();
        }
      }
    }

    // Intercept UVM port connect() via call_indirect.
    // Stores port→provider connections natively and returns immediately,
    // bypassing the UVM "Late Connection" phase check that incorrectly
    // rejects connections when the phase hopper's state tracking marks
    // end_of_elaboration as DONE before connect_phase callbacks finish.
    // The native connection map is used by get_next_item, item_done,
    // analysis_port::write, and other TLM operations.
    if (calleeName.contains("uvm_port_base") && calleeName.contains("::connect") &&
        !calleeName.contains("connect_phase") && args.size() >= 2) {
      uint64_t selfAddr = args[0].isX() ? 0 : args[0].getUInt64();
      uint64_t providerAddr = args[1].isX() ? 0 : args[1].getUInt64();
      if (selfAddr != 0 && providerAddr != 0) {
        auto &conns = analysisPortConnections[selfAddr];
        if (std::find(conns.begin(), conns.end(), providerAddr) == conns.end()) {
          conns.push_back(providerAddr);
          invalidateUvmSequencerQueueCache(selfAddr);
        }
      }
      if (traceAnalysisEnabled)
        llvm::errs() << "[ANALYSIS-CONNECT] " << calleeName
                     << " self=0x" << llvm::format_hex(selfAddr, 0)
                     << " provider=0x" << llvm::format_hex(providerAddr, 0)
                     << "\n";
      // Return immediately — don't fall through to UVM code which would
      // issue "Late Connection" warning and reject the connection.
      return success();
    }

    // Intercept resolve_bindings on UVM ports — since we handle connections
    // natively (bypassing UVM's m_provided_by/m_provided_to), the
    // resolve_bindings check would fail with "connection count of 0 does not
    // meet required minimum". We skip it entirely; our native connection map
    // in analysisPortConnections handles all TLM routing.
    if (calleeName.contains("uvm_port_base") &&
        calleeName.contains("::resolve_bindings")) {
      LLVM_DEBUG(llvm::dbgs()
                 << "  call_indirect: resolve_bindings intercepted (no-op)\n");
      return success();
    }

    // Intercept analysis_port::write to broadcast to connected ports.
    // When the native port_base connect() is rejected due to "Late Connection",
    // the UVM write() loop finds 0 subscribers. We use our native connection
    // map to resolve the correct imp write function via vtable dispatch.
    // Supports multi-hop chains: port → port/export → imp.
    if (calleeName.contains("analysis_port") && calleeName.contains("::write") &&
        !calleeName.contains("write_m_") && args.size() >= 2) {
      uint64_t portAddr = args[0].isX() ? 0 : args[0].getUInt64();
      if (traceAnalysisEnabled)
        llvm::errs() << "[ANALYSIS-WRITE] " << calleeName
                     << " portAddr=0x" << llvm::format_hex(portAddr, 0)
                     << " inMap=" << analysisPortConnections.count(portAddr)
                     << "\n";
      // Flatten the connection chain to find all terminal imps.
      // A terminal is any address that doesn't appear as a key in our map.
      llvm::SmallVector<uint64_t, 4> terminals;
      llvm::SmallVector<uint64_t, 8> worklist;
      llvm::DenseSet<uint64_t> visited;
      auto seedIt = analysisPortConnections.find(portAddr);
      if (seedIt != analysisPortConnections.end()) {
        for (uint64_t a : seedIt->second)
          worklist.push_back(a);
      }
      while (!worklist.empty()) {
        uint64_t addr = worklist.pop_back_val();
        if (!visited.insert(addr).second)
          continue;
        auto chainIt = analysisPortConnections.find(addr);
        if (chainIt != analysisPortConnections.end() && !chainIt->second.empty()) {
          // This is an intermediate port/export — follow its connections.
          for (uint64_t next : chainIt->second)
            worklist.push_back(next);
        } else {
          // Terminal (imp or unconnected export).
          terminals.push_back(addr);
        }
      }
      if (traceAnalysisEnabled && terminals.empty())
        llvm::errs() << "[ANALYSIS-WRITE] NO terminals found for portAddr=0x"
                     << llvm::format_hex(portAddr, 0) << "\n";
      if (!terminals.empty()) {
        if (traceAnalysisEnabled)
          llvm::errs() << "[ANALYSIS-WRITE] " << terminals.size()
                       << " terminal(s) found\n";
        for (uint64_t impAddr : terminals) {
          // Resolve the imp's write function via vtable dispatch.
          // Object layout: [i32 class_id][ptr vtable_ptr][...fields...]
          // Read vtable pointer at byte offset 4 from the imp object.
          uint64_t vtableOff = 0;
          MemoryBlock *impBlock = findBlockByAddress(impAddr, vtableOff);
          if (!impBlock || vtableOff + 4 + 8 > impBlock->size) {
            LLVM_DEBUG(llvm::dbgs()
                       << "  call_indirect: imp object at 0x"
                       << llvm::format_hex(impAddr, 16)
                       << " not found in memory\n");
            continue;
          }
          uint64_t vtableAddr = 0;
          for (unsigned i = 0; i < 8; ++i)
            vtableAddr |= static_cast<uint64_t>(
                              impBlock->data[vtableOff + 4 + i])
                          << (i * 8);
          auto globalIt = addressToGlobal.find(vtableAddr);
          if (globalIt == addressToGlobal.end()) {
            LLVM_DEBUG(llvm::dbgs()
                       << "  call_indirect: vtable at 0x"
                       << llvm::format_hex(vtableAddr, 16)
                       << " not found in addressToGlobal\n");
            continue;
          }
          // Read the write function pointer from vtable slot 11.
          auto vtableBlockIt = globalMemoryBlocks.find(globalIt->second);
          if (vtableBlockIt == globalMemoryBlocks.end())
            continue;
          auto &vtableBlock = vtableBlockIt->second;
          unsigned writeSlot = 11;
          unsigned slotOffset = writeSlot * 8;
          if (slotOffset + 8 > vtableBlock.size)
            continue;
          uint64_t writeFuncAddr = 0;
          for (unsigned i = 0; i < 8; ++i)
            writeFuncAddr |=
                static_cast<uint64_t>(vtableBlock.data[slotOffset + i])
                << (i * 8);
          auto funcIt2 = addressToFunction.find(writeFuncAddr);
          if (funcIt2 == addressToFunction.end()) {
            LLVM_DEBUG(llvm::dbgs()
                       << "  call_indirect: write func at vtable slot 11 (addr 0x"
                       << llvm::format_hex(writeFuncAddr, 16)
                       << ") not found\n");
            continue;
          }
          auto impWriteFunc = moduleOp.lookupSymbol<func::FuncOp>(funcIt2->second);
          if (!impWriteFunc) {
            if (traceAnalysisEnabled)
              llvm::errs() << "[ANALYSIS-WRITE] function '"
                           << funcIt2->second << "' not found in module\n";
            continue;
          }
          if (traceAnalysisEnabled)
            llvm::errs() << "[ANALYSIS-WRITE] dispatching to "
                         << funcIt2->second << "\n";
          SmallVector<InterpretedValue, 2> impArgs;
          impArgs.push_back(InterpretedValue(llvm::APInt(64, impAddr)));
          impArgs.push_back(args[1]); // transaction object
          SmallVector<InterpretedValue, 2> impResults;
          auto &cState = processStates[procId];
          ++cState.callDepth;
          (void)interpretFuncBody(procId, impWriteFunc, impArgs, impResults,
                                 callIndirectOp);
          --cState.callDepth;
        }
        return success();
      }
      // If no native connections, fall through to normal execution
      // (which will iterate the UVM m_imp_list -- may be empty).
    }

    // Intercept UVM sequencer interface: start_item, finish_item, and
    // seq_item_pull_port::get to implement a native rendezvous between
    // sequence producer and driver consumer. This bypasses the complex
    // UVM sequencer arbitration/FIFO machinery (m_safe_select_item,
    // wait_for_grant, send_request, wait_for_item_done) that requires
    // fully functional TLM FIFOs and process synchronization.
    if (traceSeq &&
        (calleeName.contains("::start_item") ||
         calleeName.contains("::finish_item") ||
         ((calleeName.contains("seq_item_pull_port") ||
           calleeName.contains("seq_item_pull_imp") ||
           calleeName.contains("sqr_if_base") ||
         calleeName.contains("uvm_sequencer")) &&
          (calleeName.ends_with("::get") ||
           calleeName.ends_with("::get_next_item") ||
           calleeName.ends_with("::item_done"))))) {
      uint64_t a0 = args.size() > 0 && !args[0].isX() ? args[0].getUInt64() : 0;
      uint64_t a1 = args.size() > 1 && !args[1].isX() ? args[1].getUInt64() : 0;
      llvm::errs() << "[SEQ-CI] " << calleeName << " a0=0x"
                   << llvm::format_hex(a0, 16) << " a1=0x"
                   << llvm::format_hex(a1, 16)
                   << " fifo_maps=" << sequencerItemFifo.size() << "\n";
    }

    // start_item: Record item→sequencer mapping and return immediately
    // (grants arbitration instantly). Args: (self, item, priority, sequencer).
    if (calleeName.contains("::start_item") && args.size() >= 4) {
      uint64_t seqAddr = args[0].isX() ? 0 : args[0].getUInt64();
      uint64_t itemAddr = args[1].isX() ? 0 : args[1].getUInt64();
      uint64_t sqrAddr = args[3].isX() ? 0 : args[3].getUInt64();
      InterpretedValue sqrArg = args[3];
      // If sequencer arg is null, get it from the sequence object.
      // The sequence's m_sequencer is set by seq.start(sqr).
      if (seqAddr != 0) {
        auto getSequencerFunc = moduleOp.lookupSymbol<func::FuncOp>(
            "uvm_pkg::uvm_sequence_item::get_sequencer");
        if (getSequencerFunc) {
          SmallVector<InterpretedValue, 1> getSeqArgs;
          getSeqArgs.push_back(args[0]); // self sequence
          SmallVector<InterpretedValue, 1> getSeqResults;
          auto &cState = processStates[procId];
          ++cState.callDepth;
          auto getSeqResult = interpretFuncBody(procId, getSequencerFunc,
                                                getSeqArgs, getSeqResults,
                                                callIndirectOp);
          --cState.callDepth;
          if (succeeded(getSeqResult) && !getSeqResults.empty() &&
              !getSeqResults[0].isX()) {
            sqrAddr = getSeqResults[0].getUInt64();
            sqrArg = InterpretedValue(llvm::APInt(64, sqrAddr));
          }
        }
      }
      if (itemAddr != 0 && sqrAddr != 0) {
        recordUvmSequencerItemOwner(itemAddr, sqrAddr);
        LLVM_DEBUG(llvm::dbgs()
                   << "  call_indirect: start_item intercepted: item 0x"
                   << llvm::format_hex(itemAddr, 16) << " → sequencer 0x"
                   << llvm::format_hex(sqrAddr, 16) << "\n");
      }
      // Call set_item_context to set up the item's parent sequence and
      // sequencer references, then return (skip wait_for_grant).
      auto setContextFunc =
          moduleOp.lookupSymbol<func::FuncOp>(
              "uvm_pkg::uvm_sequence_item::set_item_context");
      if (setContextFunc && itemAddr != 0 && seqAddr != 0) {
        SmallVector<InterpretedValue, 3> ctxArgs;
        ctxArgs.push_back(args[1]); // item
        ctxArgs.push_back(args[0]); // parent sequence
        // For the sequencer arg, use sqrAddr if available, else null.
        ctxArgs.push_back(sqrArg);
        SmallVector<InterpretedValue, 1> ctxResults;
        auto &cState = processStates[procId];
        ++cState.callDepth;
        (void)interpretFuncBody(procId, setContextFunc, ctxArgs, ctxResults,
                               callIndirectOp);
        --cState.callDepth;
      }
      return success();
    }

    // finish_item: Push item to sequencer FIFO and block until the driver
    // calls item_done for this item. This implements the standard UVM
    // handshake where finish_item blocks until the driver completes.
    // Args: (self, item, priority).
    if (calleeName.contains("::finish_item") && args.size() >= 2) {
      // [SEQ-DIRECT] finish_item diagnostic removed
      uint64_t itemAddr = args[1].isX() ? 0 : args[1].getUInt64();
      if (itemAddr != 0) {
        // Check if item_done was already received (re-poll after wake)
        if (itemDoneReceived.count(itemAddr)) {
          (void)takeUvmSequencerItemOwner(itemAddr);
          itemDoneReceived.erase(itemAddr);
          finishItemWaiters.erase(itemAddr);
          LLVM_DEBUG(llvm::dbgs()
                     << "  call_indirect: finish_item completed: item 0x"
                     << llvm::format_hex(itemAddr, 16) << " got item_done\n");
          return success();
        }

        // First call (not a re-poll): push item to FIFO
        if (!finishItemWaiters.count(itemAddr)) {
          uint64_t sqrAddr = takeUvmSequencerItemOwner(itemAddr);
          sequencerItemFifo[sqrAddr].push_back(itemAddr);
          LLVM_DEBUG(llvm::dbgs()
                     << "  call_indirect: finish_item intercepted: item 0x"
                     << llvm::format_hex(itemAddr, 16) << " pushed to "
                     << "sequencer FIFO 0x"
                     << llvm::format_hex(sqrAddr, 16) << " (depth "
                     << sequencerItemFifo[sqrAddr].size() << ")\n");
          if (traceSeq) {
            llvm::errs() << "[SEQ-CI] push item=0x"
                         << llvm::format_hex(itemAddr, 16) << " sqr=0x"
                         << llvm::format_hex(sqrAddr, 16) << " depth="
                         << sequencerItemFifo[sqrAddr].size() << "\n";
          }
        }

        // Record waiter and suspend. The item_done interceptor will
        // directly resume this process when the driver completes.
        finishItemWaiters[itemAddr] = procId;
        auto &pState = processStates[procId];
        pState.waiting = true;
        pState.sequencerGetRetryCallOp = callIndirectOp.getOperation();
        LLVM_DEBUG(llvm::dbgs()
                   << "  call_indirect: finish_item blocking proc=" << procId
                   << " on item 0x" << llvm::format_hex(itemAddr, 16)
                   << "\n");
        return success();
      }
      return success();
    }

    // seq_item_pull_port/imp::get/get_next_item: Pull item from sequencer FIFO.
    // The port is connected to sequencer's seq_item_export via our
    // analysisPortConnections map. We follow the connection chain to
    // find the sequencer, then pull from its FIFO.
    // get_next_item is functionally identical to get for pull ports.
    // Args: (self_port, output_ref).
    if ((calleeName.contains("seq_item_pull_port") ||
         calleeName.contains("seq_item_pull_imp") ||
         calleeName.contains("sqr_if_base") ||
         calleeName.contains("uvm_sequencer")) &&
        (calleeName.ends_with("::get") ||
         calleeName.ends_with("::get_next_item") ||
         calleeName.ends_with("::try_next_item")) &&
        args.size() >= 2) {
      uint64_t portAddr = args[0].isX() ? 0 : args[0].getUInt64();
      bool isTryNextItem = calleeName.ends_with("::try_next_item");
      // Resolve sequencer queue once and reuse for subsequent calls on this
      // port. This avoids repeated get_comp/vtable resolution in tight loops.
      uint64_t seqrAddr = 0;
      uint64_t seqrQueueAddr = 0;
      bool usedCachedSeqrQueue = false;
      if (lookupUvmSequencerQueueCache(portAddr, seqrQueueAddr)) {
        seqrAddr = seqrQueueAddr;
        usedCachedSeqrQueue = true;
      }
      if (!usedCachedSeqrQueue) {
        // Find connected sequencer via connection map.
        auto connIt = analysisPortConnections.find(portAddr);
        if (connIt != analysisPortConnections.end() &&
            !connIt->second.empty()) {
          // The export address may have further connections, follow chain.
          // Prefer the most recent connect() target for pull ports.
          // UVM reconnect flows can update the provider at runtime.
          uint64_t exportAddr = connIt->second.back();
          // The export is on the sequencer object. We need the sequencer
          // address. Check if the export appears as a sequencer FIFO key.
          // If not, check all FIFOs for items.
          seqrAddr = exportAddr;
        }
        seqrQueueAddr = seqrAddr;
      }
      auto promoteToSequencerQueue = [&](uint64_t candidateAddr) -> uint64_t {
        if (candidateAddr == 0 || sequencerItemFifo.contains(candidateAddr))
          return candidateAddr;
        uint64_t ownerOff = 0;
        MemoryBlock *ownerBlock =
            findMemoryBlockByAddress(candidateAddr, procId, &ownerOff);
        if (!ownerBlock)
          ownerBlock = findBlockByAddress(candidateAddr, ownerOff);
        if (ownerBlock && ownerOff != 0) {
          uint64_t ownerAddr = candidateAddr - ownerOff;
          if (sequencerItemFifo.contains(ownerAddr))
            return ownerAddr;
        }
        uint64_t nativeOff = 0;
        if (findNativeMemoryBlockByAddress(candidateAddr, &nativeOff, nullptr) &&
            nativeOff != 0) {
          uint64_t ownerAddr = candidateAddr - nativeOff;
          if (sequencerItemFifo.contains(ownerAddr))
            return ownerAddr;
        }
        return candidateAddr;
      };
      if (!usedCachedSeqrQueue && seqrQueueAddr != 0 &&
          !sequencerItemFifo.contains(seqrQueueAddr)) {
        // Connection maps often point to a seq_item_export object, not the
        // owning sequencer. Resolve the owner component first.
        if (auto getCompFunc =
                moduleOp.lookupSymbol<func::FuncOp>(
                    "uvm_pkg::uvm_port_base::get_comp")) {
          SmallVector<InterpretedValue, 1> getCompArgs;
          getCompArgs.push_back(InterpretedValue(llvm::APInt(64, seqrQueueAddr)));
          SmallVector<InterpretedValue, 1> getCompResults;
          auto &cState = processStates[procId];
          ++cState.callDepth;
          auto compRes = interpretFuncBody(procId, getCompFunc, getCompArgs,
                                           getCompResults, callIndirectOp);
          --cState.callDepth;
          if (succeeded(compRes) && !getCompResults.empty() &&
              !getCompResults[0].isX())
            seqrQueueAddr =
                promoteToSequencerQueue(getCompResults[0].getUInt64());
        }

        if (!sequencerItemFifo.contains(seqrQueueAddr)) {
          // Fallback: resolve get_comp through the runtime vtable slot.
          uint64_t vtableAddr = 0;
          bool hasVtableAddr = false;
          uint64_t portOff = 0;
          MemoryBlock *portBlock =
              findMemoryBlockByAddress(seqrQueueAddr, procId, &portOff);
          if (!portBlock)
            portBlock = findBlockByAddress(seqrQueueAddr, portOff);
          if (portBlock && portBlock->initialized &&
              portOff + 12 <= portBlock->data.size()) {
            for (unsigned i = 0; i < 8; ++i)
              vtableAddr |= static_cast<uint64_t>(
                                portBlock->data[portOff + 4 + i])
                            << (i * 8);
            hasVtableAddr = true;
          }
          if (!hasVtableAddr) {
            uint64_t nativeOff = 0;
            size_t nativeSize = 0;
            if (findNativeMemoryBlockByAddress(seqrQueueAddr, &nativeOff,
                                               &nativeSize) &&
                nativeOff + 12 <= nativeSize) {
              std::memcpy(&vtableAddr,
                          reinterpret_cast<void *>(seqrQueueAddr + 4), 8);
              hasVtableAddr = true;
            }
          }
          if (hasVtableAddr) {
            auto globalIt = addressToGlobal.find(vtableAddr);
            if (globalIt != addressToGlobal.end()) {
              auto vtableBlockIt = globalMemoryBlocks.find(globalIt->second);
              if (vtableBlockIt != globalMemoryBlocks.end()) {
                auto &vtableBlock = vtableBlockIt->second;
                unsigned getCompSlot = 13;
                unsigned slotOffset = getCompSlot * 8;
                if (slotOffset + 8 <= vtableBlock.size) {
                  uint64_t getCompAddr = 0;
                  for (unsigned i = 0; i < 8; ++i)
                    getCompAddr |=
                        static_cast<uint64_t>(vtableBlock.data[slotOffset + i])
                        << (i * 8);
                  auto fnIt = addressToFunction.find(getCompAddr);
                  if (fnIt != addressToFunction.end()) {
                    if (auto getCompDyn =
                            moduleOp.lookupSymbol<func::FuncOp>(fnIt->second)) {
                      SmallVector<InterpretedValue, 1> getCompArgs2;
                      getCompArgs2.push_back(
                          InterpretedValue(llvm::APInt(64, seqrQueueAddr)));
                      SmallVector<InterpretedValue, 1> getCompResults2;
                      auto &cState = processStates[procId];
                      ++cState.callDepth;
                      auto compRes2 = interpretFuncBody(
                          procId, getCompDyn, getCompArgs2, getCompResults2,
                          callIndirectOp);
                      --cState.callDepth;
                      if (succeeded(compRes2) && !getCompResults2.empty() &&
                          !getCompResults2[0].isX())
                        seqrQueueAddr =
                            promoteToSequencerQueue(getCompResults2[0].getUInt64());
                    }
                  }
                }
              }
            }
          }
        }

        if (!sequencerItemFifo.contains(seqrQueueAddr))
          seqrQueueAddr = promoteToSequencerQueue(seqrQueueAddr);
      }

      if (seqrQueueAddr != 0 && !sequencerItemFifo.contains(seqrQueueAddr) &&
          !sequencerItemFifo.empty()) {
        uint64_t bestKey = 0;
        uint64_t bestDistance = ~uint64_t(0);
        for (auto &[key, fifo] : sequencerItemFifo) {
          uint64_t distance = key > seqrQueueAddr ? key - seqrQueueAddr
                                                  : seqrQueueAddr - key;
          if (distance < bestDistance) {
            bestDistance = distance;
            bestKey = key;
          }
        }
        if (bestKey != 0)
          seqrQueueAddr = bestKey;
      }
      cacheUvmSequencerQueueAddress(portAddr, seqrQueueAddr);
      // Try to find an item in any FIFO (prioritize matched sequencer).
      uint64_t itemAddr = 0;
      bool found = false;
      bool fromFallbackSearch = false;

      auto readObjClassId = [&](uint64_t objAddr, uint32_t &classId) -> bool {
        if (objAddr == 0)
          return false;
        uint64_t off = 0;
        MemoryBlock *objBlock = findMemoryBlockByAddress(objAddr, procId, &off);
        if (!objBlock)
          objBlock = findBlockByAddress(objAddr, off);
        if (!objBlock || !objBlock->initialized || off + 4 > objBlock->data.size())
          return false;
        classId = 0;
        for (unsigned i = 0; i < 4; ++i)
          classId |= static_cast<uint32_t>(objBlock->data[off + i]) << (i * 8);
        return true;
      };

      uint32_t expectedClassId = 0;
      bool hasExpectedClassId = false;
      uint64_t refProbeAddr = args[1].isX() ? 0 : args[1].getUInt64();
      if (refProbeAddr != 0) {
        uint64_t refOff = 0;
        MemoryBlock *refProbeBlock =
            findMemoryBlockByAddress(refProbeAddr, procId, &refOff);
        if (!refProbeBlock)
          refProbeBlock = findBlockByAddress(refProbeAddr, refOff);
        uint64_t currentObjAddr = 0;
        bool haveCurrentObjAddr = false;
        if (refProbeBlock && refProbeBlock->initialized &&
            refOff + 8 <= refProbeBlock->data.size()) {
          for (unsigned i = 0; i < 8; ++i)
            currentObjAddr |=
                static_cast<uint64_t>(refProbeBlock->data[refOff + i]) << (i * 8);
          haveCurrentObjAddr = true;
        } else {
          uint64_t nativeOffset = 0;
          size_t nativeSize = 0;
          if (findNativeMemoryBlockByAddress(refProbeAddr, &nativeOffset,
                                             &nativeSize) &&
              nativeOffset + 8 <= nativeSize) {
            std::memcpy(&currentObjAddr,
                        reinterpret_cast<void *>(refProbeAddr), 8);
            haveCurrentObjAddr = true;
          }
        }
        if (haveCurrentObjAddr && currentObjAddr != 0)
          hasExpectedClassId = readObjClassId(currentObjAddr, expectedClassId);
      }

      if (seqrQueueAddr != 0) {
        auto fifoIt = sequencerItemFifo.find(seqrQueueAddr);
        if (fifoIt != sequencerItemFifo.end() && !fifoIt->second.empty()) {
          itemAddr = fifoIt->second.front();
          fifoIt->second.pop_front();
          found = true;
        }
      }
      if (!found && hasExpectedClassId) {
        for (auto &[key, fifo] : sequencerItemFifo) {
          if (fifo.empty())
            continue;
          uint32_t classId = 0;
          if (!readObjClassId(fifo.front(), classId) ||
              classId != expectedClassId)
            continue;
          itemAddr = fifo.front();
          fifo.pop_front();
          found = true;
          fromFallbackSearch = true;
          break;
        }
      }
      if (!found) {
        // Search all FIFOs for any available item.
        for (auto &[key, fifo] : sequencerItemFifo) {
          if (!fifo.empty()) {
            itemAddr = fifo.front();
            fifo.pop_front();
            found = true;
            fromFallbackSearch = true;
            break;
          }
        }
      }
      if (found && itemAddr != 0) {
        // Track which item was dequeued by this port (for item_done)
        lastDequeuedItem[portAddr] = itemAddr;
        // Write item address to output ref (args[1]).
        // The output ref is an llhd.ref or alloca-backed ptr.
        uint64_t refAddr = args[1].isX() ? 0 : args[1].getUInt64();
        LLVM_DEBUG(llvm::dbgs()
                   << "  seq_item_pull_port::get: item found 0x"
                   << llvm::format_hex(itemAddr, 16) << " → ref 0x"
                   << llvm::format_hex(refAddr, 16) << "\n");
        if (traceSeq) {
          llvm::errs() << "[SEQ-CI] pop item=0x"
                       << llvm::format_hex(itemAddr, 16) << " port=0x"
                       << llvm::format_hex(portAddr, 16) << " seqr_hint=0x"
                       << llvm::format_hex(seqrAddr, 16)
                       << " seqr_q=0x" << llvm::format_hex(seqrQueueAddr, 16)
                       << " fallback=" << (fromFallbackSearch ? 1 : 0)
                       << "\n";
        }
        if (refAddr != 0) {
          uint64_t offset = 0;
          MemoryBlock *refBlock =
              findMemoryBlockByAddress(refAddr, procId, &offset);
          if (refBlock &&
              offset + 8 <= refBlock->data.size()) {
            for (unsigned i = 0; i < 8; ++i)
              refBlock->data[offset + i] =
                  static_cast<uint8_t>((itemAddr >> (i * 8)) & 0xFF);
            refBlock->initialized = true;
          } else {
            uint64_t nativeOffset = 0;
            size_t nativeSize = 0;
            if (findNativeMemoryBlockByAddress(refAddr, &nativeOffset,
                                               &nativeSize) &&
                nativeOffset + 8 <= nativeSize) {
              std::memcpy(reinterpret_cast<void *>(refAddr), &itemAddr, 8);
            }
          }
        }
        return success();
      }
      if (isTryNextItem) {
        uint64_t refAddr = args[1].isX() ? 0 : args[1].getUInt64();
        if (traceSeq)
          llvm::errs() << "[SEQ-CI] try_next_item miss port=0x"
                       << llvm::format_hex(portAddr, 16) << " ref=0x"
                       << llvm::format_hex(refAddr, 16) << "\n";
        if (refAddr != 0) {
          uint64_t offset = 0;
          MemoryBlock *refBlock =
              findMemoryBlockByAddress(refAddr, procId, &offset);
          if (refBlock &&
              offset + 8 <= refBlock->data.size()) {
            for (unsigned i = 0; i < 8; ++i)
              refBlock->data[offset + i] = 0;
            refBlock->initialized = true;
          } else {
            uint64_t nativeOffset = 0;
            size_t nativeSize = 0;
            if (findNativeMemoryBlockByAddress(refAddr, &nativeOffset,
                                               &nativeSize) &&
                nativeOffset + 8 <= nativeSize) {
              uint64_t nullItem = 0;
              std::memcpy(reinterpret_cast<void *>(refAddr), &nullItem, 8);
            }
          }
        }
        return success();
      }
      // If no item available, suspend the process and schedule a poll
      // to retry on the next delta. Return success() so the halt check
      // in interpretFuncBody saves call stack frames. Store the call op
      // in sequencerGetRetryCallOp so that on resume, the innermost
      // frame's resumeOp is overridden to re-execute this call_indirect
      // (instead of skipping past it).
      LLVM_DEBUG(llvm::dbgs() << "  seq_item_pull_port::get: FIFO empty, "
                              << "suspending for delta poll\n");
      auto &pState = processStates[procId];
      pState.waiting = true;
      pState.sequencerGetRetryCallOp = callIndirectOp.getOperation();
      SimTime currentTime = scheduler.getCurrentTime();
      constexpr uint32_t kMaxDeltaPolls = 1000;
      constexpr int64_t kFallbackPollDelayFs = 10000000; // 10 ps
      SimTime targetTime;
      if (currentTime.deltaStep < kMaxDeltaPolls)
        targetTime = currentTime.nextDelta();
      else
        targetTime = currentTime.advanceTime(kFallbackPollDelayFs);
      scheduler.getEventScheduler().schedule(
          targetTime, SchedulingRegion::Active,
          Event([this, procId]() {
            auto &st = processStates[procId];
            st.waiting = false;
            scheduler.scheduleProcess(procId, SchedulingRegion::Active);
          }));
      return success();
    }

    // seq_item_pull_port/imp::item_done: Signal completion of the current
    // transaction item. This unblocks the sequence's finish_item wait.
    if ((calleeName.contains("seq_item_pull_port") ||
         calleeName.contains("seq_item_pull_imp") ||
         calleeName.contains("sqr_if_base") ||
         calleeName.contains("uvm_sequencer")) &&
        calleeName.ends_with("::item_done")) {
      uint64_t portAddr =
          args.size() > 0 && !args[0].isX() ? args[0].getUInt64() : 0;
      // Find which item was last dequeued by this port
      auto lastIt = lastDequeuedItem.find(portAddr);
      if (lastIt != lastDequeuedItem.end()) {
        uint64_t itemAddr = lastIt->second;
        itemDoneReceived.insert(itemAddr);
        lastDequeuedItem.erase(lastIt);
        LLVM_DEBUG(llvm::dbgs()
                   << "  call_indirect: item_done: item 0x"
                   << llvm::format_hex(itemAddr, 16)
                   << " marked done (port 0x"
                   << llvm::format_hex(portAddr, 16) << ")\n");

        // Directly resume the process blocked in finish_item for this item.
        auto waiterIt = finishItemWaiters.find(itemAddr);
        if (waiterIt != finishItemWaiters.end()) {
          ProcessId waiterProcId = waiterIt->second;
          finishItemWaiters.erase(waiterIt);
          auto waiterStateIt = processStates.find(waiterProcId);
          if (waiterStateIt != processStates.end() &&
              waiterStateIt->second.waiting) {
            waiterStateIt->second.waiting = false;
            scheduler.scheduleProcess(waiterProcId,
                                      SchedulingRegion::Active);
            LLVM_DEBUG(llvm::dbgs()
                       << "  item_done: resuming finish_item waiter proc="
                       << waiterProcId << "\n");
          }
        }
      }
      return success();
    }

    // Check call depth to prevent stack overflow from deep recursion (UVM patterns)
    auto &callState = processStates[procId];
    constexpr size_t maxCallDepth = 200;
    if (callState.callDepth >= maxCallDepth) {
      LLVM_DEBUG(llvm::dbgs() << "  func.call_indirect: max call depth ("
                              << maxCallDepth
                              << ") exceeded, returning zero\n");
      for (Value result : callIndirectOp.getResults()) {
        unsigned width = getTypeWidth(result.getType());
        setValue(procId, result, InterpretedValue(llvm::APInt(width, 0)));
      }
      return success();
    }

    // Recursive DFS depth detection (same as func.call handler)
    Operation *indFuncKey = funcOp.getOperation();
    uint64_t indArg0Val = 0;
    bool indHasArg0 = !args.empty() && !args[0].isX();
    if (indHasArg0)
      indArg0Val = args[0].getUInt64();
    constexpr unsigned maxRecursionDepth = 20;
    auto &indDepthMap = callState.recursionVisited[indFuncKey];
    if (indHasArg0 && callState.callDepth > 0) {
      unsigned &depth = indDepthMap[indArg0Val];
      if (depth >= maxRecursionDepth) {
        LLVM_DEBUG(llvm::dbgs()
                   << "  call_indirect: recursion depth " << depth
                   << " exceeded for '" << calleeName << "' with arg0=0x"
                   << llvm::format_hex(indArg0Val, 16) << "\n");
        for (Value result : callIndirectOp.getResults()) {
          unsigned width = getTypeWidth(result.getType());
          setValue(procId, result, InterpretedValue(llvm::APInt(width, 0)));
        }
        return success();
      }
    }
    bool indAddedToVisited = indHasArg0;
    if (indHasArg0)
      ++indDepthMap[indArg0Val];

    // Intercept UVM phase/objection methods called via vtable dispatch.
    // These bypass interpretFuncCall() so we handle them here directly.
    if (calleeName.contains("uvm_phase::raise_objection") ||
        calleeName.contains("uvm_phase::drop_objection")) {
      if (!calleeName.contains("phase_hopper") && !args.empty() && !args[0].isX()) {
        uint64_t phaseAddr = args[0].getUInt64();
        InterpretedValue countVal =
            args.size() > 3 ? args[3] : InterpretedValue(llvm::APInt(32, 1));
        int64_t count = countVal.isX() ? 1 : static_cast<int64_t>(countVal.getUInt64());
        auto it2 = phaseObjectionHandles.find(phaseAddr);
        MooreObjectionHandle handle;
        if (it2 != phaseObjectionHandles.end()) {
          handle = it2->second;
        } else {
          std::string phaseName = "phase_" + std::to_string(phaseAddr);
          handle = __moore_objection_create(
              phaseName.c_str(), static_cast<int64_t>(phaseName.size()));
          phaseObjectionHandles[phaseAddr] = handle;
        }
        if (calleeName.contains("raise_objection")) {
          raisePhaseObjection(handle, count);
        } else {
          dropPhaseObjection(handle, count);
        }
      }
      if (indAddedToVisited) {
        auto &depthRef = processStates[procId].recursionVisited[indFuncKey][indArg0Val];
        if (depthRef > 0)
          --depthRef;
      }
      return success();
    }

    // Call the function with depth tracking
    ++callState.callDepth;
    SmallVector<InterpretedValue, 2> results;
    // Pass the call operation so it can be saved in call stack frames
    LogicalResult funcResult =
        interpretFuncBody(procId, funcOp, args, results, callIndirectOp);
    --callState.callDepth;

    // Decrement depth counter after returning
    if (indAddedToVisited) {
      auto &depthRef = processStates[procId].recursionVisited[indFuncKey][indArg0Val];
      if (depthRef > 0)
        --depthRef;
    }

    if (failed(funcResult)) {
      // Check if the failure was actually a suspension that we should propagate
      // rather than swallow. When a virtual method call causes the process to
      // suspend (e.g., wait_for_state inside sync_phase called from
      // process_phase), interpretFuncBody returns success() with
      // state.waiting=true. But if the function body reached a point that
      // returns failure() (e.g., the while-loop fallthrough at the end of
      // interpretFuncBody), AND the process is actually in waiting state,
      // it means the suspension was set but the function body loop exited
      // without returning success(). In this case, the suspension is valid
      // and we should propagate it, not treat it as an error.
      auto &suspState = processStates[procId];
      if (suspState.waiting) {
        // The function suspended -- this is not an error. Propagate the
        // suspension so the caller can save a call stack frame.
        // callDepth was already decremented above (line after interpretFuncBody).
        if (indAddedToVisited) {
          auto &depthRef = processStates[procId].recursionVisited[indFuncKey][indArg0Val];
          if (depthRef > 0)
            --depthRef;
        }
        LLVM_DEBUG(llvm::dbgs() << "  call_indirect: '" << calleeName
                                << "' returned failure but process is waiting"
                                << " -- treating as suspension\n");
        return success();
      }
      // Don't propagate internal failures from virtual method calls.
      // During UVM phase traversal, individual component methods may fail
      // (e.g., unimplemented sequencer interfaces, missing config_db entries).
      // Propagating the failure would cascade through the recursive
      // traverse_on -> traverse -> traverse_on chain, halting all phase
      // processing.  Instead, absorb the failure, log a warning, and
      // return zero results so the traversal can continue to the next
      // component.
      // Suppress the warning when the failure is from abort/timeout —
      // the abort itself is the expected message.
      if (!isAbortRequested())
        emitVtableWarning("dispatched function '" + calleeName.str() +
                          "' failed internally");
      for (Value result : callIndirectOp.getResults()) {
        unsigned width = getTypeWidth(result.getType());
        setValue(procId, result, InterpretedValue(llvm::APInt(width, 0)));
      }
      // Decrement depth counter since we're returning early
      if (indAddedToVisited) {
        auto &depthRef =
            processStates[procId].recursionVisited[indFuncKey][indArg0Val];
        if (depthRef > 0)
          --depthRef;
      }
      return success();
    }

    // Check if process suspended during function execution (e.g., due to wait)
    // If so, return early without setting results - the function didn't complete
    auto &postCallState = processStates[procId];
    if (postCallState.waiting) {
      LLVM_DEBUG(llvm::dbgs() << "  call_indirect: process suspended during call to '"
                              << calleeName << "'\n");
      return success();
    }

    // Set results
    for (auto [result, retVal] : llvm::zip(callIndirectOp.getResults(), results)) {
      setValue(procId, result, retVal);
    }

    return success();
  }

  if (auto returnOp = dyn_cast<mlir::func::ReturnOp>(op)) {
    // Return is handled by the call interpreter
    return success();
  }

  //===--------------------------------------------------------------------===//
  // HW Array Operations
  //===--------------------------------------------------------------------===//

  if (auto arrayCreateOp = dyn_cast<hw::ArrayCreateOp>(op)) {
    // Create an array from the input values
    // For interpretation, we pack all elements into a single APInt
    auto arrayType = hw::type_cast<hw::ArrayType>(arrayCreateOp.getType());
    unsigned elementWidth = getTypeWidth(arrayType.getElementType());
    unsigned numElements = arrayType.getNumElements();
    unsigned totalWidth = elementWidth * numElements;

    APInt result(totalWidth, 0);
    bool hasX = false;

    // Elements are stored in reverse order (index 0 at the LSB)
    for (size_t i = 0; i < numElements; ++i) {
      InterpretedValue elem = getValue(procId, arrayCreateOp.getInputs()[i]);
      APInt elemVal(elementWidth, 0);
      if (elem.isX()) {
        if (auto encoded = getEncodedUnknownForType(arrayType.getElementType())) {
          elemVal = encoded->zextOrTrunc(elementWidth);
        } else {
          hasX = true;
          break;
        }
      } else {
        elemVal = elem.getAPInt();
      }
      if (elemVal.getBitWidth() < elementWidth)
        elemVal = elemVal.zext(elementWidth);
      else if (elemVal.getBitWidth() > elementWidth)
        elemVal = elemVal.trunc(elementWidth);
      // Insert element at position (numElements - 1 - i) * elementWidth
      // to maintain proper array ordering
      unsigned offset = (numElements - 1 - i) * elementWidth;
      safeInsertBits(result,elemVal, offset);
    }

    if (hasX) {
      setValue(procId, arrayCreateOp.getResult(),
               InterpretedValue::makeX(totalWidth));
    } else {
      setValue(procId, arrayCreateOp.getResult(), InterpretedValue(result));
    }
    return success();
  }

  if (auto arrayGetOp = dyn_cast<hw::ArrayGetOp>(op)) {
    InterpretedValue arrayVal = getValue(procId, arrayGetOp.getInput());
    InterpretedValue indexVal = getValue(procId, arrayGetOp.getIndex());

    if (indexVal.isX()) {
      setValue(procId, arrayGetOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(arrayGetOp.getType())));
      return success();
    }

    auto arrayType = cast<hw::ArrayType>(arrayGetOp.getInput().getType());
    unsigned elementWidth = getTypeWidth(arrayType.getElementType());
    unsigned numElements = arrayType.getNumElements();
    uint64_t idx = indexVal.getAPInt().getZExtValue();

    if (idx >= numElements) {
      // Out of bounds - return X
      setValue(procId, arrayGetOp.getResult(),
               InterpretedValue::makeX(elementWidth));
      return success();
    }

    if (arrayVal.isX()) {
      if (auto encoded = getEncodedUnknownForType(arrayType.getElementType())) {
        setValue(procId, arrayGetOp.getResult(),
                 InterpretedValue(encoded->zextOrTrunc(elementWidth)));
      } else {
        setValue(procId, arrayGetOp.getResult(),
                 InterpretedValue::makeX(elementWidth));
      }
      return success();
    }

    // Array element 0 is at LSB (offset 0), matching CIRCT hw dialect convention.
    unsigned offset = idx * elementWidth;
    APInt element = arrayVal.getAPInt().extractBits(elementWidth, offset);
    setValue(procId, arrayGetOp.getResult(), InterpretedValue(element));
    return success();
  }

  if (auto arraySliceOp = dyn_cast<hw::ArraySliceOp>(op)) {
    InterpretedValue arrayVal = getValue(procId, arraySliceOp.getInput());
    InterpretedValue indexVal = getValue(procId, arraySliceOp.getLowIndex());

    auto resultType = hw::type_cast<hw::ArrayType>(arraySliceOp.getType());
    if (arrayVal.isX() || indexVal.isX()) {
      unsigned resultWidth = getTypeWidth(resultType.getElementType()) *
                             resultType.getNumElements();
      setValue(procId, arraySliceOp.getResult(),
               InterpretedValue::makeX(resultWidth));
      return success();
    }

    auto inputType = hw::type_cast<hw::ArrayType>(arraySliceOp.getInput().getType());
    unsigned elementWidth = getTypeWidth(inputType.getElementType());
    unsigned inputElements = inputType.getNumElements();
    unsigned resultElements = resultType.getNumElements();
    uint64_t lowIdx = indexVal.getAPInt().getZExtValue();

    if (lowIdx + resultElements > inputElements) {
      // Out of bounds
      unsigned resultWidth = elementWidth * resultElements;
      setValue(procId, arraySliceOp.getResult(),
               InterpretedValue::makeX(resultWidth));
      return success();
    }

    // Array element 0 is at LSB (offset 0), matching CIRCT hw dialect convention.
    unsigned offset = lowIdx * elementWidth;
    unsigned sliceWidth = resultElements * elementWidth;
    APInt slice = arrayVal.getAPInt().extractBits(sliceWidth, offset);
    setValue(procId, arraySliceOp.getResult(), InterpretedValue(slice));
    return success();
  }

  if (auto arrayConcatOp = dyn_cast<hw::ArrayConcatOp>(op)) {
    auto resultType = hw::type_cast<hw::ArrayType>(arrayConcatOp.getType());
    unsigned resultWidth = getTypeWidth(resultType.getElementType()) *
                           resultType.getNumElements();

    APInt result(resultWidth, 0);
    bool hasX = false;
    unsigned bitOffset = resultWidth;

    for (Value input : arrayConcatOp.getInputs()) {
      InterpretedValue val = getValue(procId, input);
      if (val.isX()) {
        hasX = true;
        break;
      }
      unsigned inputWidth = val.getWidth();
      bitOffset -= inputWidth;
      safeInsertBits(result,val.getAPInt(), bitOffset);
    }

    if (hasX) {
      setValue(procId, arrayConcatOp.getResult(),
               InterpretedValue::makeX(resultWidth));
    } else {
      setValue(procId, arrayConcatOp.getResult(), InterpretedValue(result));
    }
    return success();
  }

  //===--------------------------------------------------------------------===//
  // HW Struct Operations
  //===--------------------------------------------------------------------===//

  if (auto structExtractOp = dyn_cast<hw::StructExtractOp>(op)) {
    InterpretedValue structVal = getValue(procId, structExtractOp.getInput());
    if (structVal.isX()) {
      if (auto encoded = getEncodedUnknownForType(structExtractOp.getType())) {
        setValue(procId, structExtractOp.getResult(),
                 InterpretedValue(*encoded));
      } else {
        setValue(procId, structExtractOp.getResult(),
                 InterpretedValue::makeX(getTypeWidth(structExtractOp.getType())));
      }
      return success();
    }

    // Get the struct type and field info
    auto structType = cast<hw::StructType>(structExtractOp.getInput().getType());
    auto elements = structType.getElements();
    uint32_t fieldIndex = structExtractOp.getFieldIndex();

    // Calculate the bit offset for the field
    // Fields are laid out from high bits to low bits in order
    unsigned fieldOffset = 0;
    for (size_t i = fieldIndex + 1; i < elements.size(); ++i) {
      fieldOffset += getTypeWidth(elements[i].type);
    }

    unsigned fieldWidth = getTypeWidth(elements[fieldIndex].type);
    APInt fieldValue = structVal.getAPInt().extractBits(fieldWidth, fieldOffset);
    setValue(procId, structExtractOp.getResult(), InterpretedValue(fieldValue));
    return success();
  }

  if (auto structCreateOp = dyn_cast<hw::StructCreateOp>(op)) {
    auto structType = cast<hw::StructType>(structCreateOp.getType());
    unsigned totalWidth = getTypeWidth(structType);

    APInt result(totalWidth, 0);
    bool hasX = false;
    auto elements = structType.getElements();
    unsigned bitOffset = totalWidth;

    for (size_t i = 0; i < structCreateOp.getInput().size(); ++i) {
      InterpretedValue val = getValue(procId, structCreateOp.getInput()[i]);
      unsigned fieldWidth = getTypeWidth(elements[i].type);
      bitOffset -= fieldWidth;
      if (val.isX()) {
        if (auto encoded = getEncodedUnknownForType(elements[i].type)) {
          safeInsertBits(result,encoded->zextOrTrunc(fieldWidth), bitOffset);
          continue;
        }
        hasX = true;
        break;
      }
      safeInsertBits(result,val.getAPInt(), bitOffset);
    }

    if (hasX) {
      setValue(procId, structCreateOp.getResult(),
               InterpretedValue::makeX(totalWidth));
    } else {
      setValue(procId, structCreateOp.getResult(), InterpretedValue(result));
    }
    return success();
  }

  if (auto structInjectOp = dyn_cast<hw::StructInjectOp>(op)) {
    InterpretedValue structVal = getValue(procId, structInjectOp.getInput());
    InterpretedValue newVal = getValue(procId, structInjectOp.getNewValue());
    auto structType = cast<hw::StructType>(structInjectOp.getInput().getType());
    unsigned totalWidth = getTypeWidth(structType);
    if (structVal.isX() || newVal.isX()) {
      setValue(procId, structInjectOp.getResult(),
               InterpretedValue::makeX(totalWidth));
      return success();
    }

    auto fieldIndexOpt = structType.getFieldIndex(structInjectOp.getFieldName());
    if (!fieldIndexOpt) {
      setValue(procId, structInjectOp.getResult(),
               InterpretedValue::makeX(totalWidth));
      return success();
    }
    unsigned fieldIndex = *fieldIndexOpt;
    auto elements = structType.getElements();

    unsigned fieldOffset = 0;
    for (size_t i = fieldIndex + 1; i < elements.size(); ++i)
      fieldOffset += getTypeWidth(elements[i].type);

    unsigned fieldWidth = getTypeWidth(elements[fieldIndex].type);
    APInt result = structVal.getAPInt();
    APInt fieldValue = newVal.getAPInt();
    if (fieldValue.getBitWidth() < fieldWidth)
      fieldValue = fieldValue.zext(fieldWidth);
    else if (fieldValue.getBitWidth() > fieldWidth)
      fieldValue = fieldValue.trunc(fieldWidth);
    safeInsertBits(result,fieldValue, fieldOffset);

    setValue(procId, structInjectOp.getResult(), InterpretedValue(result));
    return success();
  }

  if (op->getName().getStringRef() == "hw.struct_inject") {
    Value input = op->getOperand(0);
    Value newValue = op->getOperand(1);
    auto structType = cast<hw::StructType>(input.getType());
    unsigned totalWidth = getTypeWidth(structType);
    auto fieldIndexAttr = op->getAttrOfType<IntegerAttr>("fieldIndex");
    if (!fieldIndexAttr) {
      for (Value result : op->getResults())
        setValue(procId, result, InterpretedValue::makeX(totalWidth));
      return success();
    }
    unsigned fieldIndex = fieldIndexAttr.getValue().getZExtValue();
    auto elements = structType.getElements();
    InterpretedValue structVal = getValue(procId, input);
    InterpretedValue newVal = getValue(procId, newValue);
    if (structVal.isX() || newVal.isX()) {
      for (Value result : op->getResults())
        setValue(procId, result, InterpretedValue::makeX(totalWidth));
      return success();
    }

    unsigned fieldOffset = 0;
    for (size_t i = fieldIndex + 1; i < elements.size(); ++i)
      fieldOffset += getTypeWidth(elements[i].type);
    unsigned fieldWidth = getTypeWidth(elements[fieldIndex].type);
    APInt result = structVal.getAPInt();
    APInt fieldValue = newVal.getAPInt();
    if (fieldValue.getBitWidth() < fieldWidth)
      fieldValue = fieldValue.zext(fieldWidth);
    else if (fieldValue.getBitWidth() > fieldWidth)
      fieldValue = fieldValue.trunc(fieldWidth);
    safeInsertBits(result,fieldValue, fieldOffset);

    for (Value resultVal : op->getResults())
      setValue(procId, resultVal, InterpretedValue(result));
    return success();
  }

  if (auto aggConstOp = dyn_cast<hw::AggregateConstantOp>(op)) {
    APInt value = flattenAggregateConstant(aggConstOp);
    setValue(procId, aggConstOp.getResult(), InterpretedValue(value));
    return success();
  }

  if (auto bitcastOp = dyn_cast<hw::BitcastOp>(op)) {
    InterpretedValue inputVal = getValue(procId, bitcastOp.getInput());
    unsigned outputWidth = getTypeWidth(bitcastOp.getType());
    if (inputVal.isX()) {
      setValue(procId, bitcastOp.getResult(),
               InterpretedValue::makeX(outputWidth));
    } else {
      APInt srcBits = inputVal.getAPInt();

      // Check for 4-state bitcast: {value: iN, unknown: iN} -> nested
      // per-field {value: iM, unknown: iM} struct.  These two layouts store
      // 4-state bits in fundamentally different orders, so a raw bit
      // reinterpretation is wrong -- we must redistribute value/unknown bits
      // to per-field pairs.
      auto srcStructType =
          dyn_cast<hw::StructType>(bitcastOp.getInput().getType());
      auto destStructType = dyn_cast<hw::StructType>(bitcastOp.getType());

      // Helper: detect a flat 4-state leaf {value: iN, unknown: iN}.
      auto isFlatFourState = [](hw::StructType ty) -> bool {
        auto elts = ty.getElements();
        if (elts.size() != 2)
          return false;
        if (elts[0].name.getValue() != "value" ||
            elts[1].name.getValue() != "unknown")
          return false;
        auto valTy = dyn_cast<IntegerType>(elts[0].type);
        auto unkTy = dyn_cast<IntegerType>(elts[1].type);
        return valTy && unkTy && valTy.getWidth() == unkTy.getWidth();
      };

      // Helper: detect a nested 4-state struct (all leaves are {value, unknown}).
      std::function<bool(Type)> isNestedFourState = [&](Type ty) -> bool {
        auto st = dyn_cast<hw::StructType>(ty);
        if (!st)
          return false;
        if (isFlatFourState(st))
          return true;
        for (auto &elt : st.getElements())
          if (!isNestedFourState(elt.type))
            return false;
        return true;
      };

      // Helper: recursively redistribute flat value/unknown bits into the
      // per-field interleaved layout of the destination struct.
      std::function<APInt(const APInt &, const APInt &, hw::StructType)>
          interleaveBits = [&](const APInt &val, const APInt &unk,
                               hw::StructType destTy) -> APInt {
        auto elts = destTy.getElements();

        // Leaf: {value: iN, unknown: iN}
        if (isFlatFourState(destTy)) {
          unsigned N = cast<IntegerType>(elts[0].type).getWidth();
          APInt res(N * 2, 0);
          // HW struct: field 0 (value) at MSB, field 1 (unknown) at LSB
          safeInsertBits(res,val.zextOrTrunc(N), N);
          safeInsertBits(res,unk.zextOrTrunc(N), 0);
          return res;
        }

        // Non-leaf: recursively process each field.
        unsigned totalDestWidth = getTypeWidth(destTy);
        APInt res(totalDestWidth, 0);
        unsigned origOff = 0; // offset in flat value/unknown (from LSB)
        unsigned destOff = 0; // offset in output (from LSB)

        // HW struct: fields ordered MSB to LSB, so iterate in reverse.
        for (int i = (int)elts.size() - 1; i >= 0; --i) {
          unsigned destFieldW = getTypeWidth(elts[i].type);
          unsigned origFieldW = destFieldW / 2;
          APInt fv = val.extractBits(origFieldW, origOff);
          APInt fu = unk.extractBits(origFieldW, origOff);
          auto nested = cast<hw::StructType>(elts[i].type);
          safeInsertBits(res,interleaveBits(fv, fu, nested), destOff);
          origOff += origFieldW;
          destOff += destFieldW;
        }
        return res;
      };

      if (srcStructType && destStructType && isFlatFourState(srcStructType) &&
          isNestedFourState(destStructType) &&
          !isFlatFourState(destStructType)) {
        unsigned halfWidth =
            cast<IntegerType>(srcStructType.getElements()[0].type).getWidth();
        if (srcBits.getBitWidth() < halfWidth * 2)
          srcBits = srcBits.zext(halfWidth * 2);
        APInt valueHalf = srcBits.extractBits(halfWidth, halfWidth);
        APInt unknownHalf = srcBits.extractBits(halfWidth, 0);
        APInt result =
            interleaveBits(valueHalf, unknownHalf, destStructType);
        setValue(procId, bitcastOp.getResult(), InterpretedValue(result));
      } else {
        // Normal bitcast: preserve raw bits.
        APInt result = srcBits;
        if (result.getBitWidth() < outputWidth)
          result = result.zext(outputWidth);
        else if (result.getBitWidth() > outputWidth)
          result = result.trunc(outputWidth);
        setValue(procId, bitcastOp.getResult(), InterpretedValue(result));
      }
    }
    return success();
  }

  //===--------------------------------------------------------------------===//
  // LLHD Time Operations
  //===--------------------------------------------------------------------===//

  if (auto currentTimeOp = dyn_cast<llhd::CurrentTimeOp>(op)) {
    // Return the current simulation time
    SimTime currentTime = scheduler.getCurrentTime();
    setValue(procId, currentTimeOp.getResult(),
             InterpretedValue(currentTime.realTime, 64));
    return success();
  }

  if (auto timeToIntOp = dyn_cast<llhd::TimeToIntOp>(op)) {
    // Convert time to integer femtoseconds
    if (auto constTimeOp =
            timeToIntOp.getInput().getDefiningOp<llhd::ConstantTimeOp>()) {
      SimTime time = convertTime(constTimeOp.getValueAttr());
      setValue(procId, timeToIntOp.getResult(),
               InterpretedValue(time.realTime, 64));
    } else {
      InterpretedValue input = getValue(procId, timeToIntOp.getInput());
      setValue(procId, timeToIntOp.getResult(), input);
    }
    return success();
  }

  if (auto intToTimeOp = dyn_cast<llhd::IntToTimeOp>(op)) {
    // Convert integer femtoseconds to time
    InterpretedValue input = getValue(procId, intToTimeOp.getInput());
    setValue(procId, intToTimeOp.getResult(), input);
    return success();
  }

  //===--------------------------------------------------------------------===//
  // LLVM Dialect Operations
  //===--------------------------------------------------------------------===//
llvm_dispatch:
  // LLVM constant operation (llvm.mlir.constant)
  if (auto llvmConstOp = dyn_cast<LLVM::ConstantOp>(op)) {
    if (auto intAttr = dyn_cast<IntegerAttr>(llvmConstOp.getValue())) {
      setValue(procId, llvmConstOp.getResult(),
               InterpretedValue(intAttr.getValue()));
    } else {
      // For non-integer constants, create an X value
      setValue(procId, llvmConstOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(llvmConstOp.getType())));
    }
    return success();
  }

  if (auto allocaOp = dyn_cast<LLVM::AllocaOp>(op))
    return interpretLLVMAlloca(procId, allocaOp);

  if (auto loadOp = dyn_cast<LLVM::LoadOp>(op))
    return interpretLLVMLoad(procId, loadOp);

  if (auto storeOp = dyn_cast<LLVM::StoreOp>(op))
    return interpretLLVMStore(procId, storeOp);

  if (auto gepOp = dyn_cast<LLVM::GEPOp>(op))
    return interpretLLVMGEP(procId, gepOp);

  if (auto addrOfOp = dyn_cast<LLVM::AddressOfOp>(op))
    return interpretLLVMAddressOf(procId, addrOfOp);

  if (auto llvmCallOp = dyn_cast<LLVM::CallOp>(op))
    return interpretLLVMCall(procId, llvmCallOp);

  // LLVM return op is handled by call interpreter
  if (isa<LLVM::ReturnOp>(op))
    return success();

  // LLVM unreachable indicates control should not reach here (e.g., after $finish)
  // Halt the process when this is reached
  if (isa<LLVM::UnreachableOp>(op)) {
    LLVM_DEBUG(llvm::dbgs() << "  llvm.unreachable reached - halting process\n");
    // When executing inside a phase function, llvm.unreachable follows an
    // absorbed sim.terminate (die() → $finish pattern). Treat it as a void
    // return so the phase can complete normally. The unreachable was generated
    // because the compiler assumed $finish never returns.
    {
      auto phaseIt = currentExecutingPhaseAddr.find(procId);
      if (phaseIt != currentExecutingPhaseAddr.end()) {
        auto &ps = processStates[procId];
        if (ps.callDepth > 0) {
          LLVM_DEBUG(llvm::dbgs()
                     << "  llvm.unreachable absorbed during phase execution"
                     << " (callDepth=" << ps.callDepth << ")\n");
          // Don't finalize — treat as void return so die() returns to its
          // caller (the report handler), and phase traversal can continue.
          return success();
        }
      }
    }
    finalizeProcess(procId, /*killed=*/false);
    return success();
  }

  // LLVM undef creates an undefined value
  if (auto undefOp = dyn_cast<LLVM::UndefOp>(op)) {
    setValue(procId, undefOp.getResult(),
             InterpretedValue::makeX(getTypeWidth(undefOp.getType())));
    return success();
  }

  // LLVM null pointer constant
  if (auto nullOp = dyn_cast<LLVM::ZeroOp>(op)) {
    setValue(procId, nullOp.getResult(), InterpretedValue(0, 64));
    return success();
  }

  // LLVM inttoptr
  if (auto intToPtrOp = dyn_cast<LLVM::IntToPtrOp>(op)) {
    InterpretedValue input = getValue(procId, intToPtrOp.getArg());
    setValue(procId, intToPtrOp.getResult(), input);
    return success();
  }

  // LLVM ptrtoint
  if (auto ptrToIntOp = dyn_cast<LLVM::PtrToIntOp>(op)) {
    InterpretedValue input = getValue(procId, ptrToIntOp.getArg());
    unsigned width = getTypeWidth(ptrToIntOp.getType());
    if (input.isX()) {
      setValue(procId, ptrToIntOp.getResult(), InterpretedValue::makeX(width));
    } else {
      APInt val = input.getAPInt();
      if (val.getBitWidth() < width)
        val = val.zext(width);
      else if (val.getBitWidth() > width)
        val = val.trunc(width);
      setValue(procId, ptrToIntOp.getResult(), InterpretedValue(val));
    }
    return success();
  }

  // LLVM bitcast
  if (auto bitcastOp = dyn_cast<LLVM::BitcastOp>(op)) {
    InterpretedValue input = getValue(procId, bitcastOp.getArg());
    setValue(procId, bitcastOp.getResult(), input);
    return success();
  }

  // LLVM trunc
  if (auto truncOp = dyn_cast<LLVM::TruncOp>(op)) {
    InterpretedValue input = getValue(procId, truncOp.getArg());
    unsigned width = getTypeWidth(truncOp.getType());
    if (input.isX()) {
      setValue(procId, truncOp.getResult(), InterpretedValue::makeX(width));
    } else {
      setValue(procId, truncOp.getResult(),
               InterpretedValue(input.getAPInt().trunc(width)));
    }
    return success();
  }

  // LLVM zext
  if (auto zextOp = dyn_cast<LLVM::ZExtOp>(op)) {
    InterpretedValue input = getValue(procId, zextOp.getArg());
    unsigned width = getTypeWidth(zextOp.getType());
    if (input.isX()) {
      setValue(procId, zextOp.getResult(), InterpretedValue::makeX(width));
    } else {
      setValue(procId, zextOp.getResult(),
               InterpretedValue(input.getAPInt().zext(width)));
    }
    return success();
  }

  // LLVM sext
  if (auto sextOp = dyn_cast<LLVM::SExtOp>(op)) {
    InterpretedValue input = getValue(procId, sextOp.getArg());
    unsigned width = getTypeWidth(sextOp.getType());
    if (input.isX()) {
      setValue(procId, sextOp.getResult(), InterpretedValue::makeX(width));
    } else {
      setValue(procId, sextOp.getResult(),
               InterpretedValue(input.getAPInt().sext(width)));
    }
    return success();
  }

  // LLVM add
  if (auto addOp = dyn_cast<LLVM::AddOp>(op)) {
    InterpretedValue lhs = getValue(procId, addOp.getLhs());
    InterpretedValue rhs = getValue(procId, addOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, addOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(addOp.getType())));
    } else {
      setValue(procId, addOp.getResult(),
               InterpretedValue(lhs.getAPInt() + rhs.getAPInt()));
    }
    return success();
  }

  // LLVM sub
  if (auto subOp = dyn_cast<LLVM::SubOp>(op)) {
    InterpretedValue lhs = getValue(procId, subOp.getLhs());
    InterpretedValue rhs = getValue(procId, subOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, subOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(subOp.getType())));
    } else {
      setValue(procId, subOp.getResult(),
               InterpretedValue(lhs.getAPInt() - rhs.getAPInt()));
    }
    return success();
  }

  // LLVM mul
  if (auto mulOp = dyn_cast<LLVM::MulOp>(op)) {
    InterpretedValue lhs = getValue(procId, mulOp.getLhs());
    InterpretedValue rhs = getValue(procId, mulOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, mulOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(mulOp.getType())));
    } else {
      setValue(procId, mulOp.getResult(),
               InterpretedValue(lhs.getAPInt() * rhs.getAPInt()));
    }
    return success();
  }

  // LLVM icmp
  if (auto icmpOp = dyn_cast<LLVM::ICmpOp>(op)) {
    InterpretedValue lhs = getValue(procId, icmpOp.getLhs());
    InterpretedValue rhs = getValue(procId, icmpOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, icmpOp.getResult(), InterpretedValue::makeX(1));
      return success();
    }
    bool result = false;
    const APInt &lhsVal = lhs.getAPInt();
    const APInt &rhsVal = rhs.getAPInt();
    switch (icmpOp.getPredicate()) {
    case LLVM::ICmpPredicate::eq:
      result = lhsVal == rhsVal;
      break;
    case LLVM::ICmpPredicate::ne:
      result = lhsVal != rhsVal;
      break;
    case LLVM::ICmpPredicate::slt:
      result = lhsVal.slt(rhsVal);
      break;
    case LLVM::ICmpPredicate::sle:
      result = lhsVal.sle(rhsVal);
      break;
    case LLVM::ICmpPredicate::sgt:
      result = lhsVal.sgt(rhsVal);
      break;
    case LLVM::ICmpPredicate::sge:
      result = lhsVal.sge(rhsVal);
      break;
    case LLVM::ICmpPredicate::ult:
      result = lhsVal.ult(rhsVal);
      break;
    case LLVM::ICmpPredicate::ule:
      result = lhsVal.ule(rhsVal);
      break;
    case LLVM::ICmpPredicate::ugt:
      result = lhsVal.ugt(rhsVal);
      break;
    case LLVM::ICmpPredicate::uge:
      result = lhsVal.uge(rhsVal);
      break;
    }
    setValue(procId, icmpOp.getResult(), InterpretedValue(result ? 1 : 0, 1));
    return success();
  }

  // LLVM and
  if (auto andOp = dyn_cast<LLVM::AndOp>(op)) {
    InterpretedValue lhs = getValue(procId, andOp.getLhs());
    InterpretedValue rhs = getValue(procId, andOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, andOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(andOp.getType())));
    } else {
      setValue(procId, andOp.getResult(),
               InterpretedValue(lhs.getAPInt() & rhs.getAPInt()));
    }
    return success();
  }

  // LLVM or
  if (auto orOp = dyn_cast<LLVM::OrOp>(op)) {
    InterpretedValue lhs = getValue(procId, orOp.getLhs());
    InterpretedValue rhs = getValue(procId, orOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, orOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(orOp.getType())));
    } else {
      setValue(procId, orOp.getResult(),
               InterpretedValue(lhs.getAPInt() | rhs.getAPInt()));
    }
    return success();
  }

  // LLVM xor
  if (auto xorOp = dyn_cast<LLVM::XOrOp>(op)) {
    InterpretedValue lhs = getValue(procId, xorOp.getLhs());
    InterpretedValue rhs = getValue(procId, xorOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, xorOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(xorOp.getType())));
    } else {
      setValue(procId, xorOp.getResult(),
               InterpretedValue(lhs.getAPInt() ^ rhs.getAPInt()));
    }
    return success();
  }

  // LLVM shl
  if (auto shlOp = dyn_cast<LLVM::ShlOp>(op)) {
    InterpretedValue lhs = getValue(procId, shlOp.getLhs());
    InterpretedValue rhs = getValue(procId, shlOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, shlOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(shlOp.getType())));
    } else {
      uint64_t shift = rhs.getAPInt().getLimitedValue();
      unsigned bitWidth = lhs.getAPInt().getBitWidth();
      if (shift >= bitWidth) {
        setValue(procId, shlOp.getResult(),
                 InterpretedValue(APInt::getZero(bitWidth)));
      } else {
        setValue(procId, shlOp.getResult(),
                 InterpretedValue(lhs.getAPInt().shl(shift)));
      }
    }
    return success();
  }

  // LLVM lshr
  if (auto lshrOp = dyn_cast<LLVM::LShrOp>(op)) {
    InterpretedValue lhs = getValue(procId, lshrOp.getLhs());
    InterpretedValue rhs = getValue(procId, lshrOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, lshrOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(lshrOp.getType())));
    } else {
      uint64_t shift = rhs.getAPInt().getLimitedValue();
      unsigned bitWidth = lhs.getAPInt().getBitWidth();
      if (shift >= bitWidth) {
        setValue(procId, lshrOp.getResult(),
                 InterpretedValue(APInt::getZero(bitWidth)));
      } else {
        setValue(procId, lshrOp.getResult(),
                 InterpretedValue(lhs.getAPInt().lshr(shift)));
      }
    }
    return success();
  }

  // LLVM ashr
  if (auto ashrOp = dyn_cast<LLVM::AShrOp>(op)) {
    InterpretedValue lhs = getValue(procId, ashrOp.getLhs());
    InterpretedValue rhs = getValue(procId, ashrOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, ashrOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(ashrOp.getType())));
    } else {
      uint64_t shift = rhs.getAPInt().getLimitedValue();
      unsigned bitWidth = lhs.getAPInt().getBitWidth();
      if (shift >= bitWidth) {
        setValue(procId, ashrOp.getResult(),
                 InterpretedValue(
                     lhs.getAPInt().isNegative()
                         ? APInt::getAllOnes(bitWidth)
                         : APInt::getZero(bitWidth)));
      } else {
        setValue(procId, ashrOp.getResult(),
                 InterpretedValue(lhs.getAPInt().ashr(shift)));
      }
    }
    return success();
  }

  // LLVM select - conditional value selection
  if (auto selectOp = dyn_cast<LLVM::SelectOp>(op)) {
    InterpretedValue cond = getValue(procId, selectOp.getCondition());
    unsigned width = getTypeWidth(selectOp.getType());
    if (cond.isX()) {
      // X condition propagates to X result
      setValue(procId, selectOp.getResult(), InterpretedValue::makeX(width));
    } else {
      bool condVal = cond.getUInt64() != 0;
      InterpretedValue selected =
          condVal ? getValue(procId, selectOp.getTrueValue())
                  : getValue(procId, selectOp.getFalseValue());
      setValue(procId, selectOp.getResult(), selected);
    }
    return success();
  }

  // LLVM freeze - freeze undefined values to a deterministic value
  if (auto freezeOp = dyn_cast<LLVM::FreezeOp>(op)) {
    InterpretedValue input = getValue(procId, freezeOp.getVal());
    unsigned width = getTypeWidth(freezeOp.getType());
    if (input.isX()) {
      // Freeze X to 0 (a deterministic but arbitrary value)
      setValue(procId, freezeOp.getResult(), InterpretedValue(0, width));
    } else {
      // Pass through known values
      setValue(procId, freezeOp.getResult(), input);
    }
    return success();
  }

  // LLVM sdiv - signed integer division
  if (auto sdivOp = dyn_cast<LLVM::SDivOp>(op)) {
    InterpretedValue lhs = getValue(procId, sdivOp.getLhs());
    InterpretedValue rhs = getValue(procId, sdivOp.getRhs());
    unsigned width = getTypeWidth(sdivOp.getType());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, sdivOp.getResult(), InterpretedValue::makeX(width));
    } else if (rhs.getAPInt().isZero()) {
      // Division by zero returns X
      setValue(procId, sdivOp.getResult(), InterpretedValue::makeX(width));
    } else {
      setValue(procId, sdivOp.getResult(),
               InterpretedValue(lhs.getAPInt().sdiv(rhs.getAPInt())));
    }
    return success();
  }

  // LLVM udiv - unsigned integer division
  if (auto udivOp = dyn_cast<LLVM::UDivOp>(op)) {
    InterpretedValue lhs = getValue(procId, udivOp.getLhs());
    InterpretedValue rhs = getValue(procId, udivOp.getRhs());
    unsigned width = getTypeWidth(udivOp.getType());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, udivOp.getResult(), InterpretedValue::makeX(width));
    } else if (rhs.getAPInt().isZero()) {
      // Division by zero returns X
      setValue(procId, udivOp.getResult(), InterpretedValue::makeX(width));
    } else {
      setValue(procId, udivOp.getResult(),
               InterpretedValue(lhs.getAPInt().udiv(rhs.getAPInt())));
    }
    return success();
  }

  // LLVM srem - signed integer remainder
  if (auto sremOp = dyn_cast<LLVM::SRemOp>(op)) {
    InterpretedValue lhs = getValue(procId, sremOp.getLhs());
    InterpretedValue rhs = getValue(procId, sremOp.getRhs());
    unsigned width = getTypeWidth(sremOp.getType());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, sremOp.getResult(), InterpretedValue::makeX(width));
    } else if (rhs.getAPInt().isZero()) {
      // Remainder by zero returns X
      setValue(procId, sremOp.getResult(), InterpretedValue::makeX(width));
    } else {
      setValue(procId, sremOp.getResult(),
               InterpretedValue(lhs.getAPInt().srem(rhs.getAPInt())));
    }
    return success();
  }

  // LLVM urem - unsigned integer remainder
  if (auto uremOp = dyn_cast<LLVM::URemOp>(op)) {
    InterpretedValue lhs = getValue(procId, uremOp.getLhs());
    InterpretedValue rhs = getValue(procId, uremOp.getRhs());
    unsigned width = getTypeWidth(uremOp.getType());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, uremOp.getResult(), InterpretedValue::makeX(width));
    } else if (rhs.getAPInt().isZero()) {
      // Remainder by zero returns X
      setValue(procId, uremOp.getResult(), InterpretedValue::makeX(width));
    } else {
      setValue(procId, uremOp.getResult(),
               InterpretedValue(lhs.getAPInt().urem(rhs.getAPInt())));
    }
    return success();
  }

  // LLVM fadd - floating point addition
  if (auto faddOp = dyn_cast<LLVM::FAddOp>(op)) {
    InterpretedValue lhs = getValue(procId, faddOp.getLhs());
    InterpretedValue rhs = getValue(procId, faddOp.getRhs());
    unsigned width = getTypeWidth(faddOp.getType());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, faddOp.getResult(), InterpretedValue::makeX(width));
    } else {
      // Convert APInt to floating point, perform operation, convert back
      APInt lhsInt = lhs.getAPInt();
      APInt rhsInt = rhs.getAPInt();
      if (width == 32) {
        uint32_t lhsBits = static_cast<uint32_t>(lhsInt.getZExtValue());
        uint32_t rhsBits = static_cast<uint32_t>(rhsInt.getZExtValue());
        float lhsFloat = llvm::bit_cast<float>(lhsBits);
        float rhsFloat = llvm::bit_cast<float>(rhsBits);
        float result = lhsFloat + rhsFloat;
        setValue(procId, faddOp.getResult(),
                 InterpretedValue(llvm::bit_cast<uint32_t>(result), 32));
      } else if (width == 64) {
        double lhsDouble = llvm::bit_cast<double>(lhsInt.getZExtValue());
        double rhsDouble = llvm::bit_cast<double>(rhsInt.getZExtValue());
        double result = lhsDouble + rhsDouble;
        setValue(procId, faddOp.getResult(),
                 InterpretedValue(llvm::bit_cast<uint64_t>(result), 64));
      } else {
        setValue(procId, faddOp.getResult(), InterpretedValue::makeX(width));
      }
    }
    return success();
  }

  // LLVM fsub - floating point subtraction
  if (auto fsubOp = dyn_cast<LLVM::FSubOp>(op)) {
    InterpretedValue lhs = getValue(procId, fsubOp.getLhs());
    InterpretedValue rhs = getValue(procId, fsubOp.getRhs());
    unsigned width = getTypeWidth(fsubOp.getType());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, fsubOp.getResult(), InterpretedValue::makeX(width));
    } else {
      APInt lhsInt = lhs.getAPInt();
      APInt rhsInt = rhs.getAPInt();
      if (width == 32) {
        uint32_t lhsBits = static_cast<uint32_t>(lhsInt.getZExtValue());
        uint32_t rhsBits = static_cast<uint32_t>(rhsInt.getZExtValue());
        float lhsFloat = llvm::bit_cast<float>(lhsBits);
        float rhsFloat = llvm::bit_cast<float>(rhsBits);
        float result = lhsFloat - rhsFloat;
        setValue(procId, fsubOp.getResult(),
                 InterpretedValue(llvm::bit_cast<uint32_t>(result), 32));
      } else if (width == 64) {
        double lhsDouble = llvm::bit_cast<double>(lhsInt.getZExtValue());
        double rhsDouble = llvm::bit_cast<double>(rhsInt.getZExtValue());
        double result = lhsDouble - rhsDouble;
        setValue(procId, fsubOp.getResult(),
                 InterpretedValue(llvm::bit_cast<uint64_t>(result), 64));
      } else {
        setValue(procId, fsubOp.getResult(), InterpretedValue::makeX(width));
      }
    }
    return success();
  }

  // LLVM fmul - floating point multiplication
  if (auto fmulOp = dyn_cast<LLVM::FMulOp>(op)) {
    InterpretedValue lhs = getValue(procId, fmulOp.getLhs());
    InterpretedValue rhs = getValue(procId, fmulOp.getRhs());
    unsigned width = getTypeWidth(fmulOp.getType());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, fmulOp.getResult(), InterpretedValue::makeX(width));
    } else {
      APInt lhsInt = lhs.getAPInt();
      APInt rhsInt = rhs.getAPInt();
      if (width == 32) {
        uint32_t lhsBits = static_cast<uint32_t>(lhsInt.getZExtValue());
        uint32_t rhsBits = static_cast<uint32_t>(rhsInt.getZExtValue());
        float lhsFloat = llvm::bit_cast<float>(lhsBits);
        float rhsFloat = llvm::bit_cast<float>(rhsBits);
        float result = lhsFloat * rhsFloat;
        setValue(procId, fmulOp.getResult(),
                 InterpretedValue(llvm::bit_cast<uint32_t>(result), 32));
      } else if (width == 64) {
        double lhsDouble = llvm::bit_cast<double>(lhsInt.getZExtValue());
        double rhsDouble = llvm::bit_cast<double>(rhsInt.getZExtValue());
        double result = lhsDouble * rhsDouble;
        setValue(procId, fmulOp.getResult(),
                 InterpretedValue(llvm::bit_cast<uint64_t>(result), 64));
      } else {
        setValue(procId, fmulOp.getResult(), InterpretedValue::makeX(width));
      }
    }
    return success();
  }

  // LLVM fdiv - floating point division
  if (auto fdivOp = dyn_cast<LLVM::FDivOp>(op)) {
    InterpretedValue lhs = getValue(procId, fdivOp.getLhs());
    InterpretedValue rhs = getValue(procId, fdivOp.getRhs());
    unsigned width = getTypeWidth(fdivOp.getType());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, fdivOp.getResult(), InterpretedValue::makeX(width));
    } else {
      APInt lhsInt = lhs.getAPInt();
      APInt rhsInt = rhs.getAPInt();
      if (width == 32) {
        uint32_t lhsBits = static_cast<uint32_t>(lhsInt.getZExtValue());
        uint32_t rhsBits = static_cast<uint32_t>(rhsInt.getZExtValue());
        float lhsFloat = llvm::bit_cast<float>(lhsBits);
        float rhsFloat = llvm::bit_cast<float>(rhsBits);
        float result = lhsFloat / rhsFloat;
        setValue(procId, fdivOp.getResult(),
                 InterpretedValue(llvm::bit_cast<uint32_t>(result), 32));
      } else if (width == 64) {
        double lhsDouble = llvm::bit_cast<double>(lhsInt.getZExtValue());
        double rhsDouble = llvm::bit_cast<double>(rhsInt.getZExtValue());
        double result = lhsDouble / rhsDouble;
        setValue(procId, fdivOp.getResult(),
                 InterpretedValue(llvm::bit_cast<uint64_t>(result), 64));
      } else {
        setValue(procId, fdivOp.getResult(), InterpretedValue::makeX(width));
      }
    }
    return success();
  }

  // LLVM fcmp - floating point comparison
  if (auto fcmpOp = dyn_cast<LLVM::FCmpOp>(op)) {
    InterpretedValue lhs = getValue(procId, fcmpOp.getLhs());
    InterpretedValue rhs = getValue(procId, fcmpOp.getRhs());
    if (lhs.isX() || rhs.isX()) {
      setValue(procId, fcmpOp.getResult(), InterpretedValue::makeX(1));
      return success();
    }
    unsigned width = getTypeWidth(fcmpOp.getLhs().getType());
    bool result = false;

    // Convert to appropriate floating point type and compare
    if (width == 32) {
      uint32_t lhsBits = static_cast<uint32_t>(lhs.getAPInt().getZExtValue());
      uint32_t rhsBits = static_cast<uint32_t>(rhs.getAPInt().getZExtValue());
      float lhsFloat = llvm::bit_cast<float>(lhsBits);
      float rhsFloat = llvm::bit_cast<float>(rhsBits);
      switch (fcmpOp.getPredicate()) {
      case LLVM::FCmpPredicate::_false: result = false; break;
      case LLVM::FCmpPredicate::oeq: result = lhsFloat == rhsFloat; break;
      case LLVM::FCmpPredicate::ogt: result = lhsFloat > rhsFloat; break;
      case LLVM::FCmpPredicate::oge: result = lhsFloat >= rhsFloat; break;
      case LLVM::FCmpPredicate::olt: result = lhsFloat < rhsFloat; break;
      case LLVM::FCmpPredicate::ole: result = lhsFloat <= rhsFloat; break;
      case LLVM::FCmpPredicate::one: result = lhsFloat != rhsFloat && !std::isnan(lhsFloat) && !std::isnan(rhsFloat); break;
      case LLVM::FCmpPredicate::ord: result = !std::isnan(lhsFloat) && !std::isnan(rhsFloat); break;
      case LLVM::FCmpPredicate::ueq: result = lhsFloat == rhsFloat || std::isnan(lhsFloat) || std::isnan(rhsFloat); break;
      case LLVM::FCmpPredicate::ugt: result = lhsFloat > rhsFloat || std::isnan(lhsFloat) || std::isnan(rhsFloat); break;
      case LLVM::FCmpPredicate::uge: result = lhsFloat >= rhsFloat || std::isnan(lhsFloat) || std::isnan(rhsFloat); break;
      case LLVM::FCmpPredicate::ult: result = lhsFloat < rhsFloat || std::isnan(lhsFloat) || std::isnan(rhsFloat); break;
      case LLVM::FCmpPredicate::ule: result = lhsFloat <= rhsFloat || std::isnan(lhsFloat) || std::isnan(rhsFloat); break;
      case LLVM::FCmpPredicate::une: result = lhsFloat != rhsFloat; break;
      case LLVM::FCmpPredicate::uno: result = std::isnan(lhsFloat) || std::isnan(rhsFloat); break;
      case LLVM::FCmpPredicate::_true: result = true; break;
      }
    } else if (width == 64) {
      double lhsDouble = llvm::bit_cast<double>(lhs.getAPInt().getZExtValue());
      double rhsDouble = llvm::bit_cast<double>(rhs.getAPInt().getZExtValue());
      switch (fcmpOp.getPredicate()) {
      case LLVM::FCmpPredicate::_false: result = false; break;
      case LLVM::FCmpPredicate::oeq: result = lhsDouble == rhsDouble; break;
      case LLVM::FCmpPredicate::ogt: result = lhsDouble > rhsDouble; break;
      case LLVM::FCmpPredicate::oge: result = lhsDouble >= rhsDouble; break;
      case LLVM::FCmpPredicate::olt: result = lhsDouble < rhsDouble; break;
      case LLVM::FCmpPredicate::ole: result = lhsDouble <= rhsDouble; break;
      case LLVM::FCmpPredicate::one: result = lhsDouble != rhsDouble && !std::isnan(lhsDouble) && !std::isnan(rhsDouble); break;
      case LLVM::FCmpPredicate::ord: result = !std::isnan(lhsDouble) && !std::isnan(rhsDouble); break;
      case LLVM::FCmpPredicate::ueq: result = lhsDouble == rhsDouble || std::isnan(lhsDouble) || std::isnan(rhsDouble); break;
      case LLVM::FCmpPredicate::ugt: result = lhsDouble > rhsDouble || std::isnan(lhsDouble) || std::isnan(rhsDouble); break;
      case LLVM::FCmpPredicate::uge: result = lhsDouble >= rhsDouble || std::isnan(lhsDouble) || std::isnan(rhsDouble); break;
      case LLVM::FCmpPredicate::ult: result = lhsDouble < rhsDouble || std::isnan(lhsDouble) || std::isnan(rhsDouble); break;
      case LLVM::FCmpPredicate::ule: result = lhsDouble <= rhsDouble || std::isnan(lhsDouble) || std::isnan(rhsDouble); break;
      case LLVM::FCmpPredicate::une: result = lhsDouble != rhsDouble; break;
      case LLVM::FCmpPredicate::uno: result = std::isnan(lhsDouble) || std::isnan(rhsDouble); break;
      case LLVM::FCmpPredicate::_true: result = true; break;
      }
    }
    setValue(procId, fcmpOp.getResult(), InterpretedValue(result ? 1 : 0, 1));
    return success();
  }

  // LLVM extractvalue - extract a value from an aggregate (struct/array)
  if (auto extractValueOp = dyn_cast<LLVM::ExtractValueOp>(op)) {
    InterpretedValue container = getValue(procId, extractValueOp.getContainer());
    unsigned resultWidth = getTypeWidth(extractValueOp.getType());
    if (container.isX()) {
      setValue(procId, extractValueOp.getResult(),
               InterpretedValue::makeX(resultWidth));
      return success();
    }

    // Calculate the bit offset for the indexed position
    // LLVM aggregates are laid out from low bits to high bits (opposite of HW)
    Type currentType = extractValueOp.getContainer().getType();
    unsigned bitOffset = 0;
    for (int64_t idx : extractValueOp.getPosition()) {
      if (auto structType = dyn_cast<LLVM::LLVMStructType>(currentType)) {
        // For struct, accumulate offsets of preceding fields
        auto body = structType.getBody();
        for (int64_t i = 0; i < idx; ++i) {
          bitOffset += getTypeWidth(body[i]);
        }
        currentType = body[idx];
      } else if (auto arrayType = dyn_cast<LLVM::LLVMArrayType>(currentType)) {
        // For array, compute offset based on element size
        unsigned elemWidth = getTypeWidth(arrayType.getElementType());
        bitOffset += elemWidth * idx;
        currentType = arrayType.getElementType();
      }
    }

    APInt extractedValue =
        container.getAPInt().extractBits(resultWidth, bitOffset);
    setValue(procId, extractValueOp.getResult(),
             InterpretedValue(extractedValue));
    return success();
  }

  // LLVM insertvalue - insert a value into an aggregate (struct/array)
  if (auto insertValueOp = dyn_cast<LLVM::InsertValueOp>(op)) {
    InterpretedValue container = getValue(procId, insertValueOp.getContainer());
    InterpretedValue value = getValue(procId, insertValueOp.getValue());
    unsigned totalWidth = getTypeWidth(insertValueOp.getType());

    // If only the value being inserted is X, propagate X
    if (value.isX()) {
      setValue(procId, insertValueOp.getResult(),
               InterpretedValue::makeX(totalWidth));
      return success();
    }

    // If the container is X (e.g., from llvm.mlir.undef), treat it as zeros
    // to allow building up structs incrementally. This is the common pattern
    // for constructing structs: start with undef, then insertvalue fields.
    if (container.isX()) {
      container = InterpretedValue(APInt::getZero(totalWidth));
    }

    // Calculate the bit offset for the indexed position
    // LLVM aggregates are laid out from low bits to high bits (opposite of HW)
    Type currentType = insertValueOp.getContainer().getType();
    unsigned bitOffset = 0;
    unsigned fieldWidth = 0;
    for (int64_t idx : insertValueOp.getPosition()) {
      if (auto structType = dyn_cast<LLVM::LLVMStructType>(currentType)) {
        // For struct, accumulate offsets of preceding fields
        auto body = structType.getBody();
        for (int64_t i = 0; i < idx; ++i) {
          bitOffset += getTypeWidth(body[i]);
        }
        currentType = body[idx];
      } else if (auto arrayType = dyn_cast<LLVM::LLVMArrayType>(currentType)) {
        // For array, compute offset based on element size
        unsigned elemWidth = getTypeWidth(arrayType.getElementType());
        bitOffset += elemWidth * idx;
        currentType = arrayType.getElementType();
      }
    }
    fieldWidth = getTypeWidth(currentType);

    APInt result = container.getAPInt();
    APInt fieldValue = value.getAPInt();
    if (fieldValue.getBitWidth() < fieldWidth)
      fieldValue = fieldValue.zext(fieldWidth);
    else if (fieldValue.getBitWidth() > fieldWidth)
      fieldValue = fieldValue.trunc(fieldWidth);
    safeInsertBits(result,fieldValue, bitOffset);

    setValue(procId, insertValueOp.getResult(), InterpretedValue(result));
    return success();
  }

  // Handle builtin.unrealized_conversion_cast - propagate values through
  if (auto castOp = dyn_cast<UnrealizedConversionCastOp>(op)) {
    // For casts, propagate the input values to the output values
    if (castOp.getNumOperands() == castOp.getNumResults()) {
      // Simple 1:1 mapping
      for (auto [input, output] : llvm::zip(castOp.getInputs(), castOp.getOutputs())) {
        // For !llvm.ptr to !llhd.ref casts, propagate the pointer address.
        // The probe/drive handlers use SSA tracing (getDefiningOp) first,
        // but the address value is needed as a fallback when the ref is
        // passed through function arguments (where SSA tracing fails).
        Type inputType = input.getType();
        Type outputType = output.getType();
        if (isa<LLVM::LLVMPointerType>(inputType) &&
            isa<llhd::RefType>(outputType)) {
          InterpretedValue ptrVal = getValue(procId, input);
          setValue(procId, output, ptrVal);
          LLVM_DEBUG(llvm::dbgs() << "  builtin.unrealized_conversion_cast: "
                                  << "ptr->ref cast, propagating address "
                                  << (ptrVal.isX() ? "X" : std::to_string(ptrVal.getUInt64()))
                                  << "\n");
          continue;
        }

        // For !llhd.ref<T> -> !llvm.ptr casts, allocate a backing memory
        // block for the signal so that llvm.store writes are visible to
        // llhd.prb reads.  This pattern arises in --ir-hw mode where output
        // function arguments write to signals via memory.
        if (isa<llhd::RefType>(inputType) &&
            isa<LLVM::LLVMPointerType>(outputType)) {
          // Look up the signal for this ref
          auto sigIt = valueToSignal.find(input);
          if (sigIt != valueToSignal.end()) {
            SignalId sigId = sigIt->second;
            // Only use backing memory for signals that are NOT driven via
            // llhd.drv (those should use scheduler state instead).
            bool hasDriveUser = false;
            for (auto *sigUser : input.getUsers()) {
              if (isa<llhd::DriveOp>(sigUser) ||
                  isa<llhd::SigStructExtractOp>(sigUser)) {
                hasDriveUser = true;
                break;
              }
            }
            if (hasDriveUser) {
              // Fall through to the general value propagation
            } else {
            // Check if we already allocated a backing block
            auto backingIt = signalBackingMemory.find(sigId);
            if (backingIt != signalBackingMemory.end()) {
              // Reuse: look up the existing block and return its address
              auto &st = processStates[backingIt->second.first];
              auto blkIt = st.memoryBlocks.find(backingIt->second.second);
              if (blkIt != st.memoryBlocks.end()) {
                uint64_t addr = reinterpret_cast<uint64_t>(
                    blkIt->second.data.data());
                setValue(procId, output, InterpretedValue(addr, 64));
              }
            } else {
              // Allocate a new memory block for this signal
              Type innerType =
                  cast<llhd::RefType>(inputType).getNestedType();
              unsigned width = getTypeWidth(innerType);
              unsigned byteSize = std::max(1u, (width + 7) / 8);
              auto &block = processStates[procId].memoryBlocks[output];
              block.size = byteSize;
              block.data.resize(byteSize, 0);
              block.initialized = true;
              // Initialize with current signal value
              const SignalValue &sigVal =
                  scheduler.getSignalValue(sigId);
              if (!sigVal.isUnknown()) {
                APInt v = sigVal.getAPInt();
                for (unsigned i = 0; i < byteSize && i * 8 < width; ++i)
                  block.data[i] = v.extractBitsAsZExtValue(
                      std::min(8u, width - i * 8), i * 8);
              }
              signalBackingMemory[sigId] = {procId, output};
              uint64_t addr = reinterpret_cast<uint64_t>(
                  block.data.data());
              setValue(procId, output, InterpretedValue(addr, 64));
            }
            continue;
            } // end of else (no drive users)
          }
        }

        InterpretedValue val = getValue(procId, input);

        // Handle layout conversion between LLVM struct and HW struct types
        Type inputType2 = input.getType();
        Type outputType2 = output.getType();
        if (!val.isX()) {
          if ((isa<LLVM::LLVMStructType, LLVM::LLVMArrayType>(inputType2)) &&
              (isa<hw::StructType, hw::ArrayType>(outputType2))) {
            // LLVM -> HW layout conversion
            APInt converted = convertLLVMToHWLayout(val.getAPInt(), inputType2, outputType2);
            val = InterpretedValue(converted);
          } else if ((isa<hw::StructType, hw::ArrayType>(inputType2)) &&
                     (isa<LLVM::LLVMStructType, LLVM::LLVMArrayType>(outputType2))) {
            // HW -> LLVM layout conversion
            APInt converted = convertHWToLLVMLayout(val.getAPInt(), inputType2, outputType2);
            val = InterpretedValue(converted);
          }
        }

        // Adjust width if needed
        unsigned outputWidth = getTypeWidth(output.getType());
        if (!val.isX() && val.getWidth() != outputWidth) {
          if (outputWidth > 64) {
            APInt apVal = val.getAPInt();
            if (apVal.getBitWidth() < outputWidth) {
              apVal = apVal.zext(outputWidth);
            } else if (apVal.getBitWidth() > outputWidth) {
              apVal = apVal.trunc(outputWidth);
            }
            val = InterpretedValue(apVal);
          } else {
            // Mask the value to fit in outputWidth bits to avoid APInt assertion
            uint64_t maskedVal = val.getUInt64();
            if (outputWidth < 64)
              maskedVal &= ((1ULL << outputWidth) - 1);
            val = InterpretedValue(maskedVal, outputWidth);
          }
        }
        setValue(procId, output, val);
      }
    } else if (castOp.getNumOperands() == 1 && castOp.getNumResults() > 0) {
      // Single input to multiple outputs (common for function types)
      InterpretedValue val = getValue(procId, castOp.getInputs()[0]);
      for (Value output : castOp.getOutputs()) {
        unsigned outputWidth = getTypeWidth(output.getType());
        // Mask the value to fit in outputWidth bits to avoid APInt assertion
        uint64_t maskedVal = val.isX() ? 0 : val.getUInt64();
        if (outputWidth < 64)
          maskedVal &= ((1ULL << outputWidth) - 1);
        setValue(procId, output, InterpretedValue(maskedVal, outputWidth));
      }
    } else {
      // Just propagate input values for non-standard patterns
      unsigned numToCopy = std::min(castOp.getNumOperands(), castOp.getNumResults());
      for (unsigned i = 0; i < numToCopy; ++i) {
        setValue(procId, castOp.getResult(i), getValue(procId, castOp.getOperand(i)));
      }
      // Set remaining results to X
      for (unsigned i = numToCopy; i < castOp.getNumResults(); ++i) {
        setValue(procId, castOp.getResult(i),
                 InterpretedValue::makeX(getTypeWidth(castOp.getResult(i).getType())));
      }
    }
    LLVM_DEBUG(llvm::dbgs() << "  builtin.unrealized_conversion_cast: propagated "
                            << castOp.getNumOperands() << " inputs to "
                            << castOp.getNumResults() << " outputs\n");
    return success();
  }

  // Verification ops (assert/assume/cover) are formal-only constructs.
  // In simulation, halt the enclosing process since it has no useful work.
  // These typically appear in processes like: ^bb1: verif.cover ... / cf.br ^bb1
  // which would spin forever if we just returned success().
  // Handle immediate (procedural) assertions: check the condition but
  // continue execution. Only clocked/concurrent assertions are unsupported.
  if (auto assertOp = dyn_cast<verif::AssertOp>(op)) {
    InterpretedValue cond = getValue(procId, assertOp.getProperty());
    if (!cond.isX() && cond.getAPInt().isZero()) {
      std::string label;
      if (auto labelAttr = assertOp->getAttrOfType<StringAttr>("label"))
        label = labelAttr.getValue().str();
      llvm::errs() << "[circt-sim] Assertion failed";
      if (!label.empty())
        llvm::errs() << ": " << label;
      llvm::errs() << " at " << assertOp.getLoc() << "\n";
    }
    return success();
  }
  if (isa<verif::AssumeOp, verif::CoverOp>(op)) {
    // Assume/cover: skip in simulation
    return success();
  }
  if (isa<verif::ClockedAssertOp, verif::ClockedAssumeOp,
          verif::ClockedCoverOp>(op)) {
    LLVM_DEBUG(llvm::dbgs() << "  Clocked formal verification op in simulation"
                            << " - halting process\n");
    finalizeProcess(procId, /*killed=*/false);
    return success();
  }

  // For unhandled operations, issue a warning but continue
  LLVM_DEBUG(llvm::dbgs() << "  Warning: Unhandled operation: "
                          << op->getName().getStringRef() << "\n");

  // For operations with results, set them to X
  for (Value result : op->getResults()) {
    setValue(procId, result,
             InterpretedValue::makeX(getTypeWidth(result.getType())));
  }

  return success();
}

LogicalResult LLHDProcessInterpreter::interpretProbe(ProcessId procId,
                                                      llhd::ProbeOp probeOp) {
  auto *statePtr = (procId == activeProcessId && activeProcessState)
                       ? activeProcessState
                       : &processStates[procId];
  auto remapRefBlockArgSource = [&](Value &ref) {
    llvm::SmallVector<Value, 4> visited;
    while (auto arg = dyn_cast<BlockArgument>(ref)) {
      if (!isa<llhd::RefType>(arg.getType()))
        break;
      bool seen = false;
      for (Value visitedValue : visited) {
        if (visitedValue == ref) {
          seen = true;
          break;
        }
      }
      if (seen)
        break;
      visited.push_back(ref);

      auto srcIt = statePtr->refBlockArgSources.find(arg);
      if (srcIt != statePtr->refBlockArgSources.end() &&
          srcIt->second != ref) {
        ref = srcIt->second;
        continue;
      }

      Value mappedValue;
      InstanceId mappedInstance = activeInstanceId;
      if (lookupInputMapping(arg, mappedValue, mappedInstance) &&
          mappedValue != ref) {
        ScopedInstanceContext scope(*this, mappedInstance);
        ref = mappedValue;
        continue;
      }
      break;
    }
  };

  Value signal = probeOp.getSignal();
  remapRefBlockArgSource(signal);
  while (auto muxOp = signal.getDefiningOp<comb::MuxOp>()) {
    InterpretedValue cond = getValue(procId, muxOp.getCond());
    if (cond.isX()) {
      setValue(procId, probeOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(probeOp.getResult().getType())));
      return success();
    }
    signal = cond.getUInt64() != 0 ? muxOp.getTrueValue() : muxOp.getFalseValue();
    remapRefBlockArgSource(signal);
  }

  // Handle arith.select on ref types (e.g., !llhd.ref<!hw.struct<...>>)
  while (auto selectOp = signal.getDefiningOp<arith::SelectOp>()) {
    InterpretedValue cond = getValue(procId, selectOp.getCondition());
    if (cond.isX()) {
      setValue(procId, probeOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(probeOp.getResult().getType())));
      return success();
    }
    signal = cond.getUInt64() != 0 ? selectOp.getTrueValue() : selectOp.getFalseValue();
    remapRefBlockArgSource(signal);
  }

  // Get the signal ID for the probed signal
  SignalId sigId = resolveSignalId(signal);
  if (sigId == 0) {
    // Check if this is a global variable access via UnrealizedConversionCastOp
    // This happens when static class properties are accessed - they're stored
    // in LLVM globals, not LLHD signals.
    if (auto castOp =
            signal.getDefiningOp<mlir::UnrealizedConversionCastOp>()) {
      if (castOp.getInputs().size() == 1) {
        Value input = castOp.getInputs()[0];
        if (auto addrOfOp = input.getDefiningOp<LLVM::AddressOfOp>()) {
          StringRef globalName = addrOfOp.getGlobalName();
          LLVM_DEBUG(llvm::dbgs()
                     << "  Probe of global variable: " << globalName << "\n");

          // Read from global memory block
          auto blockIt = globalMemoryBlocks.find(globalName);
          if (blockIt != globalMemoryBlocks.end()) {
            MemoryBlock &block = blockIt->second;
            // Read the pointer value from global memory
            uint64_t ptrValue = 0;
            bool hasUnknown = !block.initialized;

            if (!hasUnknown) {
              // Read 8 bytes (pointer size) from the memory block
              unsigned readSize = std::min(8u, static_cast<unsigned>(block.size));
              for (unsigned i = 0; i < readSize; ++i) {
                ptrValue |= (static_cast<uint64_t>(block.data[i]) << (i * 8));
              }
            }

            InterpretedValue val;
            if (hasUnknown) {
              val = InterpretedValue::makeX(64);
            } else {
              val = InterpretedValue(ptrValue, 64);
            }
            setValue(procId, probeOp.getResult(), val);
            LLVM_DEBUG(llvm::dbgs()
                       << "  Read global " << globalName << " = "
                       << (hasUnknown ? "X" : std::to_string(ptrValue)) << "\n");
            return success();
          }
        }
        // Handle GEP-based memory access (e.g., class member access)
        // This happens when class properties are accessed - the property ref
        // creates a GEP to the field, which is then cast to !llhd.ref.
        if (auto gepOp = input.getDefiningOp<LLVM::GEPOp>()) {
          // Get the pointer value computed by the GEP
          InterpretedValue ptrVal = getValue(procId, gepOp.getResult());
          unsigned width = getTypeWidth(probeOp.getResult().getType());
          unsigned loadSize = (width + 7) / 8;

          if (ptrVal.isX()) {
            // Uninitialized pointer - return X
            setValue(procId, probeOp.getResult(), InterpretedValue::makeX(width));
            LLVM_DEBUG(llvm::dbgs()
                       << "  Probe of GEP pointer: X (uninitialized)\n");
            return success();
          }

          // Find the memory block - first try local, then global, then malloc
          MemoryBlock *block = findMemoryBlock(procId, gepOp);
          uint64_t offset = 0;

          if (block) {
            // Calculate offset for local memory
            InterpretedValue baseVal = getValue(procId, gepOp.getBase());
            if (!baseVal.isX()) {
              offset = ptrVal.getUInt64() - baseVal.getUInt64();
            }
          } else {
            // Check global and malloc memory via O(log n) range index
            uint64_t addr = ptrVal.getUInt64();
            block = findBlockByAddress(addr, offset);
            LLVM_DEBUG(if (block) llvm::dbgs()
                       << "  Probe: found block at offset " << offset << "\n");
          }

          if (!block) {
            LLVM_DEBUG(llvm::dbgs()
                       << "  Probe of GEP pointer 0x"
                       << llvm::format_hex(ptrVal.getUInt64(), 0)
                       << " failed - memory not found\n");
            setValue(procId, probeOp.getResult(), InterpretedValue::makeX(width));
            return success();
          }

          if (offset + loadSize > block->size) {
            LLVM_DEBUG(llvm::dbgs()
                       << "  Probe: out of bounds (offset=" << offset
                       << " size=" << loadSize << " block=" << block->size << ")\n");
            setValue(procId, probeOp.getResult(), InterpretedValue::makeX(width));
            return success();
          }

          if (!block->initialized) {
            LLVM_DEBUG(llvm::dbgs() << "  Probe: reading uninitialized memory\n");
            setValue(procId, probeOp.getResult(), InterpretedValue::makeX(width));
            return success();
          }

          // Read the value from memory using APInt (supports >64-bit structs)
          APInt memValue = APInt::getZero(width);
          for (unsigned i = 0; i < loadSize && i * 8 < width; ++i) {
            unsigned bitsToInsert = std::min(8u, width - i * 8);
            APInt byteVal(bitsToInsert,
                          block->data[offset + i] & ((1u << bitsToInsert) - 1));
            safeInsertBits(memValue, byteVal, i * 8);
          }

          // Check if we need to convert from LLVM layout to HW layout.
          // LLVM struct fields are at low-to-high bits, while HW struct
          // fields are at high-to-low bits.
          Type resultType = probeOp.getResult().getType();
          Type gepElemType = gepOp.getElemType();
          if (isa<hw::StructType, hw::ArrayType>(resultType) &&
              gepElemType &&
              isa<LLVM::LLVMStructType, LLVM::LLVMArrayType>(
                  gepElemType)) {
            APInt hwValue =
                convertLLVMToHWLayout(memValue, gepElemType, resultType);
            setValue(procId, probeOp.getResult(), InterpretedValue(hwValue));
            LLVM_DEBUG(llvm::dbgs()
                       << "  Probe of GEP pointer 0x"
                       << llvm::format_hex(ptrVal.getUInt64(), 0)
                       << " (LLVM->HW layout) width=" << width << "\n");
          } else {
            setValue(procId, probeOp.getResult(), InterpretedValue(memValue));
            LLVM_DEBUG(llvm::dbgs()
                       << "  Probe of GEP pointer 0x"
                       << llvm::format_hex(ptrVal.getUInt64(), 0)
                       << " width=" << width << "\n");
          }
          return success();
        }
        // Handle AllocaOp - local variables in functions backed by llvm.alloca
        // Pattern: %alloca = llvm.alloca -> unrealized_cast to !llhd.ref -> llhd.prb
        // This happens when local variables inside class methods are cast to refs.
        if (auto allocaOp = input.getDefiningOp<LLVM::AllocaOp>()) {
          unsigned width = getTypeWidth(probeOp.getResult().getType());
          unsigned loadSize = (width + 7) / 8;

          // Find the memory block for this alloca
          MemoryBlock *block = findMemoryBlock(procId, allocaOp);
          if (!block) {
            // Try finding by alloca result in process-local memory blocks
            auto &state = processStates[procId];
            auto it = state.memoryBlocks.find(allocaOp.getResult());
            if (it != state.memoryBlocks.end()) {
              block = &it->second;
              LLVM_DEBUG(llvm::dbgs() << "  Probe: found local alloca memory\n");
            }
          }

          if (!block) {
            LLVM_DEBUG(llvm::dbgs() << "  Probe of alloca failed - memory not found\n");
            setValue(procId, probeOp.getResult(), InterpretedValue::makeX(width));
            return success();
          }

          if (loadSize > block->size) {
            LLVM_DEBUG(llvm::dbgs()
                       << "  Probe: out of bounds (size=" << loadSize
                       << " block=" << block->size << ")\n");
            setValue(procId, probeOp.getResult(), InterpretedValue::makeX(width));
            return success();
          }

          if (!block->initialized) {
            LLVM_DEBUG(llvm::dbgs() << "  Probe: reading uninitialized alloca memory\n");
            setValue(procId, probeOp.getResult(), InterpretedValue::makeX(width));
            return success();
          }

          // Read the value from memory (little-endian byte order)
          APInt memValue = APInt::getZero(width);
          for (unsigned i = 0; i < loadSize && i * 8 < width; ++i) {
            unsigned bitsToInsert = std::min(8u, width - i * 8);
            APInt byteVal(bitsToInsert,
                          block->data[i] & ((1u << bitsToInsert) - 1));
            safeInsertBits(memValue,byteVal, i * 8);
          }

          // Check if we need to convert from LLVM layout to HW layout.
          // LLVM struct fields are at low-to-high bits, while HW struct
          // fields are at high-to-low bits.
          Type resultType = probeOp.getResult().getType();
          Type allocaElemType = allocaOp.getElemType();
          if (isa<hw::StructType, hw::ArrayType>(resultType) &&
              isa<LLVM::LLVMStructType, LLVM::LLVMArrayType>(
                  allocaElemType)) {
            // Recursively convert from LLVM layout to HW layout so that
            // nested structs and arrays are also properly reordered.
            APInt hwValue =
                convertLLVMToHWLayout(memValue, allocaElemType, resultType);
            setValue(procId, probeOp.getResult(), InterpretedValue(hwValue));
            LLVM_DEBUG(llvm::dbgs()
                       << "  Probe of alloca (LLVM->HW layout conversion) = 0x"
                       << llvm::format_hex(hwValue.getZExtValue(), 0)
                       << " (width=" << width << ")\n");
            return success();
          }

          // No layout conversion needed - use value as-is
          setValue(procId, probeOp.getResult(), InterpretedValue(memValue));
          LLVM_DEBUG(llvm::dbgs()
                     << "  Probe of alloca = 0x"
                     << llvm::format_hex(memValue.getZExtValue(), 0)
                     << " (width=" << width << ")\n");
          return success();
        }
        // Handle ProbeOp input - this happens when interface ports are
        // passed through module instances. Pattern:
        //   %ptr = llhd.prb %sig : !llvm.ptr
        //   %ref = unrealized_conversion_cast %ptr : !llvm.ptr to !llhd.ref<!llvm.ptr>
        //   hw.instance @mod(port: %ref)
        //   // Inside @mod: %val = llhd.prb %port : !llvm.ptr
        // We need to re-probe the original signal (%sig) to get its current value.
        if (auto innerProbeOp = input.getDefiningOp<llhd::ProbeOp>()) {
          Value innerSignal = innerProbeOp.getSignal();
          SignalId innerSigId = resolveSignalId(innerSignal);
          if (innerSigId != 0) {
            // Check for pending epsilon drives first (blocking assignment)
            auto pendingIt = pendingEpsilonDrives.find(innerSigId);
            if (pendingIt != pendingEpsilonDrives.end()) {
              setValue(procId, probeOp.getResult(), pendingIt->second);
              LLVM_DEBUG(llvm::dbgs()
                         << "  Re-probe of cast-from-prb signal " << innerSigId
                         << " = " << pendingIt->second.getUInt64()
                         << " (from pending epsilon drive)\n");
              return success();
            }
            const SignalValue &sigVal = scheduler.getSignalValue(innerSigId);
            InterpretedValue val;
            if (sigVal.isUnknown()) {
              if (auto encoded = getEncodedUnknownForType(probeOp.getResult().getType()))
                val = InterpretedValue(*encoded);
              else
                val = InterpretedValue::makeX(
                    getTypeWidth(probeOp.getResult().getType()));
            } else {
              val = InterpretedValue::fromSignalValue(sigVal);
            }
            setValue(procId, probeOp.getResult(), val);
            LLVM_DEBUG(llvm::dbgs()
                       << "  Re-probe of cast-from-prb signal " << innerSigId
                       << " = "
                       << (sigVal.isUnknown() ? "X"
                                              : std::to_string(sigVal.getValue()))
                       << "\n");
            return success();
          }
          // If signal not found, fall through to other handlers
          LLVM_DEBUG(llvm::dbgs()
                     << "  Cast-from-prb: could not resolve inner signal\n");
        }
      }
    }

    // Handle llhd.sig.struct_extract - probe a field within a struct signal.
    // We need to read the parent signal and extract the relevant field bits.
    if (auto sigExtractOp = signal.getDefiningOp<llhd::SigStructExtractOp>()) {
      // Find the parent signal ID by tracing through nested extracts
      Value parentSignal = sigExtractOp.getInput();
      SignalId parentSigId = getSignalId(parentSignal);

      // Handle nested struct extracts by tracing to the root signal
      llvm::SmallVector<llhd::SigStructExtractOp, 4> extractChain;
      extractChain.push_back(sigExtractOp);

      while (parentSigId == 0) {
        if (auto nestedExtract =
                parentSignal.getDefiningOp<llhd::SigStructExtractOp>()) {
          extractChain.push_back(nestedExtract);
          parentSignal = nestedExtract.getInput();
          parentSigId = getSignalId(parentSignal);
        } else {
          break;
        }
      }

      // If still not found, try resolveSignalId which handles more cases.
      if (parentSigId == 0) {
        parentSigId = resolveSignalId(parentSignal);
      }

      // Handle memory-backed !llhd.ref (e.g., from llvm.alloca via
      // unrealized_conversion_cast, or passed as function argument).
      // The runtime value contains the alloca address.
      if (parentSigId == 0) {
        InterpretedValue parentPtrVal = getValue(procId, parentSignal);
        if (!parentPtrVal.isX() && parentPtrVal.getUInt64() != 0) {
          uint64_t addr = parentPtrVal.getUInt64();
          uint64_t blockOffset = 0;
          MemoryBlock *block =
              findMemoryBlockByAddress(addr, procId, &blockOffset);
          if (block) {
            // Compute field bit offset using LLVM layout (low-to-high bits,
            // field 0 at bit 0).
            unsigned bitOffset = 0;
            Type currentType = parentSignal.getType();
            if (auto refType = dyn_cast<llhd::RefType>(currentType))
              currentType = refType.getNestedType();

            for (auto it = extractChain.rbegin(); it != extractChain.rend();
                 ++it) {
              auto extractOp = *it;
              auto structType = cast<hw::StructType>(currentType);
              auto elements = structType.getElements();
              StringRef fieldName = extractOp.getField();
              auto fieldIndexOpt = structType.getFieldIndex(fieldName);
              if (!fieldIndexOpt)
                return failure();
              unsigned fieldIndex = *fieldIndexOpt;
              unsigned fieldOff = 0;
              for (size_t i = 0; i < fieldIndex; ++i)
                fieldOff += getTypeWidth(elements[i].type);
              bitOffset += fieldOff;
              currentType = elements[fieldIndex].type;
            }

            unsigned fieldWidth = getTypeWidth(currentType);
            unsigned parentWidth = getTypeWidth(parentSignal.getType());
            unsigned parentStoreSize = (parentWidth + 7) / 8;

            if (blockOffset + parentStoreSize <= block->size) {
              if (!block->initialized) {
                setValue(procId, probeOp.getResult(),
                         InterpretedValue::makeX(fieldWidth));
              } else {
                // Read the parent struct value from memory
                APInt parentBits = APInt::getZero(parentWidth);
                for (unsigned i = 0; i < parentStoreSize; ++i) {
                  unsigned insertPos = i * 8;
                  unsigned bitsToInsert =
                      std::min(8u, parentWidth - insertPos);
                  if (bitsToInsert > 0 && insertPos < parentWidth) {
                    APInt byteVal(bitsToInsert,
                                  block->data[blockOffset + i] &
                                      ((1u << bitsToInsert) - 1));
                    safeInsertBits(parentBits,byteVal, insertPos);
                  }
                }
                // Extract the field (memory is in LLVM layout).
                APInt fieldBits =
                    parentBits.extractBits(fieldWidth, bitOffset);
                if (isa<hw::StructType, hw::ArrayType>(currentType))
                  fieldBits =
                      convertLLVMToHWLayoutByHWType(fieldBits, currentType);
                setValue(procId, probeOp.getResult(),
                         InterpretedValue(fieldBits));
              }

              LLVM_DEBUG(llvm::dbgs()
                         << "  Probe struct field from memory-backed ref at "
                            "offset "
                         << bitOffset << " width " << fieldWidth << "\n");
              return success();
            }
          }
        }
      }

      if (parentSigId == 0) {
        LLVM_DEBUG(llvm::dbgs()
                   << "  Error: Could not find parent signal for struct extract probe\n");
        return failure();
      }

      // Get the current value of the parent signal
      const SignalValue &parentSV = scheduler.getSignalValue(parentSigId);
      InterpretedValue parentVal = InterpretedValue::fromSignalValue(parentSV);

      // Compute the bit offset by walking the extract chain in reverse
      // (from root signal to the target field)
      unsigned bitOffset = 0;
      Type currentType = parentSignal.getType();
      if (auto refType = dyn_cast<llhd::RefType>(currentType))
        currentType = refType.getNestedType();

      for (auto it = extractChain.rbegin(); it != extractChain.rend(); ++it) {
        auto extractOp = *it;
        auto structType = cast<hw::StructType>(currentType);
        auto elements = structType.getElements();
        StringRef fieldName = extractOp.getField();

        auto fieldIndexOpt = structType.getFieldIndex(fieldName);
        if (!fieldIndexOpt) {
          LLVM_DEBUG(llvm::dbgs() << "  Error: Field not found: " << fieldName
                                  << "\n");
          return failure();
        }
        unsigned fieldIndex = *fieldIndexOpt;

        // Fields are laid out from high bits to low bits
        // Calculate offset from the low bit of the current struct
        unsigned fieldOffset = 0;
        for (size_t i = fieldIndex + 1; i < elements.size(); ++i)
          fieldOffset += getTypeWidth(elements[i].type);

        bitOffset += fieldOffset;
        currentType = elements[fieldIndex].type;
      }

      unsigned fieldWidth = getTypeWidth(currentType);

      // Extract the field value from the parent signal
      InterpretedValue fieldVal;
      if (parentVal.isX()) {
        fieldVal = InterpretedValue::makeX(fieldWidth);
      } else {
        APInt parentBits = parentVal.getAPInt();
        APInt fieldBits = parentBits.extractBits(fieldWidth, bitOffset);
        fieldVal = InterpretedValue(fieldBits);
      }

      setValue(procId, probeOp.getResult(), fieldVal);
      LLVM_DEBUG(llvm::dbgs()
                 << "  Probe struct field at offset " << bitOffset
                 << " width " << fieldWidth << " from signal " << parentSigId
                 << " = " << (fieldVal.isX() ? "X" : std::to_string(fieldVal.getUInt64()))
                 << "\n");
      return success();
    }

    // Handle llhd.sig.extract - probe a bit range from a signal/ref.
    // Pattern: %alloca -> cast to !llhd.ref<i32> -> sig.extract -> prb
    if (auto bitExtractOp = signal.getDefiningOp<llhd::SigExtractOp>()) {
      InterpretedValue lowBitVal = getValue(procId, bitExtractOp.getLowBit());
      unsigned totalBitOffset = lowBitVal.isX() ? 0 : lowBitVal.getUInt64();

      // Chase through nested SigExtractOps
      Value parentRef = bitExtractOp.getInput();
      while (auto nestedExtract = parentRef.getDefiningOp<llhd::SigExtractOp>()) {
        InterpretedValue nestedLowBit =
            getValue(procId, nestedExtract.getLowBit());
        totalBitOffset += nestedLowBit.isX() ? 0 : nestedLowBit.getUInt64();
        parentRef = nestedExtract.getInput();
      }

      unsigned resultWidth = getTypeWidth(probeOp.getResult().getType());

      // Check for alloca-backed ref
      if (auto castOp =
              parentRef.getDefiningOp<mlir::UnrealizedConversionCastOp>()) {
        if (castOp.getInputs().size() == 1) {
          Value input = castOp.getInputs()[0];
          // Find memory block - try alloca first, then address-based lookup.
          // This handles both alloca-backed refs (local variables) and
          // GEP-backed refs (class properties like JTAG coverage fields).
          unsigned parentWidth = getTypeWidth(parentRef.getType());
          unsigned loadSize = (parentWidth + 7) / 8;
          MemoryBlock *block = nullptr;
          uint64_t blockOffset = 0;

          if (auto allocaOp = input.getDefiningOp<LLVM::AllocaOp>()) {
            block = findMemoryBlock(procId, allocaOp);
            if (!block) {
              auto &state = processStates[procId];
              auto it = state.memoryBlocks.find(allocaOp.getResult());
              if (it != state.memoryBlocks.end())
                block = &it->second;
            }
          }

          // Fallback: use address-based lookup for GEP and other pointers
          if (!block) {
            InterpretedValue ptrVal = getValue(procId, input);
            if (!ptrVal.isX() && ptrVal.getUInt64() != 0) {
              block = findMemoryBlockByAddress(ptrVal.getUInt64(), procId,
                                               &blockOffset);
            }
          }

          if (!block || !block->initialized) {
            setValue(procId, probeOp.getResult(),
                    InterpretedValue::makeX(resultWidth));
            return success();
          }

          if (blockOffset + loadSize > block->size) {
            setValue(procId, probeOp.getResult(),
                    InterpretedValue::makeX(resultWidth));
            return success();
          }

          // Read the full value from memory
          APInt fullVal = APInt::getZero(parentWidth);
          for (unsigned i = 0; i < loadSize && i < block->data.size(); ++i) {
            unsigned insertPos = i * 8;
            unsigned bitsToInsert = std::min(8u, parentWidth - insertPos);
            if (bitsToInsert > 0 && insertPos < parentWidth) {
              APInt byteVal(bitsToInsert,
                            block->data[blockOffset + i] &
                                ((1u << bitsToInsert) - 1));
              safeInsertBits(fullVal,byteVal, insertPos);
            }
          }

          // Extract the requested bit range (with bounds check)
          if (totalBitOffset + resultWidth <= parentWidth) {
            APInt extractedVal =
                fullVal.extractBits(resultWidth, totalBitOffset);
            setValue(procId, probeOp.getResult(),
                     InterpretedValue(extractedVal));
            LLVM_DEBUG(llvm::dbgs()
                       << "  Probe sig.extract memory: bits ["
                       << totalBitOffset << ":"
                       << (totalBitOffset + resultWidth)
                       << "] offset " << blockOffset
                       << " = " << extractedVal.getZExtValue() << "\n");
          } else {
            // Out-of-bounds bit extraction - return X
            setValue(procId, probeOp.getResult(),
                     InterpretedValue::makeX(resultWidth));
            LLVM_DEBUG(llvm::dbgs()
                       << "  Probe sig.extract memory: out-of-bounds bits ["
                       << totalBitOffset << ":"
                       << (totalBitOffset + resultWidth)
                       << "] parentWidth=" << parentWidth << "\n");
          }
          return success();
        }
      }

      // Check for signal-backed ref
      SignalId parentSigId = getSignalId(parentRef);
      if (parentSigId == 0)
        parentSigId = resolveSignalId(parentRef);

      if (parentSigId != 0) {
        const SignalValue &parentSV = scheduler.getSignalValue(parentSigId);
        InterpretedValue parentVal = InterpretedValue::fromSignalValue(parentSV);

        if (parentVal.isX() ||
            totalBitOffset + resultWidth > parentVal.getWidth()) {
          setValue(procId, probeOp.getResult(),
                  InterpretedValue::makeX(resultWidth));
        } else {
          APInt fullVal = parentVal.getAPInt();
          APInt extractedVal = fullVal.extractBits(resultWidth, totalBitOffset);
          setValue(procId, probeOp.getResult(), InterpretedValue(extractedVal));
        }
        return success();
      }

      // Handle memory-backed !llhd.ref (e.g., from GEP into a class object
      // via unrealized_conversion_cast). The runtime value of parentRef
      // contains the memory address.
      {
        InterpretedValue parentPtrVal = getValue(procId, parentRef);
        if (!parentPtrVal.isX() && parentPtrVal.getUInt64() != 0) {
          uint64_t addr = parentPtrVal.getUInt64();
          uint64_t blockOffset = 0;
          MemoryBlock *block =
              findMemoryBlockByAddress(addr, procId, &blockOffset);
          if (block) {
            unsigned parentWidth = getTypeWidth(parentRef.getType());
            unsigned loadSize = (parentWidth + 7) / 8;

            if (blockOffset + loadSize <= block->size) {
              if (!block->initialized) {
                setValue(procId, probeOp.getResult(),
                        InterpretedValue::makeX(resultWidth));
              } else {
                APInt fullVal = APInt::getZero(parentWidth);
                for (unsigned i = 0; i < loadSize; ++i) {
                  unsigned insertPos = i * 8;
                  unsigned bitsToInsert =
                      std::min(8u, parentWidth - insertPos);
                  if (bitsToInsert > 0 && insertPos < parentWidth) {
                    APInt byteVal(bitsToInsert,
                                  block->data[blockOffset + i] &
                                      ((1u << bitsToInsert) - 1));
                    safeInsertBits(fullVal,byteVal, insertPos);
                  }
                }
                if (totalBitOffset + resultWidth <= parentWidth) {
                  APInt extractedVal =
                      fullVal.extractBits(resultWidth, totalBitOffset);
                  setValue(procId, probeOp.getResult(),
                           InterpretedValue(extractedVal));
                } else {
                  setValue(procId, probeOp.getResult(),
                           InterpretedValue::makeX(resultWidth));
                }
              }
              LLVM_DEBUG(llvm::dbgs()
                         << "  Probe sig.extract memory-backed ref: bits ["
                         << totalBitOffset << ":"
                         << (totalBitOffset + resultWidth)
                         << "] at addr 0x"
                         << llvm::format_hex(addr, 0) << "\n");
              return success();
            }
          }
        }
      }

      LLVM_DEBUG(llvm::dbgs()
                 << "  Error: Could not resolve parent for sig.extract probe\n");
      return failure();
    }

    // Handle llhd.sig.array_get - probe an element within an array signal.
    // We need to read the parent signal and extract the relevant element bits.
    if (auto sigArrayGetOp = signal.getDefiningOp<llhd::SigArrayGetOp>()) {
      Value parentSignal = sigArrayGetOp.getInput();
      SignalId parentSigId = getSignalId(parentSignal);

      // If not found directly, try resolveSignalId
      if (parentSigId == 0) {
        parentSigId = resolveSignalId(parentSignal);
      }

      if (parentSigId == 0) {
        LLVM_DEBUG(llvm::dbgs()
                   << "  Error: Could not find parent signal for array get probe\n");
        return failure();
      }

      // Get the index value (may be dynamic)
      InterpretedValue indexVal = getValue(procId, sigArrayGetOp.getIndex());
      if (indexVal.isX()) {
        // X index - return X value
        unsigned width = getTypeWidth(probeOp.getResult().getType());
        setValue(procId, probeOp.getResult(), InterpretedValue::makeX(width));
        LLVM_DEBUG(llvm::dbgs() << "  Probe array element with X index\n");
        return success();
      }
      uint64_t index = indexVal.getUInt64();

      // Get the current value of the parent signal
      const SignalValue &parentSV = scheduler.getSignalValue(parentSigId);
      InterpretedValue parentVal = InterpretedValue::fromSignalValue(parentSV);

      // Get array element type and width
      auto arrayType = cast<hw::ArrayType>(unwrapSignalType(parentSignal.getType()));
      Type elementType = arrayType.getElementType();
      unsigned elementWidth = getTypeWidth(elementType);
      size_t numElements = arrayType.getNumElements();

      // Bounds check
      if (index >= numElements) {
        LLVM_DEBUG(llvm::dbgs() << "  Warning: Array index " << index
                                << " out of bounds (size " << numElements << ")\n");
        setValue(procId, probeOp.getResult(), InterpretedValue::makeX(elementWidth));
        return success();
      }

      // hw::ArrayType layout: element 0 at low bits, element N-1 at high bits
      unsigned bitOffset = index * elementWidth;

      // Extract the element value from the parent signal
      InterpretedValue elementVal;
      if (parentVal.isX()) {
        elementVal = InterpretedValue::makeX(elementWidth);
      } else {
        APInt parentBits = parentVal.getAPInt();
        APInt elementBits = parentBits.extractBits(elementWidth, bitOffset);
        elementVal = InterpretedValue(elementBits);
      }

      setValue(procId, probeOp.getResult(), elementVal);
      LLVM_DEBUG(llvm::dbgs()
                 << "  Probe array element[" << index << "] at offset " << bitOffset
                 << " width " << elementWidth << " from signal " << parentSigId
                 << " = " << (elementVal.isX() ? "X" : std::to_string(elementVal.getUInt64()))
                 << "\n");
      return success();
    }

    // Handle memory-backed ref arguments (e.g., !llhd.ref passed through
    // function calls). The interpreted value of the ref is the memory address.
    // This mirrors the same handling in interpretDrive.
    if (isa<BlockArgument>(signal) && isa<llhd::RefType>(signal.getType())) {
      InterpretedValue addrVal = getValue(procId, signal);
      unsigned width = getTypeWidth(probeOp.getResult().getType());
      unsigned loadSize = (width + 7) / 8;

      if (!addrVal.isX() && addrVal.getUInt64() != 0) {
        uint64_t addr = addrVal.getUInt64();
        // Use the comprehensive memory search that checks process-local
        // allocas, module-level allocas, malloc blocks, and globals.
        uint64_t offset = 0;
        MemoryBlock *block = findMemoryBlockByAddress(addr, procId, &offset);

        if (block && offset + loadSize <= block->size) {
          if (!block->initialized) {
            setValue(procId, probeOp.getResult(),
                     InterpretedValue::makeX(width));
            LLVM_DEBUG(llvm::dbgs()
                       << "  Probe of memory-backed ref at 0x"
                       << llvm::format_hex(addr, 16) << ": X (uninitialized)\n");
            return success();
          }

          APInt memValue = APInt::getZero(width);
          for (unsigned i = 0; i < loadSize && i * 8 < width; ++i) {
            unsigned bitsToInsert = std::min(8u, width - i * 8);
            APInt byteVal(bitsToInsert,
                          block->data[offset + i] &
                              ((1u << bitsToInsert) - 1));
            safeInsertBits(memValue,byteVal, i * 8);
          }

          setValue(procId, probeOp.getResult(), InterpretedValue(memValue));
          LLVM_DEBUG(llvm::dbgs()
                     << "  Probe of memory-backed ref at 0x"
                     << llvm::format_hex(addr, 16) << " offset " << offset
                     << " = 0x"
                     << llvm::format_hex(memValue.getZExtValue(), 0)
                     << " (width=" << width << ")\n");
          return success();
        }
      }

      // Address is X or 0 or memory not found - return X
      setValue(procId, probeOp.getResult(),
               InterpretedValue::makeX(getTypeWidth(probeOp.getResult().getType())));
      LLVM_DEBUG(llvm::dbgs()
                 << "  Probe of memory-backed ref: X (address unavailable)\n");
      return success();
    }

    LLVM_DEBUG(llvm::dbgs() << "  Error: Unknown signal in probe\n");
    return failure();
  }

  // First check for pending epsilon drives - this enables blocking assignment
  // semantics where a probe sees the value driven earlier in the same process.
  auto pendingIt = pendingEpsilonDrives.find(sigId);
  if (pendingIt != pendingEpsilonDrives.end()) {
    setValue(procId, probeOp.getResult(), pendingIt->second);
    LLVM_DEBUG(llvm::dbgs() << "  Probed signal " << sigId
                            << " = " << (pendingIt->second.isX() ? "X"
                                         : std::to_string(pendingIt->second.getUInt64()))
                            << " (from pending epsilon drive)\n");
    return success();
  }

  // Check for memory-backed signal values: when a signal is written via
  // llvm.store through an unrealized_conversion_cast (ref->ptr), the
  // scheduler's signal state is not updated. Read from memory instead.
  // Pattern: %ptr = unrealized_conversion_cast %sig : !llhd.ref<T> to !llvm.ptr
  //          llvm.store %val, %ptr          <- writes memory
  //          %result = llhd.prb %sig        <- should see the stored value
  {
    auto backingIt = signalBackingMemory.find(sigId);
    if (backingIt != signalBackingMemory.end()) {
      ProcessId backingProcId = backingIt->second.first;
      Value backingKey = backingIt->second.second;
      auto &st = processStates[backingProcId];
      auto blkIt = st.memoryBlocks.find(backingKey);
      if (blkIt != st.memoryBlocks.end()) {
        MemoryBlock &block = blkIt->second;
        unsigned width = getTypeWidth(probeOp.getResult().getType());
        unsigned loadSize = (width + 7) / 8;
        if (block.initialized && loadSize <= block.size) {
          APInt memValue = APInt::getZero(width);
          for (unsigned i = 0; i < loadSize && i * 8 < width; ++i) {
            unsigned bitsToInsert = std::min(8u, width - i * 8);
            APInt byteVal(
                bitsToInsert,
                block.data[i] & ((1u << bitsToInsert) - 1));
            safeInsertBits(memValue, byteVal, i * 8);
          }
          setValue(procId, probeOp.getResult(),
                   InterpretedValue(memValue));
          return success();
        }
      }
    }
  }
  for (auto *user : signal.getUsers()) {
    auto castOp = dyn_cast<mlir::UnrealizedConversionCastOp>(user);
    if (!castOp || castOp.getNumResults() != 1)
      continue;
    if (!isa<LLVM::LLVMPointerType>(castOp.getResult(0).getType()))
      continue;
    // Found a ref->ptr cast. Check if the ptr has store users (direct or
    // via block arguments that thread through the control flow).
    bool hasStoreUser = false;
    for (auto *castUser : castOp.getResult(0).getUsers()) {
      if (isa<LLVM::StoreOp>(castUser)) {
        hasStoreUser = true;
        break;
      }
    }
    if (!hasStoreUser)
      continue;
    // Read from the memory block at the cast pointer address
    InterpretedValue ptrVal = getValue(procId, castOp.getResult(0));
    if (ptrVal.isX())
      continue;
    uint64_t addr = ptrVal.getUInt64();
    if (addr == 0)
      continue;
    unsigned width = getTypeWidth(probeOp.getResult().getType());
    unsigned loadSize = (width + 7) / 8;
    uint64_t blockOffset = 0;
    MemoryBlock *block = findMemoryBlockByAddress(addr, procId, &blockOffset);
    if (!block || !block->initialized ||
        blockOffset + loadSize > block->size)
      continue;
    // Read the value from memory (little-endian byte order)
    APInt memValue = APInt::getZero(width);
    for (unsigned i = 0; i < loadSize && i * 8 < width; ++i) {
      unsigned bitsToInsert = std::min(8u, width - i * 8);
      APInt byteVal(bitsToInsert,
                    block->data[blockOffset + i] & ((1u << bitsToInsert) - 1));
      safeInsertBits(memValue, byteVal, i * 8);
    }
    setValue(procId, probeOp.getResult(), InterpretedValue(memValue));
    LLVM_DEBUG(llvm::dbgs() << "  Probed signal " << sigId
                            << " from memory at 0x"
                            << llvm::format_hex(addr, 0) << " = 0x"
                            << llvm::format_hex(memValue.getZExtValue(), 0)
                            << " (width=" << width << ")\n");
    return success();
  }

  // Get the current signal value from the scheduler
  const SignalValue &sigVal = scheduler.getSignalValue(sigId);

  // Convert to InterpretedValue and store
  InterpretedValue val;
  if (sigVal.isUnknown()) {
    if (auto encoded = getEncodedUnknownForType(probeOp.getResult().getType()))
      val = InterpretedValue(*encoded);
    else
      val = InterpretedValue::makeX(
          getTypeWidth(probeOp.getResult().getType()));
  } else {
    val = InterpretedValue::fromSignalValue(sigVal);
  }
  setValue(procId, probeOp.getResult(), val);

  LLVM_DEBUG(llvm::dbgs() << "  Probed signal " << sigId << " = "
                          << (sigVal.isUnknown() ? "X"
                                                  : std::to_string(sigVal.getValue()))
                          << "\n");

  return success();
}

LogicalResult LLHDProcessInterpreter::interpretDrive(ProcessId procId,
                                                      llhd::DriveOp driveOp) {
  auto *statePtr = (procId == activeProcessId && activeProcessState)
                       ? activeProcessState
                       : &processStates[procId];
  auto remapRefBlockArgSource = [&](Value &ref) {
    llvm::SmallVector<Value, 4> visited;
    while (auto arg = dyn_cast<BlockArgument>(ref)) {
      if (!isa<llhd::RefType>(arg.getType()))
        break;
      bool seen = false;
      for (Value visitedValue : visited) {
        if (visitedValue == ref) {
          seen = true;
          break;
        }
      }
      if (seen)
        break;
      visited.push_back(ref);

      auto srcIt = statePtr->refBlockArgSources.find(arg);
      if (srcIt != statePtr->refBlockArgSources.end() &&
          srcIt->second != ref) {
        ref = srcIt->second;
        continue;
      }

      Value mappedValue;
      InstanceId mappedInstance = activeInstanceId;
      if (lookupInputMapping(arg, mappedValue, mappedInstance) &&
          mappedValue != ref) {
        ScopedInstanceContext scope(*this, mappedInstance);
        ref = mappedValue;
        continue;
      }
      break;
    }
  };

  // Handle arith.select on ref types (e.g., !llhd.ref<!hw.struct<...>>)
  // by evaluating the condition and selecting the appropriate ref.
  Value signal = driveOp.getSignal();
  remapRefBlockArgSource(signal);
  while (auto selectOp = signal.getDefiningOp<arith::SelectOp>()) {
    InterpretedValue cond = getValue(procId, selectOp.getCondition());
    if (cond.isX()) {
      LLVM_DEBUG(llvm::dbgs() << "  Warning: X condition in arith.select for drive\n");
      return success(); // Cannot determine which signal to drive
    }
    signal = cond.getUInt64() != 0 ? selectOp.getTrueValue() : selectOp.getFalseValue();
    remapRefBlockArgSource(signal);
  }

  // Get the signal ID
  SignalId sigId = getSignalId(signal);
  // Force sigId to 0 for struct extract and array get operations so the
  // read-modify-write handlers inside the sigId==0 block are reached.
  // getSignalId() returns the parent signal ID for these ops (set during
  // signal registration), but we need the special handling path that reads
  // the parent, modifies the field/element, and writes back the full value.
  if (signal.getDefiningOp<llhd::SigStructExtractOp>() ||
      signal.getDefiningOp<llhd::SigArrayGetOp>()) {
    sigId = 0;
  }
  if (sigId == 0) {
    // Handle llhd.sig.extract on alloca-backed refs.
    // Pattern: %alloca -> cast to !llhd.ref<i32> -> sig.extract -> !llhd.ref<i1>
    // This is used in uvm_oneway_hash to manipulate individual bits of local vars.
    if (auto bitExtractOp = signal.getDefiningOp<llhd::SigExtractOp>()) {
      // Get the lowBit value
      InterpretedValue lowBitVal = getValue(procId, bitExtractOp.getLowBit());
      unsigned lowBit = lowBitVal.isX() ? 0 : lowBitVal.getUInt64();

      // Trace through to find the underlying alloca or signal
      Value parentRef = bitExtractOp.getInput();
      // Chase through nested SigExtractOps
      unsigned totalBitOffset = lowBit;
      while (auto nestedExtract = parentRef.getDefiningOp<llhd::SigExtractOp>()) {
        InterpretedValue nestedLowBit =
            getValue(procId, nestedExtract.getLowBit());
        totalBitOffset += nestedLowBit.isX() ? 0 : nestedLowBit.getUInt64();
        parentRef = nestedExtract.getInput();
      }

      // Chase through sig.array_get and sig.struct_extract to accumulate
      // bit offsets. This handles the BFM pattern:
      //   sig.extract -> sig.array_get -> sig.struct_extract -> signal
      // used when driving individual bits of struct array fields.
      while (true) {
        if (auto sigArrayGet =
                parentRef.getDefiningOp<llhd::SigArrayGetOp>()) {
          InterpretedValue idxVal =
              getValue(procId, sigArrayGet.getIndex());
          uint64_t idx = idxVal.isX() ? 0 : idxVal.getUInt64();
          auto arrayType = cast<hw::ArrayType>(
              unwrapSignalType(sigArrayGet.getInput().getType()));
          unsigned elemWidth = getTypeWidth(arrayType.getElementType());
          totalBitOffset += idx * elemWidth;
          parentRef = sigArrayGet.getInput();
          continue;
        }
        if (auto structExtract =
                parentRef.getDefiningOp<llhd::SigStructExtractOp>()) {
          auto structType = cast<hw::StructType>(
              unwrapSignalType(structExtract.getInput().getType()));
          StringRef fieldName = structExtract.getFieldAttr().getValue();
          unsigned fieldBitOff = 0;
          for (auto field : structType.getElements()) {
            if (field.name == fieldName)
              break;
            fieldBitOff += getTypeWidth(field.type);
          }
          totalBitOffset += fieldBitOff;
          parentRef = structExtract.getInput();
          continue;
        }
        break;
      }

      // Now parentRef should be from UnrealizedConversionCastOp -> AllocaOp
      if (auto castOp =
              parentRef.getDefiningOp<mlir::UnrealizedConversionCastOp>()) {
        if (castOp.getInputs().size() == 1) {
          Value input = castOp.getInputs()[0];
          // Find memory block - try alloca first, then address-based lookup.
          // This handles both alloca-backed refs (local variables) and
          // GEP-backed refs (class properties like JTAG coverage fields).
          InterpretedValue driveVal = getValue(procId, driveOp.getValue());
          MemoryBlock *block = nullptr;
          uint64_t blockOffset = 0;

          if (auto allocaOp = input.getDefiningOp<LLVM::AllocaOp>()) {
            block = findMemoryBlock(procId, allocaOp);
            if (!block) {
              auto &state = processStates[procId];
              auto it = state.memoryBlocks.find(allocaOp.getResult());
              if (it != state.memoryBlocks.end())
                block = &it->second;
            }
          }

          // Fallback: use address-based lookup for GEP and other pointers
          if (!block) {
            InterpretedValue ptrVal = getValue(procId, input);
            if (!ptrVal.isX() && ptrVal.getUInt64() != 0) {
              block = findMemoryBlockByAddress(ptrVal.getUInt64(), procId,
                                               &blockOffset);
            }
          }

          if (!block) {
            LLVM_DEBUG(llvm::dbgs()
                       << "  Drive to sig.extract failed - "
                          "memory not found\n");
            return failure();
          }

          // Read-modify-write: read parent value, modify bits, write back
          unsigned parentWidth = getTypeWidth(parentRef.getType());
          unsigned storeSize = (parentWidth + 7) / 8;

          if (blockOffset + storeSize > block->size) {
            LLVM_DEBUG(llvm::dbgs()
                       << "  Drive to sig.extract: out of bounds\n");
            return failure();
          }

          // Read current value from memory
          APInt currentVal = APInt::getZero(parentWidth);
          for (unsigned i = 0; i < storeSize && i < block->data.size();
               ++i) {
            unsigned insertPos = i * 8;
            unsigned bitsToInsert = std::min(8u, parentWidth - insertPos);
            if (bitsToInsert > 0 && insertPos < parentWidth) {
              APInt byteVal(bitsToInsert,
                            block->data[blockOffset + i] &
                                ((1u << bitsToInsert) - 1));
              safeInsertBits(currentVal,byteVal, insertPos);
            }
          }

          // Insert the drive value at the bit offset.
          // Treat X as 0 (consistent with SigStructExtractOp handler)
          // rather than silently skipping the write.
          unsigned extractWidth = driveVal.getWidth();
          if (totalBitOffset + extractWidth <= parentWidth) {
            APInt insertVal = driveVal.isX()
                                  ? APInt::getZero(extractWidth)
                                  : driveVal.getAPInt();
            if (insertVal.getBitWidth() != extractWidth)
              insertVal = insertVal.zextOrTrunc(extractWidth);
            safeInsertBits(currentVal, insertVal, totalBitOffset);
          }

          // Write back to memory
          for (unsigned i = 0; i < storeSize; ++i) {
            unsigned extractPos = i * 8;
            unsigned bitsToExtract = std::min(8u, parentWidth - extractPos);
            if (bitsToExtract > 0 && extractPos < parentWidth) {
              block->data[blockOffset + i] = static_cast<uint8_t>(
                  currentVal.extractBits(bitsToExtract, extractPos)
                      .getZExtValue());
            }
          }
          block->initialized = true;

          LLVM_DEBUG(llvm::dbgs()
                     << "  Drive to sig.extract memory: bit " << totalBitOffset
                     << " offset " << blockOffset << " = "
                     << (driveVal.isX() ? "X"
                                        : std::to_string(driveVal.getUInt64()))
                     << "\n");
          return success();
        }
      }

      // Remap function block-argument refs so the signal ID lookup below
      // can trace through to the caller's operand.  Without this, drives
      // inside functions called from fork children fail because the block
      // argument isn't in valueToSignal.
      remapRefBlockArgSource(parentRef);

      // Check if the parent has a signal ID (for actual signal bit extracts)
      SignalId parentSigId = getSignalId(parentRef);
      if (parentSigId == 0)
        parentSigId = resolveSignalId(parentRef);

      if (parentSigId != 0) {
        // Drive to a bit range within an actual signal - use read-modify-write
        InterpretedValue driveVal = getValue(procId, driveOp.getValue());

        const SignalValue &parentSV = scheduler.getSignalValue(parentSigId);
        InterpretedValue parentVal = InterpretedValue::fromSignalValue(parentSV);
        unsigned parentWidth = parentVal.getWidth();

        APInt result = parentVal.isX() ? APInt::getZero(parentWidth)
                                       : parentVal.getAPInt();

        unsigned extractWidth = driveVal.getWidth();
        if (!driveVal.isX() &&
            totalBitOffset + extractWidth <= parentWidth) {
          APInt insertVal = driveVal.getAPInt();
          if (insertVal.getBitWidth() != extractWidth)
            insertVal = insertVal.zextOrTrunc(extractWidth);
          safeInsertBits(result,insertVal, totalBitOffset);
        }

        // Schedule the signal update
        SimTime delay = convertTimeValue(procId, driveOp.getTime());
        SimTime currentTime = scheduler.getCurrentTime();
        SimTime targetTime = currentTime.advanceTime(delay.realTime);
        if (delay.deltaStep > 0)
          targetTime.deltaStep = delay.deltaStep;

        uint64_t driverId = (static_cast<uint64_t>(procId) << 32) |
                            static_cast<uint64_t>(parentSigId);

        SignalValue newVal(result);
        scheduler.getEventScheduler().schedule(
            targetTime, SchedulingRegion::NBA,
            Event([this, parentSigId, driverId, newVal]() {
              scheduler.updateSignalWithStrength(parentSigId, driverId, newVal,
                                                 DriveStrength::Strong,
                                                 DriveStrength::Strong);
            }));

        return success();
      }

      // Handle memory-backed !llhd.ref (e.g., from GEP into a class object
      // via unrealized_conversion_cast). The runtime value of parentRef
      // contains the memory address. Do read-modify-write at the bit offset.
      {
        InterpretedValue parentPtrVal = getValue(procId, parentRef);
        if (!parentPtrVal.isX() && parentPtrVal.getUInt64() != 0) {
          uint64_t addr = parentPtrVal.getUInt64();
          uint64_t blockOffset = 0;
          MemoryBlock *block =
              findMemoryBlockByAddress(addr, procId, &blockOffset);
          if (block) {
            InterpretedValue driveVal = getValue(procId, driveOp.getValue());
            unsigned parentWidth = getTypeWidth(parentRef.getType());
            unsigned storeSize = (parentWidth + 7) / 8;

            if (blockOffset + storeSize <= block->size) {
              // Read current value from memory
              APInt currentVal = APInt::getZero(parentWidth);
              for (unsigned i = 0; i < storeSize; ++i) {
                unsigned insertPos = i * 8;
                unsigned bitsToInsert =
                    std::min(8u, parentWidth - insertPos);
                if (bitsToInsert > 0 && insertPos < parentWidth) {
                  APInt byteVal(bitsToInsert,
                                block->data[blockOffset + i] &
                                    ((1u << bitsToInsert) - 1));
                  safeInsertBits(currentVal,byteVal, insertPos);
                }
              }

              // Insert drive value at the bit offset
              unsigned extractWidth = driveVal.getWidth();
              if (!driveVal.isX() &&
                  totalBitOffset + extractWidth <= parentWidth) {
                APInt insertVal = driveVal.getAPInt();
                if (insertVal.getBitWidth() != extractWidth)
                  insertVal = insertVal.zextOrTrunc(extractWidth);
                safeInsertBits(currentVal,insertVal, totalBitOffset);
              }

              // Write back to memory
              for (unsigned i = 0; i < storeSize; ++i) {
                unsigned extractPos = i * 8;
                unsigned bitsToExtract =
                    std::min(8u, parentWidth - extractPos);
                if (bitsToExtract > 0 && extractPos < parentWidth) {
                  block->data[blockOffset + i] = static_cast<uint8_t>(
                      currentVal.extractBits(bitsToExtract, extractPos)
                          .getZExtValue());
                } else {
                  block->data[blockOffset + i] = 0;
                }
              }
              block->initialized = !driveVal.isX();

              LLVM_DEBUG(llvm::dbgs()
                         << "  Drive to sig.extract memory-backed ref: bit "
                         << totalBitOffset << " at addr 0x"
                         << llvm::format_hex(addr, 0) << "\n");
              return success();
            }
          }
        }
      }

      LLVM_DEBUG(llvm::dbgs()
                 << "  Drive to sig.extract failed - could not resolve ref\n");
      return failure();
    }

    // Check if this is a local variable access via UnrealizedConversionCastOp
    // This happens when local variables in functions are accessed - they're
    // backed by llvm.alloca and cast to !llhd.ref, not actual LLHD signals.
    if (auto castOp = signal.getDefiningOp<mlir::UnrealizedConversionCastOp>()) {
      if (castOp.getInputs().size() == 1) {
        Value input = castOp.getInputs()[0];

        // Handle AllocaOp - local variables backed by llvm.alloca
        if (auto allocaOp = input.getDefiningOp<LLVM::AllocaOp>()) {
          // Get the value to drive
          InterpretedValue driveVal = getValue(procId, driveOp.getValue());

          // Find the memory block for this alloca
          MemoryBlock *block = findMemoryBlock(procId, allocaOp);
          if (!block) {
            // Try finding by alloca result in process-local memory blocks
            auto &state = processStates[procId];
            auto it = state.memoryBlocks.find(allocaOp.getResult());
            if (it != state.memoryBlocks.end()) {
              block = &it->second;
              LLVM_DEBUG(llvm::dbgs() << "  Drive: found local alloca memory\n");
            }
          }

          if (!block) {
            LLVM_DEBUG(llvm::dbgs() << "  Drive to alloca failed - memory not found\n");
            return failure();
          }

          unsigned width = driveVal.getWidth();
          unsigned storeSize = (width + 7) / 8;

          if (storeSize > block->size) {
            LLVM_DEBUG(llvm::dbgs()
                       << "  Drive: out of bounds (size=" << storeSize
                       << " block=" << block->size << ")\n");
            return failure();
          }

          // Write the value to memory
          if (driveVal.isX()) {
            // Write X pattern (all 1s as marker)
            std::fill(block->data.begin(), block->data.begin() + storeSize, 0xFF);
            block->initialized = false;
          } else {
            uint64_t value = driveVal.getUInt64();
            for (unsigned i = 0; i < storeSize; ++i) {
              block->data[i] = (value >> (i * 8)) & 0xFF;
            }
            block->initialized = true;
          }

          LLVM_DEBUG(llvm::dbgs()
                     << "  Drive to alloca: "
                     << (driveVal.isX() ? "X" : std::to_string(driveVal.getUInt64()))
                     << " (width=" << width << ")\n");
          return success();
        }

        // Handle GEP-based memory access (class member fields).
        // This happens when class properties are driven via
        // unrealized_conversion_cast from a GEP pointer to !llhd.ref.
        // Mirrors the probe handler at interpretProbe.
        if (auto gepOp = input.getDefiningOp<LLVM::GEPOp>()) {
          InterpretedValue ptrVal = getValue(procId, gepOp.getResult());
          InterpretedValue driveVal = getValue(procId, driveOp.getValue());
          auto refType = cast<llhd::RefType>(signal.getType());
          unsigned width = getTypeWidth(refType.getNestedType());
          unsigned storeSize = (width + 7) / 8;

          if (ptrVal.isX()) {
            LLVM_DEBUG(llvm::dbgs()
                       << "  Drive to GEP pointer: X (uninitialized)\n");
            return success();
          }

          uint64_t addr = ptrVal.getUInt64();
          uint64_t offset = 0;
          MemoryBlock *block = findMemoryBlock(procId, gepOp);

          if (block) {
            InterpretedValue baseVal = getValue(procId, gepOp.getBase());
            if (!baseVal.isX())
              offset = addr - baseVal.getUInt64();
          } else {
            // Check global and malloc memory via O(log n) range index
            block = findBlockByAddress(addr, offset);
          }

          if (block && offset + storeSize <= block->size) {
            if (driveVal.isX()) {
              for (unsigned i = 0; i < storeSize; ++i)
                block->data[offset + i] = 0xFF;
            } else {
              APInt val = driveVal.getAPInt();
              if (val.getBitWidth() < width)
                val = val.zext(width);
              else if (val.getBitWidth() > width)
                val = val.trunc(width);
              for (unsigned i = 0; i < storeSize; ++i) {
                unsigned bitPos = i * 8;
                unsigned bitsToWrite = std::min(8u, width - bitPos);
                if (bitsToWrite > 0 && bitPos < width)
                  block->data[offset + i] =
                      val.extractBits(bitsToWrite, bitPos).getZExtValue();
                else
                  block->data[offset + i] = 0;
              }
            }
            block->initialized = !driveVal.isX();

            LLVM_DEBUG(llvm::dbgs()
                       << "  Drive to GEP memory at 0x"
                       << llvm::format_hex(addr, 16) << " offset " << offset
                       << " width " << width << "\n");
            return success();
          }

          LLVM_DEBUG(llvm::dbgs()
                     << "  Drive to GEP pointer 0x"
                     << llvm::format_hex(addr, 0)
                     << " failed - memory not found\n");
          // Fall through to other handlers
        }

        // Handle addressof-based global variable access.
        // This happens when static class properties are driven via
        // unrealized_conversion_cast from addressof to !llhd.ref.
        if (auto addrOfOp = input.getDefiningOp<LLVM::AddressOfOp>()) {
          StringRef globalName = addrOfOp.getGlobalName();
          InterpretedValue driveVal = getValue(procId, driveOp.getValue());
          auto refType = cast<llhd::RefType>(signal.getType());
          unsigned width = getTypeWidth(refType.getNestedType());
          unsigned storeSize = (width + 7) / 8;

          auto blockIt = globalMemoryBlocks.find(globalName);
          if (blockIt != globalMemoryBlocks.end()) {
            MemoryBlock &block = blockIt->second;
            if (storeSize <= block.size) {
              if (driveVal.isX()) {
                for (unsigned i = 0; i < storeSize; ++i)
                  block.data[i] = 0xFF;
                block.initialized = false;
              } else {
                APInt val = driveVal.getAPInt();
                if (val.getBitWidth() < width)
                  val = val.zext(width);
                else if (val.getBitWidth() > width)
                  val = val.trunc(width);
                for (unsigned i = 0; i < storeSize; ++i) {
                  unsigned bitPos = i * 8;
                  unsigned bitsToWrite = std::min(8u, width - bitPos);
                  if (bitsToWrite > 0 && bitPos < width)
                    block.data[i] =
                        val.extractBits(bitsToWrite, bitPos).getZExtValue();
                  else
                    block.data[i] = 0;
                }
                block.initialized = true;
              }

              LLVM_DEBUG(llvm::dbgs()
                         << "  Drive to global '" << globalName << "' width "
                         << width << "\n");
              return success();
            }
          }
          LLVM_DEBUG(llvm::dbgs()
                     << "  Drive to global '" << globalName
                     << "' failed - memory not found\n");
          // Fall through
        }
      }
    }

    // Handle llhd.sig.struct_extract - drive to a field within a struct signal.
    // We need to read-modify-write the parent signal.
    if (auto sigExtractOp = signal.getDefiningOp<llhd::SigStructExtractOp>()) {
      // Find the parent signal ID by tracing through nested extracts
      Value parentSignal = sigExtractOp.getInput();
      SignalId parentSigId = getSignalId(parentSignal);

      // Handle nested struct extracts by tracing to the root signal
      llvm::SmallVector<llhd::SigStructExtractOp, 4> extractChain;
      extractChain.push_back(sigExtractOp);

      while (parentSigId == 0) {
        if (auto nestedExtract =
                parentSignal.getDefiningOp<llhd::SigStructExtractOp>()) {
          extractChain.push_back(nestedExtract);
          parentSignal = nestedExtract.getInput();
          parentSigId = getSignalId(parentSignal);
        } else {
          break;
        }
      }

      // Remap function block-argument refs to their caller operands.
      if (parentSigId == 0)
        remapRefBlockArgSource(parentSignal);

      // If still not found, try resolveSignalId which handles more cases
      // like tracing through UnrealizedConversionCastOp, block arguments, etc.
      if (parentSigId == 0) {
        parentSigId = getSignalId(parentSignal);
      }
      if (parentSigId == 0) {
        parentSigId = resolveSignalId(parentSignal);
      }

      // Check if the parent is actually a memory location (llvm.alloca via cast)
      // rather than an actual LLHD signal. This happens in combinational blocks
      // where structs are built up by driving individual fields.
      if (parentSigId == 0) {
        if (auto castOp =
                parentSignal.getDefiningOp<mlir::UnrealizedConversionCastOp>()) {
          if (castOp.getInputs().size() == 1) {
            Value input = castOp.getInputs()[0];
            if (auto allocaOp = input.getDefiningOp<LLVM::AllocaOp>()) {
              // This is a drive to a field within a memory-backed struct.
              // We need to do a read-modify-write of the memory block.

              // Get the value to drive
              InterpretedValue driveVal = getValue(procId, driveOp.getValue());

              // Find the memory block for this alloca
              MemoryBlock *block = findMemoryBlock(procId, allocaOp);
              if (!block) {
                auto &state = processStates[procId];
                auto it = state.memoryBlocks.find(allocaOp.getResult());
                if (it != state.memoryBlocks.end()) {
                  block = &it->second;
                }
              }

              if (!block) {
                LLVM_DEBUG(llvm::dbgs()
                           << "  Drive to struct field in alloca failed - "
                              "memory not found\n");
                return failure();
              }

              // Compute the bit offset by walking the extract chain in reverse.
              // For memory-backed structs (LLVM alloca), we use LLVM layout
              // where fields are at low-to-high bits (field 0 at bit 0).
              unsigned bitOffset = 0;
              Type currentType = parentSignal.getType();
              if (auto refType = dyn_cast<llhd::RefType>(currentType))
                currentType = refType.getNestedType();

              for (auto it = extractChain.rbegin(); it != extractChain.rend();
                   ++it) {
                auto extractOp = *it;
                auto structType = cast<hw::StructType>(currentType);
                auto elements = structType.getElements();
                StringRef fieldName = extractOp.getField();

                auto fieldIndexOpt = structType.getFieldIndex(fieldName);
                if (!fieldIndexOpt) {
                  LLVM_DEBUG(llvm::dbgs()
                             << "  Error: Field not found: " << fieldName
                             << "\n");
                  return failure();
                }
                unsigned fieldIndex = *fieldIndexOpt;

                // For LLVM struct layout: fields are at low-to-high bits.
                // Field 0 starts at bit 0, field 1 starts after field 0, etc.
                unsigned fieldOffset = 0;
                for (size_t i = 0; i < fieldIndex; ++i)
                  fieldOffset += getTypeWidth(elements[i].type);

                bitOffset += fieldOffset;
                currentType = elements[fieldIndex].type;
              }

              unsigned fieldWidth = getTypeWidth(currentType);
              unsigned parentWidth = getTypeWidth(parentSignal.getType());
              unsigned storeSize = (parentWidth + 7) / 8;

              if (storeSize > block->size) {
                LLVM_DEBUG(llvm::dbgs()
                           << "  Drive to struct field in alloca: out of bounds\n");
                return failure();
              }

              // Read the current value from memory
              APInt currentVal = APInt::getZero(parentWidth);
              for (unsigned i = 0; i < storeSize && i < block->data.size();
                   ++i) {
                unsigned insertPos = i * 8;
                unsigned bitsToInsert = std::min(8u, parentWidth - insertPos);
                if (bitsToInsert > 0 && insertPos < parentWidth) {
                  APInt byteVal(bitsToInsert,
                                block->data[i] & ((1u << bitsToInsert) - 1));
                  safeInsertBits(currentVal,byteVal, insertPos);
                }
              }

              // Insert the new field value at the computed bit offset.
              // The drive value is in HW layout, but the alloca stores
              // in LLVM layout. Convert if the field is a struct/array.
              APInt fieldValue = driveVal.isX() ? APInt::getZero(fieldWidth)
                                                : driveVal.getAPInt();
              if (!driveVal.isX() &&
                  isa<hw::StructType, hw::ArrayType>(currentType)) {
                // Find the corresponding LLVM type for conversion
                Type hwFieldType = currentType;
                Type llvmFieldType;
                // Try to get the LLVM type from the alloca's original type
                if (auto allocaPtrType =
                        dyn_cast<LLVM::LLVMPointerType>(allocaOp.getType())) {
                  // The alloca elem type corresponds to the parent signal type
                  // We need to find the LLVM field type at the same position
                  Type allocElemType = allocaOp.getElemType();
                  if (allocElemType) {
                    Type curLLVM = allocElemType;
                    for (auto it2 = extractChain.rbegin();
                         it2 != extractChain.rend(); ++it2) {
                      auto extractOp2 = *it2;
                      Type rawType =
                          it2 == extractChain.rbegin()
                              ? parentSignal.getType()
                              : (*(it2 - 1))->getResult(0).getType();
                      // Unwrap RefType if present
                      Type refInner = rawType;
                      if (auto refT = dyn_cast<llhd::RefType>(rawType))
                        refInner = refT.getNestedType();
                      auto hwST = dyn_cast<hw::StructType>(refInner);
                      if (!hwST) break;
                      auto fidx = hwST.getFieldIndex(extractOp2.getField());
                      if (!fidx) break;
                      if (auto llvmST = dyn_cast<LLVM::LLVMStructType>(curLLVM)) {
                        auto body = llvmST.getBody();
                        if (*fidx < body.size())
                          curLLVM = body[*fidx];
                        else
                          break;
                      } else {
                        break;
                      }
                    }
                    llvmFieldType = curLLVM;
                  }
                }
                if (llvmFieldType &&
                    isa<LLVM::LLVMStructType, LLVM::LLVMArrayType>(llvmFieldType)) {
                  fieldValue = convertHWToLLVMLayout(fieldValue, hwFieldType,
                                                     llvmFieldType);
                } else {
                  fieldValue =
                      convertHWToLLVMLayoutByHWType(fieldValue, hwFieldType);
                }
              }
              if (fieldValue.getBitWidth() < fieldWidth)
                fieldValue = fieldValue.zext(fieldWidth);
              else if (fieldValue.getBitWidth() > fieldWidth)
                fieldValue = fieldValue.trunc(fieldWidth);

              safeInsertBits(currentVal,fieldValue, bitOffset);

              // Write the modified value back to memory
              for (unsigned i = 0; i < storeSize; ++i) {
                unsigned extractPos = i * 8;
                unsigned bitsToExtract =
                    std::min(8u, parentWidth - extractPos);
                if (bitsToExtract > 0 && extractPos < parentWidth) {
                  block->data[i] =
                      currentVal.extractBits(bitsToExtract, extractPos)
                          .getZExtValue();
                } else {
                  block->data[i] = 0;
                }
              }
              block->initialized = !driveVal.isX();

              LLVM_DEBUG(llvm::dbgs()
                         << "  Drive to struct field in alloca at offset "
                         << bitOffset << " width " << fieldWidth << "\n");
              return success();
            }
          }
        }
      }

      // Handle memory-backed !llhd.ref passed as function argument or through
      // other indirect paths. The runtime value contains the alloca address.
      if (parentSigId == 0) {
        InterpretedValue parentPtrVal = getValue(procId, parentSignal);
        if (!parentPtrVal.isX() && parentPtrVal.getUInt64() != 0) {
          uint64_t addr = parentPtrVal.getUInt64();
          uint64_t blockOffset = 0;
          MemoryBlock *block =
              findMemoryBlockByAddress(addr, procId, &blockOffset);
          if (block) {
            InterpretedValue driveVal = getValue(procId, driveOp.getValue());

            // Compute field bit offset using LLVM layout (low-to-high bits).
            unsigned bitOffset = 0;
            Type currentType = parentSignal.getType();
            if (auto refType = dyn_cast<llhd::RefType>(currentType))
              currentType = refType.getNestedType();

            for (auto it = extractChain.rbegin(); it != extractChain.rend();
                 ++it) {
              auto extractOp = *it;
              auto structType = cast<hw::StructType>(currentType);
              auto elements = structType.getElements();
              StringRef fieldName = extractOp.getField();
              auto fieldIndexOpt = structType.getFieldIndex(fieldName);
              if (!fieldIndexOpt)
                return failure();
              unsigned fieldIndex = *fieldIndexOpt;
              unsigned fieldOff = 0;
              for (size_t i = 0; i < fieldIndex; ++i)
                fieldOff += getTypeWidth(elements[i].type);
              bitOffset += fieldOff;
              currentType = elements[fieldIndex].type;
            }

            unsigned fieldWidth = getTypeWidth(currentType);
            unsigned parentWidth = getTypeWidth(parentSignal.getType());
            unsigned storeSize = (parentWidth + 7) / 8;

            if (blockOffset + storeSize <= block->size) {
              // Read current parent value from memory
              APInt currentVal = APInt::getZero(parentWidth);
              for (unsigned i = 0; i < storeSize; ++i) {
                unsigned insertPos = i * 8;
                unsigned bitsToInsert =
                    std::min(8u, parentWidth - insertPos);
                if (bitsToInsert > 0 && insertPos < parentWidth) {
                  APInt byteVal(bitsToInsert,
                                block->data[blockOffset + i] &
                                    ((1u << bitsToInsert) - 1));
                  safeInsertBits(currentVal,byteVal, insertPos);
                }
              }

              // Insert the new field value
              APInt fieldValue = driveVal.isX()
                                     ? APInt::getZero(fieldWidth)
                                     : driveVal.getAPInt();
              if (!driveVal.isX() &&
                  isa<hw::StructType, hw::ArrayType>(currentType))
                fieldValue =
                    convertHWToLLVMLayoutByHWType(fieldValue, currentType);
              if (fieldValue.getBitWidth() < fieldWidth)
                fieldValue = fieldValue.zext(fieldWidth);
              else if (fieldValue.getBitWidth() > fieldWidth)
                fieldValue = fieldValue.trunc(fieldWidth);

              safeInsertBits(currentVal,fieldValue, bitOffset);

              // Write back to memory
              for (unsigned i = 0; i < storeSize; ++i) {
                unsigned extractPos = i * 8;
                unsigned bitsToExtract =
                    std::min(8u, parentWidth - extractPos);
                if (bitsToExtract > 0 && extractPos < parentWidth) {
                  block->data[blockOffset + i] =
                      currentVal.extractBits(bitsToExtract, extractPos)
                          .getZExtValue();
                } else {
                  block->data[blockOffset + i] = 0;
                }
              }
              block->initialized = !driveVal.isX();

              LLVM_DEBUG(llvm::dbgs()
                         << "  Drive to struct field in memory-backed ref at "
                            "offset "
                         << bitOffset << " width " << fieldWidth << "\n");
              return success();
            }
          }
        }
      }

      if (parentSigId == 0) {
        LLVM_DEBUG(llvm::dbgs()
                   << "  Error: Could not find parent signal for struct extract\n");
        return failure();
      }

      // Get the value to drive
      InterpretedValue driveVal = getValue(procId, driveOp.getValue());

      // Get the current value of the parent signal, checking pending epsilon
      // drives first so that multiple struct field drives in the same process
      // accumulate correctly (e.g., s.a=1; s.b=2; $display(s)).
      InterpretedValue parentVal;
      auto pendingIt = pendingEpsilonDrives.find(parentSigId);
      if (pendingIt != pendingEpsilonDrives.end()) {
        parentVal = pendingIt->second;
      } else {
        const SignalValue &parentSV = scheduler.getSignalValue(parentSigId);
        parentVal = InterpretedValue::fromSignalValue(parentSV);
      }

      // If parent is X, we can still drive a field (result will be X except for
      // the driven field)
      unsigned parentWidth = parentVal.getWidth();
      APInt result = parentVal.isX() ? APInt::getZero(parentWidth)
                                     : parentVal.getAPInt();

      // Compute the bit offset by walking the extract chain in reverse
      // (from root signal to the target field)
      unsigned bitOffset = 0;
      Type currentType = parentSignal.getType();
      if (auto refType = dyn_cast<llhd::RefType>(currentType))
        currentType = refType.getNestedType();

      for (auto it = extractChain.rbegin(); it != extractChain.rend(); ++it) {
        auto extractOp = *it;
        auto structType = cast<hw::StructType>(currentType);
        auto elements = structType.getElements();
        StringRef fieldName = extractOp.getField();

        auto fieldIndexOpt = structType.getFieldIndex(fieldName);
        if (!fieldIndexOpt) {
          LLVM_DEBUG(llvm::dbgs() << "  Error: Field not found: " << fieldName
                                  << "\n");
          return failure();
        }
        unsigned fieldIndex = *fieldIndexOpt;

        // Fields are laid out from high bits to low bits
        // Calculate offset from the low bit of the current struct
        unsigned fieldOffset = 0;
        for (size_t i = fieldIndex + 1; i < elements.size(); ++i)
          fieldOffset += getTypeWidth(elements[i].type);

        bitOffset += fieldOffset;
        currentType = elements[fieldIndex].type;
      }

      unsigned fieldWidth = getTypeWidth(currentType);

      // Insert the new value at the computed bit offset
      APInt fieldValue = driveVal.isX() ? APInt::getZero(fieldWidth)
                                        : driveVal.getAPInt();
      if (fieldValue.getBitWidth() < fieldWidth)
        fieldValue = fieldValue.zext(fieldWidth);
      else if (fieldValue.getBitWidth() > fieldWidth)
        fieldValue = fieldValue.trunc(fieldWidth);

      safeInsertBits(result,fieldValue, bitOffset);

      // Get the delay time
      SimTime delay = convertTimeValue(procId, driveOp.getTime());
      SimTime currentTime = scheduler.getCurrentTime();
      SimTime targetTime = currentTime.advanceTime(delay.realTime);
      if (delay.deltaStep > 0)
        targetTime.deltaStep = delay.deltaStep;

      // Use the same driver ID scheme
      uint64_t driverId = (static_cast<uint64_t>(procId) << 32) |
                          static_cast<uint64_t>(parentSigId);

      LLVM_DEBUG(llvm::dbgs()
                 << "  Drive to struct field at offset " << bitOffset
                 << " width " << fieldWidth << " in signal " << parentSigId
                 << "\n");

      // Schedule the signal update
      SignalValue newVal(result);
      scheduler.getEventScheduler().schedule(
          targetTime, SchedulingRegion::NBA,
          Event([this, parentSigId, driverId, newVal]() {
            scheduler.updateSignalWithStrength(parentSigId, driverId, newVal,
                                               DriveStrength::Strong,
                                               DriveStrength::Strong);
          }));

      // For epsilon/zero delays, store in pending drives for immediate reads.
      // This enables blocking assignment semantics for struct field writes:
      // s.a=1; s.b=2; $display(s) should see {1,2} not {0,0}.
      if (delay.realTime == 0 && delay.deltaStep <= 1) {
        pendingEpsilonDrives[parentSigId] = InterpretedValue(result);
        scheduler.updateSignal(parentSigId, newVal);
      }

      return success();
    }

    // Handle llhd.sig.array_get - drive to an element within an array signal.
    // We need to read-modify-write the parent signal.
    if (auto sigArrayGetOp = signal.getDefiningOp<llhd::SigArrayGetOp>()) {
      Value parentSignal = sigArrayGetOp.getInput();
      SignalId parentSigId = getSignalId(parentSignal);

      // If not found directly, try resolveSignalId
      if (parentSigId == 0) {
        parentSigId = resolveSignalId(parentSignal);
      }

      // Check if the parent is a memory-backed array (llvm.alloca or malloc via cast)
      if (parentSigId == 0) {
        if (auto castOp =
                parentSignal.getDefiningOp<mlir::UnrealizedConversionCastOp>()) {
          if (castOp.getInputs().size() == 1) {
            Value input = castOp.getInputs()[0];

            // Get the index value (may be dynamic)
            InterpretedValue indexVal = getValue(procId, sigArrayGetOp.getIndex());
            if (indexVal.isX()) {
              LLVM_DEBUG(llvm::dbgs() << "  Warning: X index in array drive\n");
              return success(); // Don't drive with X index
            }
            uint64_t index = indexVal.getUInt64();

            // Get array element type and width
            auto arrayType = cast<hw::ArrayType>(unwrapSignalType(parentSignal.getType()));
            Type elementType = arrayType.getElementType();
            unsigned elementWidth = getTypeWidth(elementType);
            size_t numElements = arrayType.getNumElements();

            // Bounds check
            if (index >= numElements) {
              LLVM_DEBUG(llvm::dbgs() << "  Warning: Array index " << index
                                      << " out of bounds (size " << numElements << ")\n");
              return success();
            }

            // Get the value to drive
            InterpretedValue driveVal = getValue(procId, driveOp.getValue());

            // Try to find the memory block - could be from pointer value
            InterpretedValue ptrVal = getValue(procId, input);
            if (!ptrVal.isX()) {
              uint64_t baseAddr = ptrVal.getUInt64();
              MemoryBlock *block = nullptr;
              uint64_t baseOffset = 0;

              // Check global and malloc blocks via O(log n) range index
              block = findBlockByAddress(baseAddr, baseOffset);

              if (block) {
                // Calculate byte offset for the element
                unsigned elementByteWidth = (elementWidth + 7) / 8;
                uint64_t elementOffset = baseOffset + index * elementByteWidth;

                if (elementOffset + elementByteWidth <= block->size) {
                  // Write the element value to memory (little-endian)
                  if (driveVal.isX()) {
                    // Write zeros for X
                    for (unsigned i = 0; i < elementByteWidth; ++i) {
                      block->data[elementOffset + i] = 0;
                    }
                  } else {
                    APInt val = driveVal.getAPInt();
                    if (val.getBitWidth() < elementWidth)
                      val = val.zext(elementWidth);
                    else if (val.getBitWidth() > elementWidth)
                      val = val.trunc(elementWidth);
                    for (unsigned i = 0; i < elementByteWidth; ++i) {
                      block->data[elementOffset + i] =
                          val.extractBits(std::min(8u, elementWidth - i * 8), i * 8)
                              .getZExtValue();
                    }
                  }
                  block->initialized = !driveVal.isX();

                  LLVM_DEBUG(llvm::dbgs()
                             << "  Drive to memory-backed array[" << index
                             << "] at offset " << elementOffset
                             << " width " << elementWidth << "\n");
                  return success();
                }
              }
            }
          }
        }

        // Handle sig.array_get where parent is a sig.struct_extract chain
        // tracing back to a memory-backed ref (e.g., function argument from
        // alloca). This occurs in from_class functions where individual array
        // elements within struct fields are driven via llhd.drv.
        {
          Value traceVal = parentSignal;
          llvm::SmallVector<llhd::SigStructExtractOp, 4> structExtractChain;
          while (auto extractOp =
                     traceVal.getDefiningOp<llhd::SigStructExtractOp>()) {
            structExtractChain.push_back(extractOp);
            traceVal = extractOp.getInput();
          }

          if (!structExtractChain.empty()) {
            // traceVal is the root signal (memory-backed ref)
            InterpretedValue rootPtrVal = getValue(procId, traceVal);
            if (!rootPtrVal.isX() && rootPtrVal.getUInt64() != 0) {
              uint64_t addr = rootPtrVal.getUInt64();
              uint64_t blockOffset = 0;
              MemoryBlock *block =
                  findMemoryBlockByAddress(addr, procId, &blockOffset);
              if (!block)
                block = findBlockByAddress(addr, blockOffset);
              if (block) {
                // Compute struct field bit offset using LLVM layout
                // (low-to-high: field 0 at bit 0).
                unsigned structBitOffset = 0;
                Type curType = traceVal.getType();
                if (auto refType = dyn_cast<llhd::RefType>(curType))
                  curType = refType.getNestedType();

                for (auto it = structExtractChain.rbegin();
                     it != structExtractChain.rend(); ++it) {
                  auto extractOp = *it;
                  auto sType = cast<hw::StructType>(curType);
                  auto elems = sType.getElements();
                  auto fidx = sType.getFieldIndex(extractOp.getField());
                  if (!fidx)
                    break;
                  unsigned fieldOff = 0;
                  for (size_t i = 0; i < *fidx; ++i)
                    fieldOff += getTypeWidth(elems[i].type);
                  structBitOffset += fieldOff;
                  curType = elems[*fidx].type;
                }

                // curType should now be the array type
                if (auto arrType = dyn_cast<hw::ArrayType>(curType)) {
                  Type elemType = arrType.getElementType();
                  unsigned elemWidth = getTypeWidth(elemType);

                  InterpretedValue idxVal =
                      getValue(procId, sigArrayGetOp.getIndex());
                  if (idxVal.isX())
                    return success();
                  uint64_t idx = idxVal.getUInt64();
                  if (idx >= arrType.getNumElements())
                    return success();

                  // Total bit offset = struct field offset + array element
                  unsigned totalBitOffset = structBitOffset + idx * elemWidth;

                  InterpretedValue driveVal =
                      getValue(procId, driveOp.getValue());

                  // Read-modify-write the memory block
                  unsigned rootWidth = getTypeWidth(traceVal.getType());
                  unsigned storeSize = (rootWidth + 7) / 8;

                  if (blockOffset + storeSize <= block->size) {
                    APInt currentVal = APInt::getZero(rootWidth);
                    for (unsigned i = 0; i < storeSize; ++i) {
                      unsigned insertPos = i * 8;
                      unsigned bitsToInsert =
                          std::min(8u, rootWidth - insertPos);
                      if (bitsToInsert > 0 && insertPos < rootWidth) {
                        APInt byteVal(
                            bitsToInsert,
                            block->data[blockOffset + i] &
                                ((1u << bitsToInsert) - 1));
                        safeInsertBits(currentVal, byteVal, insertPos);
                      }
                    }

                    APInt elemValue =
                        driveVal.isX() ? APInt::getZero(elemWidth)
                                       : driveVal.getAPInt();
                    if (elemValue.getBitWidth() < elemWidth)
                      elemValue = elemValue.zext(elemWidth);
                    else if (elemValue.getBitWidth() > elemWidth)
                      elemValue = elemValue.trunc(elemWidth);

                    safeInsertBits(currentVal, elemValue, totalBitOffset);

                    for (unsigned i = 0; i < storeSize; ++i) {
                      unsigned extractPos = i * 8;
                      unsigned bitsToExtract =
                          std::min(8u, rootWidth - extractPos);
                      if (bitsToExtract > 0 && extractPos < rootWidth) {
                        block->data[blockOffset + i] =
                            currentVal
                                .extractBits(bitsToExtract, extractPos)
                                .getZExtValue();
                      } else {
                        block->data[blockOffset + i] = 0;
                      }
                    }
                    block->initialized = !driveVal.isX();

                    LLVM_DEBUG(
                        llvm::dbgs()
                        << "  Drive to array[" << idx
                        << "] in struct field of memory-backed ref"
                        << " at bit offset " << totalBitOffset << " width "
                        << elemWidth << "\n");
                    return success();
                  }
                }
              }
            }
          }
        }

        LLVM_DEBUG(llvm::dbgs()
                   << "  Error: Could not find parent signal for array get\n");
        return failure();
      }

      // Get the index value (may be dynamic)
      InterpretedValue indexVal = getValue(procId, sigArrayGetOp.getIndex());
      if (indexVal.isX()) {
        LLVM_DEBUG(llvm::dbgs() << "  Warning: X index in array drive\n");
        return success(); // Don't drive with X index
      }
      uint64_t index = indexVal.getUInt64();

      // Get the value to drive
      InterpretedValue driveVal = getValue(procId, driveOp.getValue());

      // Get the current value of the parent signal, checking pending epsilon
      // drives first so that multiple array element drives in the same process
      // accumulate correctly (e.g., b[0]=0; b[1]=1; b[2]=2; $display(b)).
      InterpretedValue parentVal;
      auto pendingIt = pendingEpsilonDrives.find(parentSigId);
      if (pendingIt != pendingEpsilonDrives.end()) {
        parentVal = pendingIt->second;
      } else {
        const SignalValue &parentSV = scheduler.getSignalValue(parentSigId);
        parentVal = InterpretedValue::fromSignalValue(parentSV);
      }

      unsigned parentWidth = parentVal.getWidth();
      APInt result = parentVal.isX() ? APInt::getZero(parentWidth)
                                     : parentVal.getAPInt();

      // Get array element type and width
      auto arrayType = cast<hw::ArrayType>(unwrapSignalType(parentSignal.getType()));
      Type elementType = arrayType.getElementType();
      unsigned elementWidth = getTypeWidth(elementType);
      size_t numElements = arrayType.getNumElements();

      // Bounds check
      if (index >= numElements) {
        LLVM_DEBUG(llvm::dbgs() << "  Warning: Array index " << index
                                << " out of bounds (size " << numElements << ")\n");
        return success(); // Out of bounds - don't drive
      }

      // hw::ArrayType layout: element 0 at low bits, element N-1 at high bits
      unsigned bitOffset = index * elementWidth;

      // Insert the new value at the computed bit offset
      APInt elementValue = driveVal.isX() ? APInt::getZero(elementWidth)
                                          : driveVal.getAPInt();
      if (elementValue.getBitWidth() < elementWidth)
        elementValue = elementValue.zext(elementWidth);
      else if (elementValue.getBitWidth() > elementWidth)
        elementValue = elementValue.trunc(elementWidth);

      safeInsertBits(result,elementValue, bitOffset);

      // Get the delay time
      SimTime delay = convertTimeValue(procId, driveOp.getTime());
      SimTime currentTime = scheduler.getCurrentTime();
      SimTime targetTime = currentTime.advanceTime(delay.realTime);
      if (delay.deltaStep > 0)
        targetTime.deltaStep = delay.deltaStep;

      // Use the same driver ID scheme
      uint64_t driverId = (static_cast<uint64_t>(procId) << 32) |
                          static_cast<uint64_t>(parentSigId);

      LLVM_DEBUG(llvm::dbgs()
                 << "  Drive to array element[" << index << "] at offset "
                 << bitOffset << " width " << elementWidth << " in signal "
                 << parentSigId << "\n");

      // Schedule the signal update
      SignalValue newVal(result);
      scheduler.getEventScheduler().schedule(
          targetTime, SchedulingRegion::NBA,
          Event([this, parentSigId, driverId, newVal]() {
            scheduler.updateSignalWithStrength(parentSigId, driverId, newVal,
                                               DriveStrength::Strong,
                                               DriveStrength::Strong);
          }));

      // For epsilon/zero delays, store in pending drives for immediate reads.
      // This enables blocking assignment semantics for array element writes:
      // b[0]=0; b[1]=1; b[2]=2; $display(b) should see {0,1,2} not {0,0,0}.
      if (delay.realTime == 0 && delay.deltaStep <= 1) {
        pendingEpsilonDrives[parentSigId] = InterpretedValue(result);
      }

      return success();
    }

    // Handle memory-backed ref arguments (e.g., !llhd.ref passed through
    // function calls from UnrealizedConversionCastOp of GEP/addressof).
    // These refs are backed by LLVM memory locations (class fields, globals),
    // not LLHD signals. The interpreted value of the ref is the memory address.
    // This is critical for uvm_config_db::set which stores values into
    // associative arrays via ref arguments passed through multiple call layers.
    if (isa<BlockArgument>(signal) && isa<llhd::RefType>(signal.getType())) {
      InterpretedValue addrVal = getValue(procId, signal);
      if (!addrVal.isX() && addrVal.getUInt64() != 0) {
        uint64_t addr = addrVal.getUInt64();
        InterpretedValue driveVal = getValue(procId, driveOp.getValue());

        // Get the type being driven
        auto refType = cast<llhd::RefType>(signal.getType());
        unsigned width = getTypeWidth(refType.getNestedType());
        unsigned storeSize = (width + 7) / 8;

        // Find the memory block at this address using the comprehensive
        // search that checks process-local allocas, module-level allocas,
        // malloc blocks, and global memory blocks.  The previous manual
        // search only checked globals and mallocs, missing process-local
        // allocas (e.g., automatic variables passed by ref through
        // func.call chains like uvm_resource_debug::init_access_record).
        uint64_t offset = 0;
        MemoryBlock *block = findMemoryBlockByAddress(addr, procId, &offset);

        if (block && offset + storeSize <= block->size) {
          if (driveVal.isX()) {
            // Write X pattern
            for (unsigned i = 0; i < storeSize; ++i)
              block->data[offset + i] = 0xFF;
          } else {
            APInt val = driveVal.getAPInt();
            if (val.getBitWidth() < width)
              val = val.zext(width);
            else if (val.getBitWidth() > width)
              val = val.trunc(width);
            for (unsigned i = 0; i < storeSize; ++i) {
              unsigned bitPos = i * 8;
              unsigned bitsToWrite = std::min(8u, width - bitPos);
              if (bitsToWrite > 0 && bitPos < width)
                block->data[offset + i] =
                    val.extractBits(bitsToWrite, bitPos).getZExtValue();
              else
                block->data[offset + i] = 0;
            }
          }
          block->initialized = !driveVal.isX();

          LLVM_DEBUG(llvm::dbgs()
                     << "  Drive to memory-backed ref at 0x"
                     << llvm::format_hex(addr, 16) << " offset " << offset
                     << " width " << width << "\n");
          return success();
        }

        LLVM_DEBUG(llvm::dbgs()
                   << "  Drive to memory-backed ref at 0x"
                   << llvm::format_hex(addr, 16)
                   << " failed - memory not found\n");
        // Fall through to resolveSignalId as last resort
      }
    }

    // Try resolveSignalId which handles more cases like tracing through
    // UnrealizedConversionCastOp, block arguments, instance outputs, etc.
    // This is needed for direct struct drives where the signal reference
    // might not be in the direct valueToSignal map.
    sigId = resolveSignalId(signal);
    if (sigId != 0) {
      LLVM_DEBUG(llvm::dbgs() << "  Resolved signal via resolveSignalId: "
                              << sigId << "\n");
      // Fall through to the normal drive handling below
    } else {
      LLVM_DEBUG(llvm::dbgs() << "  Error: Unknown signal in drive\n");
      return failure();
    }
  }

  // Check enable condition if present
  if (driveOp.getEnable()) {
    InterpretedValue enableVal = getValue(procId, driveOp.getEnable());
    if (enableVal.isX() || enableVal.getUInt64() == 0) {
      LLVM_DEBUG(llvm::dbgs() << "  Drive disabled (enable = "
                              << (enableVal.isX() ? "X" : "0") << ")\n");
      return success(); // Drive is disabled
    }
  }

  // Get the value to drive
  InterpretedValue driveVal = getValue(procId, driveOp.getValue());

  // Get the delay time
  SimTime delay = convertTimeValue(procId, driveOp.getTime());

  // Calculate the target time
  SimTime currentTime = scheduler.getCurrentTime();
  SimTime targetTime = currentTime.advanceTime(delay.realTime);
  if (delay.deltaStep > 0) {
    targetTime.deltaStep = delay.deltaStep;
  }

  // Extract strength attributes if present
  DriveStrength strength0 = DriveStrength::Strong; // Default
  DriveStrength strength1 = DriveStrength::Strong; // Default

  if (auto s0Attr = driveOp.getStrength0Attr()) {
    // Convert LLHD DriveStrength to sim DriveStrength
    strength0 = static_cast<DriveStrength>(
        static_cast<uint8_t>(s0Attr.getValue()));
  }
  if (auto s1Attr = driveOp.getStrength1Attr()) {
    strength1 = static_cast<DriveStrength>(
        static_cast<uint8_t>(s1Attr.getValue()));
  }

  // Use a per-process, per-signal driver ID so multiple llhd.drv ops in the
  // same process model a single driver rather than conflicting drivers.
  uint64_t driverId =
      (static_cast<uint64_t>(procId) << 32) | static_cast<uint64_t>(sigId);

  LLVM_DEBUG(llvm::dbgs() << "  Scheduling drive to signal " << sigId
                          << " at time " << targetTime.realTime << " fs"
                          << " (delay " << delay.realTime << " fs)"
                          << " strength(" << getDriveStrengthName(strength0)
                          << ", " << getDriveStrengthName(strength1) << ")\n");

  // For epsilon/zero delays, also store in pending drives for immediate reads.
  // This enables blocking assignment semantics where a subsequent probe in the
  // same process sees the value immediately rather than waiting for the event.
  if (delay.realTime == 0 && delay.deltaStep <= 1) {
    pendingEpsilonDrives[sigId] = driveVal;
  }

  // Schedule the signal update with strength information
  SignalValue newVal = driveVal.toSignalValue();
  scheduler.getEventScheduler().schedule(
      targetTime, SchedulingRegion::NBA,
      Event([this, sigId, driverId, newVal, strength0, strength1]() {
        scheduler.updateSignalWithStrength(sigId, driverId, newVal, strength0,
                                           strength1);
      }));

  return success();
}

LogicalResult LLHDProcessInterpreter::interpretWait(ProcessId procId,
                                                     llhd::WaitOp waitOp) {
  auto &state = processStates[procId];

  // Handle yield operands - these become the process result values
  // The yield values are immediately available to the llhd.drv operations
  // that reference the process results.
  auto yieldOperands = waitOp.getYieldOperands();
  if (!yieldOperands.empty()) {
    // Get the parent process operation
    if (auto processOp = state.getProcessOp()) {
      auto results = processOp.getResults();
      for (auto [result, yieldOp] : llvm::zip(results, yieldOperands)) {
        InterpretedValue yieldVal = getValue(procId, yieldOp);
        // Store the yielded value so it can be accessed when evaluating
        // the process results outside the process
        state.valueMap[result] = yieldVal;
        LLVM_DEBUG(llvm::dbgs() << "  Yield value for process result: "
                                << (yieldVal.isX() ? "X"
                                                    : std::to_string(yieldVal.getUInt64()))
                                << "\n");
      }
    }

    // Execute module-level drives that depend on this process's results
    executeModuleDrives(procId);
    executeInstanceOutputUpdates(procId);
  }

  // Get the destination block
  state.destBlock = waitOp.getDest();

  // Store destination operands
  state.destOperands.clear();
  for (Value operand : waitOp.getDestOperands()) {
    state.destOperands.push_back(getValue(procId, operand));
  }

  // Mark as waiting
  state.waiting = true;
  bool hadDelay = static_cast<bool>(waitOp.getDelay());

  // Handle delay-based wait
  if (waitOp.getDelay()) {
    SimTime delay = convertTimeValue(procId, waitOp.getDelay());
    SimTime targetTime = scheduler.getCurrentTime().advanceTime(delay.realTime);

    LLVM_DEBUG(llvm::dbgs() << "  Wait delay " << delay.realTime
                            << " fs until time " << targetTime.realTime << "\n");

    // Schedule resumption
    scheduler.getEventScheduler().schedule(
        targetTime, SchedulingRegion::Active,
        Event([this, procId]() { resumeProcess(procId); }));
  }

  // Handle event-based wait (sensitivity list)
  // Note: The 'observed' operands are probe results (values), not signal refs.
  // We need to trace back to find the original signal by looking at the
  // defining probe operation.
  auto applySelfDrivenFilter = [&](SensitivityList &list) {
    if (list.empty())
      return;
    llvm::DenseSet<SignalId> selfDrivenSignals;
    if (auto processOp = state.getProcessOp()) {
      processOp.walk([&](llhd::DriveOp driveOp) {
        SignalId drivenId = getSignalId(driveOp.getSignal());
        if (drivenId != 0)
          selfDrivenSignals.insert(drivenId);
      });
    }
    // Include module-level drives fed by this process's results.
    // Also include transitive dependencies: signals that the drive value
    // depends on. If a process drives signal Z via a module-level drive that
    // reads signal X, then both Z and X are "self-driven" and should be
    // filtered from the sensitivity list to prevent zero-delta loops.
    for (auto &entry : moduleDrives) {
      if (entry.procId != procId)
        continue;
      ScopedInstanceContext instScope(*this, entry.instanceId);
      ScopedInputValueMap inputScope(*this, entry.inputMap);
      SignalId drivenId = getSignalId(entry.driveOp.getSignal());
      if (drivenId != 0)
        selfDrivenSignals.insert(drivenId);
      // Collect transitive dependencies from the drive value expression.
      llvm::SmallVector<SignalId, 4> transitiveSignals;
      collectSignalIds(entry.driveOp.getValue(), transitiveSignals);
      for (SignalId sigId : transitiveSignals)
        selfDrivenSignals.insert(sigId);
    }

    if (selfDrivenSignals.empty())
      return;
    bool hasNonSelf = false;
    for (const auto &entry : list.getEntries()) {
      if (!selfDrivenSignals.count(entry.signalId)) {
        hasNonSelf = true;
        break;
      }
    }

    if (hasNonSelf) {
      SensitivityList filtered;
      for (const auto &entry : list.getEntries()) {
        if (selfDrivenSignals.count(entry.signalId))
          continue;
        filtered.addEdge(entry.signalId, entry.edge);
      }
      list = std::move(filtered);
    }
  };

  if (!waitOp.getObserved().empty()) {
    SensitivityList waitList;
    auto cacheIt = state.waitSensitivityCache.find(waitOp.getOperation());
    if (cacheIt != state.waitSensitivityCache.end()) {
      for (const auto &entry : cacheIt->second)
        waitList.addEdge(entry.signalId, entry.edge);
      ++state.waitSensitivityCacheHits;
    }

    if (waitList.empty()) {
      // Helper function to recursively trace back through operations to find
      // the signal being observed. This handles chains like:
      //   %clk_bool = comb.and %value, %not_unknown
      //   %value = hw.struct_extract %probed["value"]
      //   %probed = llhd.prb %signal
      // We need to trace back through this chain to find %signal.
      std::function<SignalId(Value, int)> traceToSignal;
      traceToSignal = [&](Value value, int depth) -> SignalId {
        // Limit recursion depth to prevent infinite loops
        if (depth > 32)
          return 0;

        // Check if it's a signal reference directly
        SignalId sigId = getSignalId(value);
        if (sigId != 0)
          return sigId;

        // Trace through instance results to child outputs.
        auto instMapIt = instanceOutputMap.find(activeInstanceId);
        if (instMapIt != instanceOutputMap.end()) {
          auto instIt = instMapIt->second.find(value);
          if (instIt != instMapIt->second.end()) {
            const auto &info = instIt->second;
            ScopedInstanceContext instScope(
                *const_cast<LLHDProcessInterpreter *>(this), info.instanceId);
            if (info.inputMap.empty())
              return traceToSignal(info.outputValue, depth + 1);
            ScopedInputValueMap scope(
                *const_cast<LLHDProcessInterpreter *>(this), info.inputMap);
            return traceToSignal(info.outputValue, depth + 1);
          }
        }

        // Direct probe case
        if (auto probeOp = value.getDefiningOp<llhd::ProbeOp>()) {
          SignalId sigId = resolveSignalId(probeOp.getSignal());
          if (sigId != 0) {
            LLVM_DEBUG(llvm::dbgs() << "  Found signal " << sigId
                                    << " from probe at depth " << depth << "\n");
            return sigId;
          }
        }

        // Block argument - trace through predecessors
        if (auto blockArg = dyn_cast<BlockArgument>(value)) {
          Value mappedValue;
          InstanceId mappedInstance = activeInstanceId;
          if (lookupInputMapping(blockArg, mappedValue, mappedInstance) &&
              mappedValue != value) {
            ScopedInstanceContext scope(
                *const_cast<LLHDProcessInterpreter *>(this), mappedInstance);
            return traceToSignal(mappedValue, depth + 1);
          }
          Block *block = blockArg.getOwner();
          unsigned argIdx = blockArg.getArgNumber();

          // Look at all predecessors
          for (Block *pred : block->getPredecessors()) {
            Operation *terminator = pred->getTerminator();
            if (auto branchOp = dyn_cast<mlir::cf::BranchOp>(terminator)) {
              if (branchOp.getDest() == block &&
                  argIdx < branchOp.getNumOperands()) {
                Value incoming = branchOp.getDestOperands()[argIdx];
                sigId = traceToSignal(incoming, depth + 1);
                if (sigId != 0)
                  return sigId;
              }
            } else if (auto condBrOp =
                           dyn_cast<mlir::cf::CondBranchOp>(terminator)) {
              if (condBrOp.getTrueDest() == block &&
                  argIdx < condBrOp.getNumTrueOperands()) {
                Value incoming = condBrOp.getTrueDestOperands()[argIdx];
                sigId = traceToSignal(incoming, depth + 1);
                if (sigId != 0)
                  return sigId;
              }
              if (condBrOp.getFalseDest() == block &&
                  argIdx < condBrOp.getNumFalseOperands()) {
                Value incoming = condBrOp.getFalseDestOperands()[argIdx];
                sigId = traceToSignal(incoming, depth + 1);
                if (sigId != 0)
                  return sigId;
              }
            }
          }
          return 0;
        }

        // Trace through defining operation's operands
        if (Operation *defOp = value.getDefiningOp()) {
          for (Value operand : defOp->getOperands()) {
            sigId = traceToSignal(operand, depth + 1);
            if (sigId != 0)
              return sigId;
          }
        }

        return 0;
      };

      for (Value observed : waitOp.getObserved()) {
        SignalId sigId = traceToSignal(observed, 0);

        if (sigId != 0) {
          waitList.addLevel(sigId);
        } else {
          llvm::SmallVector<SignalId, 4> fallbackSignals;
          collectSignalIds(observed, fallbackSignals);
          if (!fallbackSignals.empty()) {
            for (SignalId fallbackId : fallbackSignals)
              waitList.addLevel(fallbackId);
            LLVM_DEBUG(llvm::dbgs()
                       << "  Waiting on "
                       << fallbackSignals.size()
                       << " fallback signal(s) for observed value\n");
          } else {
            LLVM_DEBUG(llvm::dbgs() << "  Warning: Could not find signal for "
                                        "observed value (type: "
                                    << observed.getType() << ")\n");
          }
        }
      }
    }

    // Avoid self-triggering on signals driven by this process when other
    // sensitivities exist (prevents zero-delta feedback loops).
    applySelfDrivenFilter(waitList);

    // Register the wait sensitivity with the scheduler
    if (waitList.empty()) {
      if (auto processOp = state.getProcessOp()) {
        processOp.walk([&](llhd::ProbeOp probeOp) {
          SignalId sigId = getSignalId(probeOp.getSignal());
          if (sigId != 0)
            waitList.addLevel(sigId);
        });
      } else if (auto initialOp = state.getInitialOp()) {
        initialOp.walk([&](llhd::ProbeOp probeOp) {
          SignalId sigId = getSignalId(probeOp.getSignal());
          if (sigId != 0)
            waitList.addLevel(sigId);
        });
      }
    }

    applySelfDrivenFilter(waitList);

    // Expand interface pointer signals to field shadow signals (observed case).
    if (!interfacePtrToFieldSignals.empty()) {
      SensitivityList expanded;
      for (const auto &entry : waitList.getEntries()) {
        auto fieldIt = interfacePtrToFieldSignals.find(entry.signalId);
        if (fieldIt != interfacePtrToFieldSignals.end()) {
          for (SignalId fieldSigId : fieldIt->second)
            expanded.addLevel(fieldSigId);
        } else {
          expanded.addEdge(entry.signalId, entry.edge);
        }
      }
      waitList = std::move(expanded);
    }

    if (!waitList.empty()) {
      if (cacheIt == state.waitSensitivityCache.end())
        state.waitSensitivityCache.try_emplace(waitOp.getOperation(),
                                               waitList.getEntries());
      scheduler.suspendProcessForEvents(procId, waitList);
      cacheWaitState(state, scheduler, &waitList, hadDelay);
    } else {
      cacheWaitState(state, scheduler, nullptr, hadDelay);
    }
  }

  // Handle case 3: No delay AND no observed signals (always @(*) semantics)
  // Derive sensitivity from signals that influence outputs or yields, falling
  // back to probes and then a delta resume when no signals can be found.
  if (!waitOp.getDelay() && waitOp.getObserved().empty()) {
    SensitivityList waitList;
    auto cacheIt = state.waitSensitivityCache.find(waitOp.getOperation());
    if (cacheIt != state.waitSensitivityCache.end()) {
      for (const auto &entry : cacheIt->second)
        waitList.addEdge(entry.signalId, entry.edge);
      ++state.waitSensitivityCacheHits;
    } else {
      llvm::SmallVector<SignalId, 8> derivedSignals;
      llvm::DenseSet<SignalId> derivedSignalSet;
      auto appendSignals = [&](Value value) {
        llvm::SmallVector<SignalId, 4> signals;
        collectSignalIds(value, signals);
        for (SignalId sigId : signals) {
          if (sigId != 0 && derivedSignalSet.insert(sigId).second)
            derivedSignals.push_back(sigId);
        }
      };

      for (Value operand : waitOp.getYieldOperands())
        appendSignals(operand);

      if (auto processOp = state.getProcessOp()) {
        processOp.walk([&](llhd::DriveOp driveOp) {
          appendSignals(driveOp.getValue());
          if (driveOp.getEnable())
            appendSignals(driveOp.getEnable());
        });
      } else if (auto initialOp = state.getInitialOp()) {
        initialOp.walk([&](llhd::DriveOp driveOp) {
          appendSignals(driveOp.getValue());
          if (driveOp.getEnable())
            appendSignals(driveOp.getEnable());
        });
      }

      if (!derivedSignals.empty()) {
        for (SignalId sigId : derivedSignals)
          waitList.addLevel(sigId);
      } else if (auto processOp = state.getProcessOp()) {
        processOp.walk([&](llhd::ProbeOp probeOp) {
          SignalId sigId = getSignalId(probeOp.getSignal());
          if (sigId != 0)
            waitList.addLevel(sigId);
        });
      } else if (auto initialOp = state.getInitialOp()) {
        initialOp.walk([&](llhd::ProbeOp probeOp) {
          SignalId sigId = getSignalId(probeOp.getSignal());
          if (sigId != 0)
            waitList.addLevel(sigId);
        });
      }

      applySelfDrivenFilter(waitList);

      // Expand interface pointer signals to their field shadow signals.
      // When a process is sensitive to an interface pointer signal (which
      // holds a malloc'd address that never changes), replace it with the
      // per-field shadow signals so the process wakes on field changes.
      if (!interfacePtrToFieldSignals.empty()) {
        SensitivityList expanded;
        for (const auto &entry : waitList.getEntries()) {
          auto fieldIt = interfacePtrToFieldSignals.find(entry.signalId);
          if (fieldIt != interfacePtrToFieldSignals.end()) {
            for (SignalId fieldSigId : fieldIt->second)
              expanded.addLevel(fieldSigId);
          } else {
            expanded.addEdge(entry.signalId, entry.edge);
          }
        }
        waitList = std::move(expanded);
      }

      if (!waitList.empty())
        state.waitSensitivityCache.try_emplace(waitOp.getOperation(),
                                               waitList.getEntries());
    }

    if (!waitList.empty()) {
      scheduler.suspendProcessForEvents(procId, waitList);
      LLVM_DEBUG(llvm::dbgs()
                 << "  Wait with no delay/no signals - derived "
                 << waitList.size() << " probe signal(s)\n");
      cacheWaitState(state, scheduler, &waitList, hadDelay);
    } else {
      LLVM_DEBUG(llvm::dbgs()
                 << "  Wait with no delay and no signals - scheduling "
                    "immediate delta-step resumption (always @(*) fallback)\n");

      // Schedule the process to resume on the next delta cycle.
      // This ensures the process doesn't hang when no signals are detected.
      scheduler.getEventScheduler().scheduleNextDelta(
          SchedulingRegion::Active,
          Event([this, procId]() { resumeProcess(procId); }));
      cacheWaitState(state, scheduler, nullptr, hadDelay);
    }
  }

  if (waitOp.getDelay() && waitOp.getObserved().empty())
    cacheWaitState(state, scheduler, nullptr, hadDelay);

  return success();
}

LogicalResult LLHDProcessInterpreter::interpretHalt(ProcessId procId,
                                                     llhd::HaltOp haltOp) {
  auto &state = processStates[procId];

  // Check if this process has active forked children that haven't completed.
  // If so, we cannot halt yet - we must wait for all children to complete.
  // This is critical for UVM phase termination where run_test() spawns UVM
  // phases via fork-join, and the parent process must not halt until all
  // forked children complete.
  if (forkJoinManager.hasActiveChildren(procId)) {
    LLVM_DEBUG(llvm::dbgs() << "  Halt deferred - process has active forked children\n");

    // Suspend the process instead of halting - it will be resumed when
    // all children complete (via the fork/join completion mechanism)
    state.waiting = true;

    // Store the halt operation so we can re-execute it when children complete
    state.destBlock = haltOp->getBlock();
    state.currentOp = mlir::Block::iterator(haltOp);
    state.resumeAtCurrentOp = true; // Resume at halt op, not block beginning

    Process *proc = scheduler.getProcess(procId);
    if (proc)
      proc->setState(ProcessState::Waiting);

    return success();
  }

  // Handle yield operands - these become the process result values
  // The yield values are immediately available to the llhd.drv operations
  // that reference the process results.
  auto yieldOperands = haltOp.getYieldOperands();
  if (!yieldOperands.empty()) {
    // Get the parent process operation
    if (auto processOp = state.getProcessOp()) {
      auto results = processOp.getResults();
      for (auto [result, yieldOp] : llvm::zip(results, yieldOperands)) {
        InterpretedValue yieldVal = getValue(procId, yieldOp);
        // Store the yielded value so it can be accessed when evaluating
        // the process results outside the process
        state.valueMap[result] = yieldVal;
        LLVM_DEBUG(llvm::dbgs() << "  Halt yield value for process result: "
                                << (yieldVal.isX() ? "X"
                                                    : std::to_string(yieldVal.getUInt64()))
                                << "\n");
      }
    }

    // Execute module-level drives that depend on this process's results
    executeModuleDrives(procId);
    executeInstanceOutputUpdates(procId);
  }

  LLVM_DEBUG(llvm::dbgs() << "  Process halted\n");

  finalizeProcess(procId, /*killed=*/false);

  return success();
}

LogicalResult
LLHDProcessInterpreter::interpretConstantTime(ProcessId procId,
                                               llhd::ConstantTimeOp timeOp) {
  // Store the time value - we'll convert it when needed
  // For now, store a placeholder value that we can use to look up the op later
  setValue(procId, timeOp.getResult(), InterpretedValue(0, 64));

  return success();
}

//===----------------------------------------------------------------------===//
// SCF Dialect Operation Interpreters
//===----------------------------------------------------------------------===//

LogicalResult LLHDProcessInterpreter::interpretSCFIf(ProcessId procId,
                                                      mlir::scf::IfOp ifOp) {
  LLVM_DEBUG(llvm::dbgs() << "  Interpreting scf.if\n");

  InterpretedValue cond = getValue(procId, ifOp.getCondition());

  // Determine which branch to execute
  mlir::Region *region = nullptr;
  if (cond.isX()) {
    // X condition - if both branches produce the same result, use it,
    // otherwise produce X for all results
    if (ifOp.getNumResults() > 0) {
      for (Value result : ifOp.getResults()) {
        setValue(procId, result,
                 InterpretedValue::makeX(getTypeWidth(result.getType())));
      }
    }
    return success();
  }

  if (cond.getUInt64() != 0) {
    region = &ifOp.getThenRegion();
  } else {
    if (ifOp.getElseRegion().empty()) {
      // No else branch
      return success();
    }
    region = &ifOp.getElseRegion();
  }

  // Execute the selected region
  llvm::SmallVector<InterpretedValue, 4> yieldValues;
  if (failed(interpretRegion(procId, *region, {}, yieldValues)))
    return failure();

  // Map yield values to the if op results
  for (auto [result, yieldVal] :
       llvm::zip(ifOp.getResults(), yieldValues)) {
    setValue(procId, result, yieldVal);
  }

  return success();
}

LogicalResult LLHDProcessInterpreter::interpretSCFFor(ProcessId procId,
                                                       mlir::scf::ForOp forOp) {
  LLVM_DEBUG(llvm::dbgs() << "  Interpreting scf.for\n");

  InterpretedValue lb = getValue(procId, forOp.getLowerBound());
  InterpretedValue ub = getValue(procId, forOp.getUpperBound());
  InterpretedValue step = getValue(procId, forOp.getStep());

  if (lb.isX() || ub.isX() || step.isX()) {
    // Cannot determine loop bounds - set results to X
    for (Value result : forOp.getResults()) {
      setValue(procId, result,
               InterpretedValue::makeX(getTypeWidth(result.getType())));
    }
    return success();
  }

  // Initialize iteration values
  llvm::SmallVector<InterpretedValue, 4> iterValues;
  for (Value initArg : forOp.getInitArgs()) {
    iterValues.push_back(getValue(procId, initArg));
  }

  int64_t lbVal = lb.getAPInt().getSExtValue();
  int64_t ubVal = ub.getAPInt().getSExtValue();
  int64_t stepVal = step.getAPInt().getSExtValue();

  // Prevent infinite loops
  const size_t maxIterations = 100000;
  size_t iterCount = 0;

  for (int64_t iv = lbVal; iv < ubVal && iterCount < maxIterations;
       iv += stepVal, ++iterCount) {
    // Set up block arguments: induction variable, then iter args
    llvm::SmallVector<InterpretedValue, 4> blockArgs;
    blockArgs.push_back(InterpretedValue(iv, getTypeWidth(forOp.getInductionVar().getType())));
    blockArgs.append(iterValues.begin(), iterValues.end());

    // Execute the loop body
    llvm::SmallVector<InterpretedValue, 4> yieldValues;
    if (failed(interpretRegion(procId, forOp.getRegion(), blockArgs, yieldValues)))
      return failure();

    // Update iteration values for next iteration
    iterValues = std::move(yieldValues);
  }

  if (iterCount >= maxIterations) {
    LLVM_DEBUG(llvm::dbgs() << "  Warning: scf.for reached max iterations\n");
  }

  // Map final iteration values to loop results
  for (auto [result, iterVal] : llvm::zip(forOp.getResults(), iterValues)) {
    setValue(procId, result, iterVal);
  }

  return success();
}

LogicalResult
LLHDProcessInterpreter::interpretSCFWhile(ProcessId procId,
                                           mlir::scf::WhileOp whileOp) {
  LLVM_DEBUG(llvm::dbgs() << "  Interpreting scf.while\n");

  // Initialize with input arguments
  llvm::SmallVector<InterpretedValue, 4> iterValues;
  for (Value operand : whileOp.getOperands()) {
    iterValues.push_back(getValue(procId, operand));
  }

  const size_t maxIterations = 100000;
  size_t iterCount = 0;

  while (iterCount < maxIterations) {
    ++iterCount;

    // Execute the "before" region (condition check)
    llvm::SmallVector<InterpretedValue, 4> conditionResults;
    if (failed(interpretWhileCondition(procId, whileOp.getBefore(), iterValues,
                                        conditionResults)))
      return failure();

    // The first result is the condition
    if (conditionResults.empty()) {
      LLVM_DEBUG(llvm::dbgs() << "  scf.while: no condition result\n");
      break;
    }

    InterpretedValue cond = conditionResults[0];
    if (cond.isX() || cond.getUInt64() == 0) {
      // Exit the loop - use remaining condition results as final values
      for (size_t i = 1; i < conditionResults.size() &&
                         i - 1 < whileOp.getResults().size(); ++i) {
        setValue(procId, whileOp.getResult(i - 1), conditionResults[i]);
      }
      break;
    }

    // Execute the "after" region (loop body)
    llvm::SmallVector<InterpretedValue, 4> afterValues(
        conditionResults.begin() + 1, conditionResults.end());
    llvm::SmallVector<InterpretedValue, 4> yieldValues;
    if (failed(interpretRegion(procId, whileOp.getAfter(), afterValues, yieldValues)))
      return failure();

    // Update iteration values for next condition check
    iterValues = std::move(yieldValues);
  }

  if (iterCount >= maxIterations) {
    LLVM_DEBUG(llvm::dbgs() << "  Warning: scf.while reached max iterations\n");
    // Set results to X on overflow
    for (Value result : whileOp.getResults()) {
      setValue(procId, result,
               InterpretedValue::makeX(getTypeWidth(result.getType())));
    }
  }

  return success();
}

LogicalResult LLHDProcessInterpreter::interpretWhileCondition(
    ProcessId procId, mlir::Region &region,
    llvm::ArrayRef<InterpretedValue> args,
    llvm::SmallVectorImpl<InterpretedValue> &results) {
  if (region.empty())
    return failure();

  Block &block = region.front();

  // Set block arguments
  for (auto [arg, val] : llvm::zip(block.getArguments(), args)) {
    setValue(procId, arg, val);
  }

  // Execute operations until we hit scf.condition
  for (Operation &op : block) {
    if (auto condOp = dyn_cast<mlir::scf::ConditionOp>(&op)) {
      // Gather the condition and forwarded values
      results.push_back(getValue(procId, condOp.getCondition()));
      for (Value arg : condOp.getArgs()) {
        results.push_back(getValue(procId, arg));
      }
      return success();
    }

    if (failed(interpretOperation(procId, &op))) {
      llvm::errs() << "circt-sim: Failed in while condition for process "
                   << procId << "\n";
      llvm::errs() << "  Operation: ";
      op.print(llvm::errs(), OpPrintingFlags().printGenericOpForm());
      llvm::errs() << "\n";
      llvm::errs() << "  Location: " << op.getLoc() << "\n";
      return failure();
    }
  }

  return failure();
}

LogicalResult LLHDProcessInterpreter::interpretRegion(
    ProcessId procId, mlir::Region &region,
    llvm::ArrayRef<InterpretedValue> args,
    llvm::SmallVectorImpl<InterpretedValue> &results) {
  if (region.empty())
    return success();

  Block &block = region.front();

  // Set block arguments
  for (auto [arg, val] : llvm::zip(block.getArguments(), args)) {
    setValue(procId, arg, val);
  }

  // Execute operations until we hit a yield
  for (Operation &op : block) {
    if (auto yieldOp = dyn_cast<mlir::scf::YieldOp>(&op)) {
      // Gather yielded values
      for (Value operand : yieldOp.getOperands()) {
        results.push_back(getValue(procId, operand));
      }
      return success();
    }

    if (failed(interpretOperation(procId, &op))) {
      llvm::errs() << "circt-sim: Failed in region for process " << procId
                   << "\n";
      llvm::errs() << "  Operation: ";
      op.print(llvm::errs(), OpPrintingFlags().printGenericOpForm());
      llvm::errs() << "\n";
      llvm::errs() << "  Location: " << op.getLoc() << "\n";
      return failure();
    }
  }

  return success();
}

//===----------------------------------------------------------------------===//
// Func Dialect Operation Interpreters
//===----------------------------------------------------------------------===//

LogicalResult
LLHDProcessInterpreter::interpretFuncCall(ProcessId procId,
                                           mlir::func::CallOp callOp) {
  LLVM_DEBUG(llvm::dbgs() << "  Interpreting func.call to '"
                          << callOp.getCallee() << "'\n");
  StringRef calleeName = callOp.getCallee();
  bool traceSeq = traceSeqEnabled;

  LLVM_DEBUG({
    if (calleeName.contains("driver_bfm::") || calleeName.contains("monitor_bfm::")) {
      static unsigned bfmCallDiagCount = 0;
      if (bfmCallDiagCount < 30) {
        ++bfmCallDiagCount;
        llvm::dbgs() << "[BFM-CALL] proc=" << procId << " -> " << calleeName << "\n";
      }
    }
  });

  if (profilingEnabled)
    ++funcCallProfile[calleeName];

  // Intercept get_0 (uvm_coreservice_t::get singleton accessor) - 907 calls.
  // After init, just reads global uvm_coreservice_t::inst pointer.
  if (calleeName == "get_0" && callOp.getNumResults() >= 1) {
    auto it = globalAddresses.find("uvm_pkg::uvm_pkg::uvm_coreservice_t::inst");
    if (it != globalAddresses.end()) {
      uint64_t globalAddr = it->getValue();
      uint64_t off = 0;
      MemoryBlock *blk = findBlockByAddress(globalAddr, off);
      if (blk && blk->initialized && off + 8 <= blk->data.size()) {
        uint64_t ptr = 0;
        for (unsigned i = 0; i < 8; ++i)
          ptr |= static_cast<uint64_t>(blk->data[off + i]) << (i * 8);
        if (ptr != 0) {
          setValue(procId, callOp.getResult(0), InterpretedValue(ptr, 64));
          return success();
        }
      }
    }
  }

  // Intercept get_core_state - reads global m_uvm_core_state.
  if (calleeName == "uvm_pkg::get_core_state" && callOp.getNumResults() >= 1) {
    auto it = globalAddresses.find("uvm_pkg::m_uvm_core_state");
    if (it != globalAddresses.end()) {
      uint64_t globalAddr = it->getValue();
      uint64_t off = 0;
      MemoryBlock *blk = findBlockByAddress(globalAddr, off);
      if (blk && blk->initialized && off + 16 <= blk->data.size()) {
        // struct<(ptr, i64)>: read the i64 at offset 8
        uint64_t lenVal = 0;
        for (unsigned i = 0; i < 8; ++i)
          lenVal |= static_cast<uint64_t>(blk->data[off + 8 + i]) << (i * 8);
        int32_t result = 0;
        if (lenVal != 0) {
          // Read the ptr at offset 0, then load i32 from it
          uint64_t ptrVal = 0;
          for (unsigned i = 0; i < 8; ++i)
            ptrVal |= static_cast<uint64_t>(blk->data[off + i]) << (i * 8);
          if (ptrVal != 0) {
            uint64_t off2 = 0;
            MemoryBlock *blk2 = findBlockByAddress(ptrVal, off2);
            if (!blk2)
              blk2 = findMemoryBlockByAddress(ptrVal, procId, &off2);
            if (blk2 && blk2->initialized && off2 + 4 <= blk2->data.size()) {
              result = 0;
              for (unsigned i = 0; i < 4; ++i)
                result |= static_cast<int32_t>(blk2->data[off2 + i]) << (i * 8);
            }
          }
        }
        setValue(procId, callOp.getResult(0),
                 InterpretedValue(llvm::APInt(32, static_cast<uint64_t>(result))));
        return success();
      }
    }
  }

  // Intercept uvm_default_coreservice_t::get_factory - reads field[1] (factory ptr).
  if (calleeName == "uvm_pkg::uvm_default_coreservice_t::get_factory" &&
      callOp.getNumResults() >= 1 && callOp.getNumOperands() >= 1) {
    InterpretedValue selfVal = getValue(procId, callOp.getOperand(0));
    if (!selfVal.isX() && selfVal.getUInt64() >= 0x1000) {
      // field[1] offset in uvm_default_coreservice_t: past the base class
      // uvm_coreservice_t{uvm_void{i32(4), ptr(8)}} = 12 bytes, then field[1] is ptr
      constexpr uint64_t kFactoryOff = 12;
      uint64_t off = 0;
      MemoryBlock *blk = findBlockByAddress(selfVal.getUInt64() + kFactoryOff, off);
      if (!blk)
        blk = findMemoryBlockByAddress(selfVal.getUInt64() + kFactoryOff, procId, &off);
      if (blk && blk->initialized && off + 8 <= blk->data.size()) {
        uint64_t factoryPtr = 0;
        for (unsigned i = 0; i < 8; ++i)
          factoryPtr |= static_cast<uint64_t>(blk->data[off + i]) << (i * 8);
        if (factoryPtr != 0) {
          setValue(procId, callOp.getResult(0),
                   InterpretedValue(factoryPtr, 64));
          return success();
        }
      }
    }
  }

  // Intercept m_resolve_type_name — the core string→wrapper lookup used by
  // find_override_by_name → m_resolve_type_name_by_inst → m_resolve_type_name.
  // The MLIR version checks factory.m_type_names assoc array, which is empty
  // for most types because our register interceptor (in call_indirect) stores
  // in the C++ nativeFactoryTypeNames map instead. Types that failed the
  // fast-path register DO exist in m_type_names, so we fall through to MLIR
  // for those.
  if (calleeName == "uvm_pkg::uvm_default_factory::m_resolve_type_name" &&
      callOp.getNumResults() >= 1 && callOp.getNumOperands() >= 2) {
    // arg[1] is struct<(ptr, i64)> type_name — a packed string
    InterpretedValue nameVal = getValue(procId, callOp.getOperand(1));
    if (!nameVal.isX() && nameVal.getWidth() >= 128) {
      APInt nameAPInt = nameVal.getAPInt();
      uint64_t strAddr = nameAPInt.extractBits(64, 0).getZExtValue();
      uint64_t strLen = nameAPInt.extractBits(64, 64).getZExtValue();
      if (strLen > 0 && strLen <= 1024 && strAddr != 0) {
        uint64_t strOff = 0;
        MemoryBlock *strBlk = findBlockByAddress(strAddr, strOff);
        if (!strBlk)
          strBlk = findMemoryBlockByAddress(strAddr, procId, &strOff);
        if (strBlk && strBlk->initialized &&
            strOff + strLen <= strBlk->data.size()) {
          std::string typeName(
              reinterpret_cast<const char *>(strBlk->data.data() + strOff),
              strLen);
          auto it = nativeFactoryTypeNames.find(typeName);
          if (it != nativeFactoryTypeNames.end()) {
            setValue(procId, callOp.getResult(0),
                    InterpretedValue(it->second, 64));
            return success();
          }
        }
      }
    }
    // Fall through to normal MLIR interpretation
  }

  // Intercept uvm_get_report_object at func.call level - trivially returns self.
  if (calleeName == "uvm_pkg::uvm_report_object::uvm_get_report_object" &&
      callOp.getNumResults() >= 1 && callOp.getNumOperands() >= 1) {
    setValue(procId, callOp.getResult(0),
             getValue(procId, callOp.getOperand(0)));
    return success();
  }

  // Intercept UVM phase wait_for_state: bypass since our IMP ordering mechanism
  // already enforces the correct phase sequence. The native UVM wait_for_state
  // polls memory-backed phase states that never update (because our IMP ordering
  // bypasses the UVM phase graph), creating deadlocks.
  if (callOp.getCallee() == "uvm_pkg::uvm_phase::wait_for_state") {
    LLVM_DEBUG(llvm::dbgs() << "  Bypassing wait_for_state (IMP ordering active)\n");
    return success();
  }

  // Intercept uvm_objection::m_execute_scheduled_forks.
  // This task is a forever-loop background worker that waits on internal
  // objection queues. The simulator already handles objection completion via
  // native wait_for/raise/drop interceptors, so interpreting this loop adds
  // large step overhead with no functional benefit.
  if (calleeName == "m_execute_scheduled_forks" ||
      calleeName.ends_with("::m_execute_scheduled_forks")) {
    LLVM_DEBUG(llvm::dbgs()
               << "  func.call: m_execute_scheduled_forks intercepted (no-op)\n");
    return success();
  }

  auto writePointerToOutRef = [&](Value outRef, uint64_t ptrValue) {
    InterpretedValue refAddr = getValue(procId, outRef);
    if (refAddr.isX())
      return;
    uint64_t addr = refAddr.getUInt64();
    if (!addr)
      return;

    uint64_t offset = 0;
    MemoryBlock *refBlock = findMemoryBlockByAddress(addr, procId, &offset);
    if (refBlock && offset + 8 <= refBlock->data.size()) {
      for (unsigned i = 0; i < 8; ++i)
        refBlock->data[offset + i] =
            static_cast<uint8_t>((ptrValue >> (i * 8)) & 0xFF);
      refBlock->initialized = true;
      return;
    }

    uint64_t nativeOffset = 0;
    size_t nativeSize = 0;
    if (findNativeMemoryBlockByAddress(addr, &nativeOffset, &nativeSize) &&
        nativeOffset + 8 <= nativeSize)
      std::memcpy(reinterpret_cast<void *>(addr), &ptrValue, 8);
  };

  auto waitOnHopperDataForCall = [&](uint64_t hopperAddr, Operation *retryOp) {
    auto &state = processStates[procId];
    state.waiting = true;
    state.sequencerGetRetryCallOp = retryOp;
    auto &waiters = phaseHopperWaiters[hopperAddr];
    if (std::find(waiters.begin(), waiters.end(), procId) == waiters.end())
      waiters.push_back(procId);
  };

  auto wakeHopperWaiters = [&](uint64_t hopperAddr) {
    auto waitIt = phaseHopperWaiters.find(hopperAddr);
    if (waitIt == phaseHopperWaiters.end())
      return;
    auto waiters = waitIt->second;
    phaseHopperWaiters.erase(waitIt);
    for (ProcessId waiterProc : waiters) {
      auto stateIt = processStates.find(waiterProc);
      if (stateIt == processStates.end())
        continue;
      if (!stateIt->second.waiting)
        continue;
      stateIt->second.waiting = false;
      scheduler.scheduleProcess(waiterProc, SchedulingRegion::Active);
    }
  };

  auto getHopperAddr = [&]() -> uint64_t {
    if (callOp.getNumOperands() < 1)
      return 0;
    InterpretedValue hopperVal = getValue(procId, callOp.getOperand(0));
    return hopperVal.isX() ? 0 : hopperVal.getUInt64();
  };

  // Native queue fast path for phase hopper task queue operations.
  if (calleeName.ends_with("uvm_phase_hopper::try_put") &&
      callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
    uint64_t hopperAddr = getHopperAddr();
    uint64_t phaseAddr = 0;
    InterpretedValue phaseVal = getValue(procId, callOp.getOperand(1));
    if (!phaseVal.isX())
      phaseAddr = phaseVal.getUInt64();

    phaseHopperQueue[hopperAddr].push_back(phaseAddr);
    wakeHopperWaiters(hopperAddr);

    // try_put raises an objection for each scheduled phase.
    if (hopperAddr != 0) {
      auto it = phaseObjectionHandles.find(hopperAddr);
      int64_t handle = 0;
      if (it != phaseObjectionHandles.end()) {
        handle = it->second;
      } else {
        std::string hopperName = "phase_hopper_" + std::to_string(hopperAddr);
        handle = __moore_objection_create(
            hopperName.c_str(), static_cast<int64_t>(hopperName.size()));
        phaseObjectionHandles[hopperAddr] = handle;
      }
      raisePhaseObjection(handle, 1);
    }

    unsigned width = getTypeWidth(callOp.getResult(0).getType());
    setValue(procId, callOp.getResult(0), InterpretedValue(llvm::APInt(width, 1)));
    return success();
  }

  if (calleeName.ends_with("uvm_phase_hopper::try_get") &&
      callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
    uint64_t hopperAddr = getHopperAddr();
    uint64_t phaseAddr = 0;
    bool hasPhase = false;
    auto it = phaseHopperQueue.find(hopperAddr);
    if (it != phaseHopperQueue.end() && !it->second.empty()) {
      phaseAddr = it->second.front();
      it->second.pop_front();
      hasPhase = true;
    }
    writePointerToOutRef(callOp.getOperand(1), phaseAddr);
    unsigned width = getTypeWidth(callOp.getResult(0).getType());
    setValue(procId, callOp.getResult(0),
             InterpretedValue(llvm::APInt(width, hasPhase ? 1 : 0)));
    return success();
  }

  if (calleeName.ends_with("uvm_phase_hopper::try_peek") &&
      callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
    uint64_t hopperAddr = getHopperAddr();
    uint64_t phaseAddr = 0;
    bool hasPhase = false;
    auto it = phaseHopperQueue.find(hopperAddr);
    if (it != phaseHopperQueue.end() && !it->second.empty()) {
      phaseAddr = it->second.front();
      hasPhase = true;
    }
    writePointerToOutRef(callOp.getOperand(1), phaseAddr);
    unsigned width = getTypeWidth(callOp.getResult(0).getType());
    setValue(procId, callOp.getResult(0),
             InterpretedValue(llvm::APInt(width, hasPhase ? 1 : 0)));
    return success();
  }

  if (calleeName.ends_with("uvm_phase_hopper::peek") &&
      callOp.getNumOperands() >= 2) {
    uint64_t hopperAddr = getHopperAddr();
    uint64_t phaseAddr = 0;
    auto it = phaseHopperQueue.find(hopperAddr);
    if (it != phaseHopperQueue.end() && !it->second.empty()) {
      phaseAddr = it->second.front();
      writePointerToOutRef(callOp.getOperand(1), phaseAddr);
      return success();
    }
    waitOnHopperDataForCall(hopperAddr, callOp.getOperation());
    return success();
  }

  if (calleeName.ends_with("uvm_phase_hopper::get") &&
      callOp.getNumOperands() >= 2) {
    uint64_t hopperAddr = getHopperAddr();
    auto it = phaseHopperQueue.find(hopperAddr);
    if (it != phaseHopperQueue.end() && !it->second.empty()) {
      uint64_t phaseAddr = it->second.front();
      it->second.pop_front();
      writePointerToOutRef(callOp.getOperand(1), phaseAddr);
      return success();
    }
    waitOnHopperDataForCall(hopperAddr, callOp.getOperation());
    return success();
  }

  // Intercept uvm_driver::end_of_elaboration_phase at func.call level.
  // Derived driver proxies call super.end_of_elaboration_phase via func.call.
  // The base function checks seq_item_port.size() which reads from UVM's
  // m_imp_list (stays empty since we use native connections). Skip it.
  if (calleeName.contains("uvm_driver") &&
      calleeName.contains("end_of_elaboration_phase")) {
    LLVM_DEBUG(llvm::dbgs()
               << "  func.call: uvm_driver::end_of_elaboration_phase "
               << "intercepted (no-op, suppresses DRVCONNECT)\n");
    return success();
  }

  // Intercept to_string_NNN — wide packed value to string conversion.
  // The compiled MLIR does bit-by-bit division of i4096 values to produce
  // decimal strings. For very wide values (e.g. AXI4's 16K-bit wdata),
  // this consumes tens of millions of interpreter steps, stalling the
  // simulation at time 0. We replace it with a fast C++ implementation.
  // Signature: to_string_NNN(%arg0: !hw.struct<value: iN, unknown: iN>,
  //                          %arg1: i32 width, %arg2: i28 format,
  //                          %arg3: !llvm.struct<(ptr, i64)> prefix)
  //         -> !llvm.struct<(ptr, i64)>
  if (calleeName.starts_with("to_string_") && calleeName.size() > 10) {
    bool allDigits = true;
    for (char c : calleeName.drop_front(10))
      if (!std::isdigit(c)) { allDigits = false; break; }
    if (allDigits && callOp.getNumOperands() >= 3 &&
        callOp.getNumResults() >= 1) {
      // Check if arg0 is a wide hw.struct<value: iN, unknown: iN>
      Type arg0Type = callOp.getOperand(0).getType();
      if (auto structType = dyn_cast<hw::StructType>(arg0Type)) {
        auto elements = structType.getElements();
        if (elements.size() == 2 &&
            elements[0].name.getValue() == "value" &&
            elements[1].name.getValue() == "unknown") {
          unsigned fieldWidth = getTypeWidth(elements[0].type);
          if (fieldWidth > 64) {
            // Fast path: extract value and unknown, convert in C++
            InterpretedValue structVal =
                getValue(procId, callOp.getOperand(0));
            InterpretedValue widthArg =
                getValue(procId, callOp.getOperand(1));
            InterpretedValue fmtArg =
                getValue(procId, callOp.getOperand(2));

            unsigned actualWidth =
                widthArg.isX() ? fieldWidth
                               : static_cast<unsigned>(
                                     widthArg.getAPInt().getZExtValue());
            if (actualWidth == 0 || actualWidth > fieldWidth)
              actualWidth = fieldWidth;

            // Decode format from arg2 bits [27:24]:
            //   1=binary, 2=decimal(signed), 3=octal, 4=hex, 6=decimal(unsigned)
            unsigned fmtBits = 2; // default decimal
            if (!fmtArg.isX()) {
              uint64_t fmtVal = fmtArg.getAPInt().getZExtValue();
              fmtBits = (fmtVal >> 24) & 0xF;
            }

            std::string result;
            unsigned totalWidth = getTypeWidth(structType);
            if (structVal.isX() ||
                structVal.getWidth() < totalWidth) {
              result = "0";
            } else {
              APInt fullBits = structVal.getAPInt();
              // value is in upper half, unknown is in lower half
              APInt valueBits =
                  fullBits.extractBits(fieldWidth, totalWidth - fieldWidth);
              APInt unknownBits = fullBits.extractBits(fieldWidth, 0);

              // Truncate to actual width
              APInt val = valueBits.trunc(actualWidth);
              APInt unk = unknownBits.trunc(actualWidth);

              if (unk.isZero()) {
                // No X bits — use hex for wide values (fast),
                // decimal for narrow
                if (actualWidth <= 64) {
                  result = std::to_string(val.getZExtValue());
                } else {
                  llvm::SmallString<256> str;
                  val.toStringUnsigned(str, 16);
                  result = std::string(str.str());
                }
              } else if (unk.isAllOnes()) {
                result = "x";
              } else {
                result = "x";
              }
            }

            // Prepend prefix string from arg3 if present
            if (callOp.getNumOperands() >= 4) {
              InterpretedValue prefixVal =
                  getValue(procId, callOp.getOperand(3));
              if (!prefixVal.isX() && prefixVal.getWidth() >= 128) {
                APInt bits = prefixVal.getAPInt();
                uint64_t pPtr = bits.extractBits(64, 0).getZExtValue();
                int64_t pLen = bits.extractBits(64, 64).getSExtValue();
                if (pPtr != 0 && pLen > 0) {
                  auto dynIt =
                      dynamicStrings.find(static_cast<int64_t>(pPtr));
                  if (dynIt != dynamicStrings.end() &&
                      dynIt->second.first && dynIt->second.second > 0) {
                    std::string prefix(
                        dynIt->second.first,
                        std::min(static_cast<size_t>(pLen),
                                 static_cast<size_t>(
                                     dynIt->second.second)));
                    result = prefix + result;
                  }
                }
              }
            }

            // Store and return string result using __moore_int_to_string
            // pattern: pack into {ptr, len} struct
            interpreterStrings.push_back(std::move(result));
            const std::string &stored = interpreterStrings.back();
            int64_t ptrVal =
                reinterpret_cast<int64_t>(stored.data());
            int64_t lenVal = static_cast<int64_t>(stored.size());
            dynamicStrings[ptrVal] = {stored.data(), lenVal};

            // Return the string as a 128-bit packed struct {ptr, len}
            // matching the !llvm.struct<(ptr, i64)> return type
            unsigned resultWidth =
                getTypeWidth(callOp.getResult(0).getType());
            APInt packedResult(resultWidth, 0);
            safeInsertBits(packedResult,
                APInt(64, static_cast<uint64_t>(ptrVal)), 0);
            safeInsertBits(packedResult,
                APInt(64, static_cast<uint64_t>(lenVal)), 64);
            setValue(procId, callOp.getResult(0),
                     InterpretedValue(packedResult));

            LLVM_DEBUG(llvm::dbgs()
                       << "  func.call: " << calleeName
                       << " FAST PATH (width=" << actualWidth
                       << ", fmt=" << fmtBits
                       << ", resultWidth=" << resultWidth
                       << ") = \"" << stored << "\"\n");
            return success();
          }
        }
      }
    }
  }

  // Intercept uvm_port_base::connect() at func.call level.
  // Some UVM code paths call connect directly instead of through vtables.
  if (calleeName.contains("uvm_port_base") &&
      calleeName.contains("::connect") &&
      !calleeName.contains("connect_phase") &&
      callOp.getNumOperands() >= 2) {
    InterpretedValue selfVal = getValue(procId, callOp.getOperand(0));
    InterpretedValue providerVal = getValue(procId, callOp.getOperand(1));
    uint64_t selfAddr = selfVal.isX() ? 0 : selfVal.getUInt64();
    uint64_t providerAddr = providerVal.isX() ? 0 : providerVal.getUInt64();
    if (selfAddr != 0 && providerAddr != 0) {
      auto &conns = analysisPortConnections[selfAddr];
      if (std::find(conns.begin(), conns.end(), providerAddr) == conns.end()) {
        conns.push_back(providerAddr);
        invalidateUvmSequencerQueueCache(selfAddr);
      }
    }
    // [SEQ-CONN] func.call connect diagnostic removed
    return success();
  }

  // Intercept uvm_port_base::size() and report count from native
  // analysisPortConnections, not UVM's m_imp_list bookkeeping.
  if (calleeName.contains("uvm_port_base") &&
      calleeName.ends_with("::size") &&
      callOp.getNumResults() >= 1 && callOp.getNumOperands() >= 1) {
    InterpretedValue selfVal = getValue(procId, callOp.getOperand(0));
    uint64_t selfAddr = selfVal.isX() ? 0 : selfVal.getUInt64();
    int32_t count = getNativeUvmPortSize(analysisPortConnections, selfAddr);
    Value result = callOp.getResult(0);
    unsigned width = getTypeWidth(result.getType());
    setValue(procId, result,
             InterpretedValue(
                 llvm::APInt(width, static_cast<uint64_t>(count), false)));
    if (traceSeq)
      llvm::errs() << "[SEQ-SIZE] func.call: " << calleeName << " self=0x"
                   << llvm::format_hex(selfAddr, 16) << " -> " << count
                   << " (total_conns=" << analysisPortConnections.size()
                   << ")\n";
    LLVM_DEBUG(llvm::dbgs() << "  func.call: uvm_port_base::size self=0x"
                            << llvm::format_hex(selfAddr, 16) << " -> "
                            << count << "\n");
    return success();
  }

  // Intercept analysis_port::write at func.call level.
  // uvm_analysis_port::write() is a non-virtual method, so it's called via
  // func.call rather than call_indirect. We broadcast to connected subscribers
  // using the same native connection map used by the call_indirect handler.
  if (calleeName.contains("analysis_port") && calleeName.contains("::write") &&
      !calleeName.contains("write_m_") && callOp.getNumOperands() >= 2) {
    InterpretedValue selfVal = getValue(procId, callOp.getOperand(0));
    InterpretedValue txnVal = getValue(procId, callOp.getOperand(1));
    uint64_t portAddr = selfVal.isX() ? 0 : selfVal.getUInt64();
    if (traceAnalysisEnabled)
      llvm::errs() << "[ANALYSIS-WRITE-FC] " << calleeName
                   << " portAddr=0x" << llvm::format_hex(portAddr, 0)
                   << " inMap=" << analysisPortConnections.count(portAddr)
                   << "\n";
    // Flatten the connection chain to find all terminal imps.
    llvm::SmallVector<uint64_t, 4> terminals;
    llvm::SmallVector<uint64_t, 8> worklist;
    llvm::DenseSet<uint64_t> visited;
    auto seedIt = analysisPortConnections.find(portAddr);
    if (seedIt != analysisPortConnections.end()) {
      for (uint64_t a : seedIt->second)
        worklist.push_back(a);
    }
    while (!worklist.empty()) {
      uint64_t addr = worklist.pop_back_val();
      if (!visited.insert(addr).second)
        continue;
      auto chainIt = analysisPortConnections.find(addr);
      if (chainIt != analysisPortConnections.end() && !chainIt->second.empty()) {
        for (uint64_t next : chainIt->second)
          worklist.push_back(next);
      } else {
        terminals.push_back(addr);
      }
    }
    if (!terminals.empty()) {
      // Resolve the MLIR module for symbol lookup.
      auto &cState = processStates[procId];
      Operation *parent = cState.processOrInitialOp;
      while (parent && !isa<ModuleOp>(parent))
        parent = parent->getParentOp();
      ModuleOp moduleOp = parent ? cast<ModuleOp>(parent) : rootModule;

      if (traceAnalysisEnabled)
        llvm::errs() << "[ANALYSIS-WRITE-FC] " << terminals.size()
                     << " terminal(s)\n";
      for (uint64_t impAddr : terminals) {
        // Read vtable pointer at byte offset 4 from the imp object.
        uint64_t vtableOff = 0;
        MemoryBlock *impBlock = findBlockByAddress(impAddr, vtableOff);
        if (!impBlock || vtableOff + 4 + 8 > impBlock->size) {
          if (traceAnalysisEnabled)
            llvm::errs() << "[ANALYSIS-WRITE-FC] imp 0x"
                         << llvm::format_hex(impAddr, 0)
                         << " not found in memory\n";
          continue;
        }
        uint64_t vtableAddr = 0;
        for (unsigned i = 0; i < 8; ++i)
          vtableAddr |= static_cast<uint64_t>(
                            impBlock->data[vtableOff + 4 + i])
                        << (i * 8);
        auto globalIt = addressToGlobal.find(vtableAddr);
        if (globalIt == addressToGlobal.end()) {
          if (traceAnalysisEnabled)
            llvm::errs() << "[ANALYSIS-WRITE-FC] vtable 0x"
                         << llvm::format_hex(vtableAddr, 0)
                         << " not in addressToGlobal\n";
          continue;
        }
        // Read the write function pointer from vtable slot 11.
        auto vtableBlockIt = globalMemoryBlocks.find(globalIt->second);
        if (vtableBlockIt == globalMemoryBlocks.end())
          continue;
        auto &vtableBlock = vtableBlockIt->second;
        unsigned writeSlot = 11;
        unsigned slotOffset = writeSlot * 8;
        if (slotOffset + 8 > vtableBlock.size)
          continue;
        uint64_t writeFuncAddr = 0;
        for (unsigned i = 0; i < 8; ++i)
          writeFuncAddr |=
              static_cast<uint64_t>(vtableBlock.data[slotOffset + i])
              << (i * 8);
        auto funcIt2 = addressToFunction.find(writeFuncAddr);
        if (funcIt2 == addressToFunction.end()) {
          if (traceAnalysisEnabled)
            llvm::errs() << "[ANALYSIS-WRITE-FC] slot 11 func addr 0x"
                         << llvm::format_hex(writeFuncAddr, 0)
                         << " not in addressToFunction\n";
          continue;
        }
        auto impWriteFunc =
            moduleOp.lookupSymbol<func::FuncOp>(funcIt2->second);
        if (!impWriteFunc) {
          if (traceAnalysisEnabled)
            llvm::errs() << "[ANALYSIS-WRITE-FC] function '"
                         << funcIt2->second << "' not found in module\n";
          continue;
        }
        if (traceAnalysisEnabled)
          llvm::errs() << "[ANALYSIS-WRITE-FC] dispatching to "
                       << funcIt2->second << "\n";
        SmallVector<InterpretedValue, 2> impArgs;
        impArgs.push_back(InterpretedValue(llvm::APInt(64, impAddr)));
        impArgs.push_back(txnVal);
        SmallVector<InterpretedValue, 2> impResults;
        ++cState.callDepth;
        (void)interpretFuncBody(procId, impWriteFunc, impArgs, impResults,
                               callOp);
        --cState.callDepth;
      }
      return success();
    }
    // If no native connections, fall through to normal execution.
  }

  // Intercept sequencer pull interface at func.call level.
  // This handles wrapper calls before they dereference m_if, which can be
  // null when UVM connect bookkeeping is bypassed by native connection logic.
  if ((calleeName.contains("seq_item_pull_port") ||
       calleeName.contains("seq_item_pull_imp") ||
       calleeName.contains("sqr_if_base") ||
         calleeName.contains("uvm_sequencer")) &&
      (calleeName.ends_with("::get") ||
       calleeName.ends_with("::get_next_item") ||
       calleeName.ends_with("::try_next_item")) &&
      callOp.getNumOperands() >= 2) {
    uint64_t portAddr = 0;
    bool isTryNextItem = calleeName.ends_with("::try_next_item");
    InterpretedValue selfVal = getValue(procId, callOp.getOperand(0));
    if (!selfVal.isX())
      portAddr = selfVal.getUInt64();

    if (traceSeq)
      llvm::errs() << "[SEQ-FC] get " << calleeName << " port=0x"
                   << llvm::format_hex(portAddr, 16)
                   << " fifoMaps=" << sequencerItemFifo.size() << "\n";

    uint64_t seqrAddr = 0;
    (void)lookupUvmSequencerQueueCache(portAddr, seqrAddr);
    if (seqrAddr == 0) {
      auto connIt = analysisPortConnections.find(portAddr);
      if (connIt != analysisPortConnections.end() && !connIt->second.empty())
        // Prefer the most recent connect() target for pull ports.
        seqrAddr = connIt->second.back();
      cacheUvmSequencerQueueAddress(portAddr, seqrAddr);
    }

    uint64_t itemAddr = 0;
    bool found = false;
    if (seqrAddr != 0) {
      auto fifoIt = sequencerItemFifo.find(seqrAddr);
      if (fifoIt != sequencerItemFifo.end() && !fifoIt->second.empty()) {
        itemAddr = fifoIt->second.front();
        fifoIt->second.pop_front();
        found = true;
      }
    }
    if (!found) {
      for (auto &[key, fifo] : sequencerItemFifo) {
        if (!fifo.empty()) {
          itemAddr = fifo.front();
          fifo.pop_front();
          found = true;
          break;
        }
      }
    }

    if (found && itemAddr != 0) {
      lastDequeuedItem[portAddr] = itemAddr;
      uint64_t refAddr = 0;
      InterpretedValue outRefVal = getValue(procId, callOp.getOperand(1));
      if (!outRefVal.isX())
        refAddr = outRefVal.getUInt64();

      if (refAddr != 0) {
        uint64_t offset = 0;
        MemoryBlock *refBlock =
            findMemoryBlockByAddress(refAddr, procId, &offset);
        if (refBlock && offset + 8 <= refBlock->data.size()) {
          for (unsigned i = 0; i < 8; ++i)
            refBlock->data[offset + i] =
                static_cast<uint8_t>((itemAddr >> (i * 8)) & 0xFF);
            refBlock->initialized = true;
        } else {
          uint64_t nativeOffset = 0;
          size_t nativeSize = 0;
          if (findNativeMemoryBlockByAddress(refAddr, &nativeOffset,
                                             &nativeSize) &&
              nativeOffset + 8 <= nativeSize) {
            std::memcpy(reinterpret_cast<void *>(refAddr), &itemAddr, 8);
          }
        }
      }
      return success();
    }

    if (isTryNextItem) {
      uint64_t refAddr = 0;
      InterpretedValue outRefVal = getValue(procId, callOp.getOperand(1));
      if (!outRefVal.isX())
        refAddr = outRefVal.getUInt64();
      if (traceSeq)
        llvm::errs() << "[SEQ-FC] try_next_item miss port=0x"
                     << llvm::format_hex(portAddr, 16) << " ref=0x"
                     << llvm::format_hex(refAddr, 16) << "\n";
      if (refAddr != 0) {
        uint64_t offset = 0;
        MemoryBlock *refBlock =
            findMemoryBlockByAddress(refAddr, procId, &offset);
        if (refBlock &&
            offset + 8 <= refBlock->data.size()) {
          for (unsigned i = 0; i < 8; ++i)
            refBlock->data[offset + i] = 0;
            refBlock->initialized = true;
        } else {
          uint64_t nativeOffset = 0;
          size_t nativeSize = 0;
          if (findNativeMemoryBlockByAddress(refAddr, &nativeOffset,
                                             &nativeSize) &&
              nativeOffset + 8 <= nativeSize) {
            uint64_t nullItem = 0;
            std::memcpy(reinterpret_cast<void *>(refAddr), &nullItem, 8);
          }
        }
      }
      return success();
    }

    auto &pState = processStates[procId];
    pState.waiting = true;
    pState.sequencerGetRetryCallOp = callOp.getOperation();
    SimTime currentTime = scheduler.getCurrentTime();
    constexpr uint32_t kMaxDeltaPolls = 1000;
    constexpr int64_t kFallbackPollDelayFs = 10000000; // 10 ps
    SimTime targetTime;
    if (currentTime.deltaStep < kMaxDeltaPolls)
      targetTime = currentTime.nextDelta();
    else
      targetTime = currentTime.advanceTime(kFallbackPollDelayFs);
    scheduler.getEventScheduler().schedule(
        targetTime, SchedulingRegion::Active,
        Event([this, procId]() {
          auto &st = processStates[procId];
          st.waiting = false;
          scheduler.scheduleProcess(procId, SchedulingRegion::Active);
        }));
    return success();
  }

  if ((calleeName.contains("seq_item_pull_port") ||
       calleeName.contains("seq_item_pull_imp") ||
       calleeName.contains("sqr_if_base") ||
         calleeName.contains("uvm_sequencer")) &&
      calleeName.ends_with("::item_done") && callOp.getNumOperands() >= 1) {
    uint64_t portAddr = 0;
    InterpretedValue selfVal = getValue(procId, callOp.getOperand(0));
    if (!selfVal.isX())
      portAddr = selfVal.getUInt64();

    auto lastIt = lastDequeuedItem.find(portAddr);
    if (lastIt != lastDequeuedItem.end()) {
      uint64_t itemAddr = lastIt->second;
      itemDoneReceived.insert(itemAddr);
      lastDequeuedItem.erase(lastIt);

      auto waiterIt = finishItemWaiters.find(itemAddr);
      if (waiterIt != finishItemWaiters.end()) {
        ProcessId waiterProcId = waiterIt->second;
        finishItemWaiters.erase(waiterIt);
        auto waiterStateIt = processStates.find(waiterProcId);
        if (waiterStateIt != processStates.end() && waiterStateIt->second.waiting) {
          waiterStateIt->second.waiting = false;
          scheduler.scheduleProcess(waiterProcId, SchedulingRegion::Active);
        }
      }
    }
    return success();
  }

  // Intercept config_db wrapper functions at the func.call level.
  // Config_db wrappers (get_NNNN/set_NNNN) have 4 args, return i1, and their
  // body calls get_imp_NNNN() then call_indirect to the implementation.
  // Some specializations' singletons fail to initialize (vtable null), so
  // intercepting at the call_indirect level misses them. By intercepting here,
  // we handle ALL config_db calls regardless of singleton state.
  if (callOp.getNumResults() == 1 &&
      callOp.getResult(0).getType().isSignlessInteger(1) &&
      callOp.getNumOperands() == 4 &&
      isa<LLVM::LLVMPointerType>(callOp.getOperand(0).getType())) {
    Type arg3Type = callOp.getOperand(3).getType();
    if (auto refType = dyn_cast<llhd::RefType>(arg3Type)) {
      // Detect config_db wrapper by name: get_NNNN or set_NNNN where NNNN is
      // all digits. This matches the slang-generated wrapper pattern.
      StringRef callee = callOp.getCallee();
      bool isConfigDbWrapper = false;
      if ((callee.starts_with("get_") || callee.starts_with("set_")) &&
          callee.size() > 4) {
        bool allDigits = true;
        for (char c : callee.drop_front(4))
          if (!std::isdigit(c)) { allDigits = false; break; }
        isConfigDbWrapper = allDigits;
      }


      if (isConfigDbWrapper) {
        // This is a config_db::get wrapper. Extract string args and handle
        // via our key-value store, bypassing the singleton dispatch.
        auto readStr = [&](unsigned argIdx) -> std::string {
          InterpretedValue val = getValue(procId, callOp.getOperand(argIdx));
          if (val.isX() || val.getWidth() < 128)
            return "";
          llvm::APInt bits = val.getAPInt();
          uint64_t strPtr = bits.extractBits(64, 0).getZExtValue();
          int64_t strLen = bits.extractBits(64, 64).getSExtValue();
          if (strPtr == 0 || strLen <= 0)
            return "";
          // Check dynamicStrings first (for runtime-allocated strings from
          // __moore_string_concat, __moore_int_to_string, etc.)
          auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
          if (dynIt != dynamicStrings.end() && dynIt->second.first &&
              dynIt->second.second > 0) {
            return std::string(
                dynIt->second.first,
                std::min(static_cast<size_t>(strLen),
                         static_cast<size_t>(dynIt->second.second)));
          }
          // Fall back to global/alloca memory blocks
          uint64_t strOff = 0;
          MemoryBlock *strBlock = findBlockByAddress(strPtr, strOff);
          if (!strBlock || !strBlock->initialized)
            return "";
          std::string result;
          for (int64_t i = 0; i < strLen && strOff + i < strBlock->data.size(); ++i)
            result += static_cast<char>(strBlock->data[strOff + i]);
          return result;
        };

        // Build config_db key from self context + inst_name + field_name
        InterpretedValue selfVal = getValue(procId, callOp.getOperand(0));
        std::string instName = readStr(1);
        std::string fieldName = readStr(2);
        std::string key = instName + "." + fieldName;

        // Look up in configDbEntries with wildcard matching
        // (same logic as the call_indirect config_db handler)
        auto it = configDbEntries.find(key);
        if (it == configDbEntries.end()) {
          // Wildcard match: look for entries where field name matches
          for (auto &[k, v] : configDbEntries) {
            size_t dotPos = k.rfind('.');
            if (dotPos != std::string::npos &&
                k.substr(dotPos + 1) == fieldName) {
              it = configDbEntries.find(k);
              break;
            }
          }
        }
        // Fuzzy match: try _x suffix → _0 suffix
        if (it == configDbEntries.end() && fieldName.size() > 2 &&
            fieldName.back() == 'x' && fieldName[fieldName.size() - 2] == '_') {
          std::string baseName = fieldName.substr(0, fieldName.size() - 1);
          for (auto &[k, v] : configDbEntries) {
            size_t dotPos = k.rfind('.');
            if (dotPos != std::string::npos) {
              std::string storedField = k.substr(dotPos + 1);
              if (storedField.size() > baseName.size() &&
                  storedField.substr(0, baseName.size()) == baseName &&
                  std::isdigit(storedField[baseName.size()])) {
                it = configDbEntries.find(k);
                break;
              }
            }
          }
        }

        if (it != configDbEntries.end()) {
          Value outputRef = callOp.getOperand(3);
          const std::vector<uint8_t> &valueData = it->second;
          Type innerType = refType.getNestedType();
          unsigned innerBits = getTypeWidth(innerType);
          unsigned innerBytes = (innerBits + 7) / 8;
          llvm::APInt valueBits(innerBits, 0);
          for (unsigned i = 0;
               i < std::min(innerBytes, (unsigned)valueData.size()); ++i)
            safeInsertBits(valueBits,llvm::APInt(8, valueData[i]), i * 8);
          // Write value to output ref via signal or memory
          SignalId sigId2 = resolveSignalId(outputRef);
          if (sigId2 != 0)
            pendingEpsilonDrives[sigId2] = InterpretedValue(valueBits);
          InterpretedValue refAddr = getValue(procId, outputRef);
          if (!refAddr.isX()) {
            uint64_t addr = refAddr.getUInt64();
            uint64_t off3 = 0;
            MemoryBlock *blk =
                findMemoryBlockByAddress(addr, procId, &off3);
            if (blk) {
              writeConfigDbBytesToMemoryBlock(
                  blk, off3, valueData, innerBytes,
                  /*zeroFillMissing=*/true);
            } else {
              // Fallback: write directly to native memory (heap-allocated
              // blocks from __moore_dyn_array_new, malloc, etc.)
              uint64_t nativeOff = 0;
              size_t nativeSize = 0;
              if (findNativeMemoryBlockByAddress(addr, &nativeOff,
                                                 &nativeSize)) {
                writeConfigDbBytesToNativeMemory(
                    addr, nativeOff, nativeSize, valueData, innerBytes,
                    /*zeroFillMissing=*/true);
              }
            }
          }
          setValue(procId, callOp.getResult(0),
                  InterpretedValue(llvm::APInt(1, 1)));
          return success();
        } else {
          // Not found - return false
          setValue(procId, callOp.getResult(0),
                  InterpretedValue(llvm::APInt(1, 0)));
          return success();
        }
      }
    }
  }

  // Intercept config_db set_ wrappers at the func.call level.
  // set_ wrappers return void and have !llvm.ptr arg3 (unlike get_ wrappers
  // which return i1 and have !llhd.ref arg3). Without this intercept,
  // set_ wrappers execute their full MLIR body which involves factory
  // singleton initialization that can fail (vtable X) for some specializations,
  // causing config_db entries to never be stored. This breaks I2S (and
  // potentially other AVIPs) because the env/agent configs are never stored,
  // so build_phase can't retrieve them and components are never created.
  if (callOp.getNumResults() == 0 &&
      callOp.getNumOperands() == 4 &&
      isa<LLVM::LLVMPointerType>(callOp.getOperand(0).getType()) &&
      isa<LLVM::LLVMPointerType>(callOp.getOperand(3).getType())) {
    StringRef callee = callOp.getCallee();
    bool isConfigDbSetWrapper = false;
    if (callee.starts_with("set_") && callee.size() > 4) {
      bool allDigits = true;
      for (char c : callee.drop_front(4))
        if (!std::isdigit(c)) { allDigits = false; break; }
      isConfigDbSetWrapper = allDigits;
    }
    if (isConfigDbSetWrapper) {
      // Read inst_name and field_name from struct<(ptr,i64)> args
      auto readStr = [&](unsigned argIdx) -> std::string {
        InterpretedValue val = getValue(procId, callOp.getOperand(argIdx));
        if (val.isX() || val.getWidth() < 128)
          return "";
        llvm::APInt bits = val.getAPInt();
        uint64_t strPtr = bits.extractBits(64, 0).getZExtValue();
        int64_t strLen = bits.extractBits(64, 64).getSExtValue();
        if (strPtr == 0 || strLen <= 0)
          return "";
        auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
        if (dynIt != dynamicStrings.end() && dynIt->second.first &&
            dynIt->second.second > 0) {
          return std::string(
              dynIt->second.first,
              std::min(static_cast<size_t>(strLen),
                       static_cast<size_t>(dynIt->second.second)));
        }
        uint64_t strOff = 0;
        MemoryBlock *strBlock = findBlockByAddress(strPtr, strOff);
        if (!strBlock || !strBlock->initialized)
          return "";
        std::string result;
        for (int64_t i = 0; i < strLen && strOff + i < strBlock->data.size();
             ++i)
          result += static_cast<char>(strBlock->data[strOff + i]);
        return result;
      };

      std::string instName = readStr(1);
      std::string fieldName = readStr(2);
      std::string key = instName + "." + fieldName;

      // Store the value pointer as raw bytes in configDbEntries.
      // arg3 is !llvm.ptr — the pointer IS the config value (object handle).
      InterpretedValue valueArg = getValue(procId, callOp.getOperand(3));
      unsigned valueBits = valueArg.getWidth();
      unsigned valueBytes = (valueBits + 7) / 8;
      std::vector<uint8_t> valueData(valueBytes, 0);
      if (!valueArg.isX()) {
        llvm::APInt valBits = valueArg.getAPInt();
        for (unsigned i = 0; i < valueBytes; ++i)
          valueData[i] = static_cast<uint8_t>(
              valBits.extractBits(8, i * 8).getZExtValue());
      }
      configDbEntries[key] = std::move(valueData);
      LLVM_DEBUG(llvm::dbgs()
                 << "  func.call @" << callee
                 << ": config_db set intercepted, key=\"" << key
                 << "\" valueBytes=" << valueBytes << "\n");
      return success();
    }
  }

  // Track UVM root construction for re-entrancy handling
  // When m_uvm_get_root is called, we need to mark root construction as started
  // so that re-entrant calls (via uvm_component::new -> get_root) can skip
  // the m_inst != uvm_top comparison that fails during construction.
  // Handle process::self() - both the old stub (@self) and the runtime function.
  // Old compilations of circt-verilog generated a stub @self() that returns null.
  // Intercept it here to return the actual process handle, fixing UVM's
  // "run_test() invoked from a non process context" error.
  if (calleeName == "self" && callOp.getNumOperands() == 0 &&
      callOp.getNumResults() == 1 &&
      isa<LLVM::LLVMPointerType>(callOp.getResult(0).getType())) {
    auto &state = processStates[procId];
    void *processHandle = &state;
    uint64_t handleVal = reinterpret_cast<uint64_t>(processHandle);
    LLVM_DEBUG(llvm::dbgs() << "  func.call @self(): returning process handle 0x"
                            << llvm::format_hex(handleVal, 16) << "\n");
    setValue(procId, callOp.getResult(0), InterpretedValue(APInt(64, handleVal)));
    return success();
  }

  // Handle class-level srandom(seed) calls (old stub pattern).
  // Old MooreToCore emitted empty stub functions @srandom_NNNN for class
  // srandom(). These don't carry the object pointer, so we store a pending
  // seed that will be applied to the next __moore_randomize_basic call.
  // New compilations emit __moore_class_srandom(objPtr, seed) which is
  // handled below in the LLVM call interceptor.
  if ((calleeName == "srandom" || calleeName.starts_with("srandom_")) &&
      callOp.getNumOperands() >= 1 && callOp.getNumResults() == 0) {
    uint32_t seed = static_cast<uint32_t>(
        getValue(procId, callOp.getOperand(0)).getUInt64());
    pendingSrandomSeed = seed;
    std::srand(static_cast<unsigned>(seed));
    LLVM_DEBUG(llvm::dbgs() << "  func.call @" << calleeName
                            << ": setting pending seed " << seed
                            << " (legacy stub, no object ptr)\n");
    return success();
  }

  // Handle class-level get_randstate()/set_randstate() stubs.
  if ((calleeName == "get_randstate" ||
       calleeName.starts_with("get_randstate_")) &&
      callOp.getNumResults() >= 1) {
    if (isa<LLVM::LLVMStructType>(callOp.getResult(0).getType())) {
      setValue(procId, callOp.getResult(0), InterpretedValue(0ULL, 128));
    } else {
      setValue(procId, callOp.getResult(0), InterpretedValue(0ULL, 64));
    }
    LLVM_DEBUG(llvm::dbgs() << "  func.call @" << calleeName
                            << ": returning stub state\n");
    return success();
  }
  if ((calleeName == "set_randstate" ||
       calleeName.starts_with("set_randstate_")) &&
      callOp.getNumResults() == 0) {
    LLVM_DEBUG(llvm::dbgs() << "  func.call @" << calleeName
                            << ": stub (ignored)\n");
    return success();
  }

  if (handleUvmFuncCallFastPath(procId, callOp, calleeName))
    return success();

  // Intercept uvm_sequence_item::get_root_sequence to prevent infinite loops
  // when the parent_sequence chain has cycles (due to incomplete constructor
  // initialization). Walk the parent chain with a depth limit and cycle
  // detection, return the last non-null parent (or self if no parent).
  if (calleeName.contains("get_root_sequence") &&
      !calleeName.contains("_name") &&
      callOp.getNumResults() == 1 && callOp.getNumOperands() >= 1) {
    InterpretedValue selfVal = getValue(procId, callOp.getOperand(0));
    uint64_t current = selfVal.isX() ? 0 : selfVal.getUInt64();
    uint64_t root = current;
    // Parent sequence is at field [0, 5] of uvm_sequence_item.
    // Byte offset: uvm_transaction(108) + i32(4) + i1(1) + i32(4) + ptr(8)
    //            = 108 + 4 + 1 + 4 + 8 = 125
    constexpr size_t kParentSeqOffset = 125;
    llvm::SmallDenseSet<uint64_t, 32> visited;
    visited.insert(current);
    for (int depth = 0; depth < 100 && current != 0; ++depth) {
      uint64_t off = 0;
      MemoryBlock *blk = findBlockByAddress(current + kParentSeqOffset, off);
      if (!blk)
        blk = findMemoryBlockByAddress(current + kParentSeqOffset, procId,
                                       &off);
      if (!blk || off + 8 > blk->data.size())
        break;
      uint64_t parent = 0;
      for (int i = 0; i < 8; ++i)
        parent |= static_cast<uint64_t>(blk->data[off + i]) << (i * 8);
      if (parent == 0)
        break;
      if (visited.count(parent))
        break; // Cycle detected
      visited.insert(parent);
      root = parent;
      current = parent;
    }
    setValue(procId, callOp.getResult(0),
            InterpretedValue(llvm::APInt(64, root)));
    return success();
  }

  // Intercept uvm_sequence_item::get_root_sequence_name to avoid cascading
  // failures from get_root_sequence. Returns an empty string struct.
  if (calleeName.contains("get_root_sequence_name") &&
      callOp.getNumResults() == 1) {
    if (isa<LLVM::LLVMStructType>(callOp.getResult(0).getType())) {
      setValue(procId, callOp.getResult(0), InterpretedValue(0ULL, 128));
    } else {
      setValue(procId, callOp.getResult(0), InterpretedValue(0ULL, 64));
    }
    return success();
  }

  bool isGetRoot = calleeName == "m_uvm_get_root";
  if (isGetRoot) {
    ++uvmGetRootDepth;
    if (uvmGetRootDepth == 1) {
      // First call - mark root construction as starting
      __moore_uvm_root_constructing_start();
      LLVM_DEBUG(llvm::dbgs() << "  UVM: m_uvm_get_root entry (depth=1), "
                              << "marking root construction started\n");
    } else {
      LLVM_DEBUG(llvm::dbgs() << "  UVM: m_uvm_get_root re-entry (depth="
                              << uvmGetRootDepth << ")\n");
    }
  }

  // Use RAII to ensure depth is decremented even on early returns
  auto decrementDepthOnExit = llvm::make_scope_exit([&]() {
    if (isGetRoot) {
      --uvmGetRootDepth;
      if (uvmGetRootDepth == 0) {
        // Last call completed - mark root construction as finished
        __moore_uvm_root_constructing_end();
        LLVM_DEBUG(llvm::dbgs() << "  UVM: m_uvm_get_root exit (depth=0), "
                                << "marking root construction ended\n");
      }
    }
  });

  // Find the called function
  auto *symbolOp = mlir::SymbolTable::lookupNearestSymbolFrom(
      callOp.getOperation(), callOp.getCalleeAttr());
  auto funcOp = dyn_cast_or_null<mlir::func::FuncOp>(symbolOp);
  if (!funcOp) {
    LLVM_DEBUG(llvm::dbgs() << "  Warning: Could not find function '"
                            << callOp.getCallee() << "'\n");
    // Set results to X
    for (Value result : callOp.getResults()) {
      setValue(procId, result,
               InterpretedValue::makeX(getTypeWidth(result.getType())));
    }
    return success();
  }

  // Check if function body is available (external functions cannot be called)
  if (funcOp.isExternal()) {
    // Try DPI function interception first (uvm_re_*, uvm_hdl_*, uvm_dpi_*)
    if (succeeded(interceptDPIFunc(procId, calleeName, callOp)))
      return success();

    LLVM_DEBUG(llvm::dbgs() << "  Warning: External function '"
                            << callOp.getCallee() << "' cannot be interpreted\n");
    for (Value result : callOp.getResults()) {
      setValue(procId, result,
               InterpretedValue::makeX(getTypeWidth(result.getType())));
    }
    return success();
  }

  // Get call arguments
  llvm::SmallVector<InterpretedValue, 4> args;
  for (Value operand : callOp.getOperands()) {
    args.push_back(getValue(procId, operand));
  }

  // Function result caching for hot UVM phase traversal functions.
  // These functions are pure (no side effects on global state) and called
  // thousands of times with the same args during phase graph construction.
  // Caching their results avoids re-executing expensive DFS traversals.
  bool isCacheableFunc = false;
  uint64_t cacheArgHash = 0;
  {
    llvm::StringRef calleeName = callOp.getCallee();
    // Cache functions involved in UVM phase graph traversal.
    // These are called repeatedly with the same args during get_common_domain()
    // and uvm_component::new, and their results only change when add() modifies
    // the graph. Invalidation happens in the add() handler below.
    if (calleeName.contains("uvm_phase::")) {
      if (calleeName.contains("get_schedule") ||
          calleeName.contains("get_domain") ||
          calleeName.contains("get_phase_type") ||
          calleeName.contains("::find") ||
          calleeName.contains("m_find_successor") ||
          calleeName.contains("m_find_predecessor") ||
          calleeName.contains("m_find_successor_by_name") ||
          calleeName.contains("m_find_predecessor_by_name")) {
        isCacheableFunc = true;
      }
    }
    if (isCacheableFunc) {
      // Compute hash of all argument values
      cacheArgHash = 0x517cc1b727220a95ULL; // seed
      for (const auto &arg : args) {
        uint64_t v = arg.isX() ? 0xDEADBEEFULL : arg.getUInt64();
        cacheArgHash = cacheArgHash * 0x9e3779b97f4a7c15ULL + v;
      }
      // Check cache
      auto &cacheState = processStates[procId];
      auto funcIt = cacheState.funcResultCache.find(funcOp.getOperation());
      if (funcIt != cacheState.funcResultCache.end()) {
        auto argIt = funcIt->second.find(cacheArgHash);
        if (argIt != funcIt->second.end()) {
          // Cache hit - return cached results
          const auto &cachedResults = argIt->second;
          auto results = callOp.getResults();
          for (auto [result, cached] : llvm::zip(results, cachedResults)) {
            setValue(procId, result, cached);
          }
          ++cacheState.funcCacheHits;
          LLVM_DEBUG(llvm::dbgs()
                     << "  func.call: cache hit for '" << calleeName
                     << "' (hits=" << cacheState.funcCacheHits << ")\n");
          return success();
        }
      }
    }
  }

  auto hashPhaseAddArgs =
      [&](llvm::ArrayRef<InterpretedValue> values) -> uint64_t {
    uint64_t hash = 0x517cc1b727220a95ULL;
    for (const auto &value : values.take_front(7)) {
      uint64_t bits = value.isX() ? 0xDEADBEEFDEADBEEFULL : value.getUInt64();
      hash ^= bits + 0x9e3779b97f4a7c15ULL + (hash << 6) + (hash >> 2);
    }
    return hash;
  };

  // Deduplicate repeated uvm_phase::add calls and invalidate cached phase-graph
  // queries only when a unique edge add is observed.
  if (callOp.getCallee().contains("uvm_phase::add")) {
    uint64_t edgeKey = hashPhaseAddArgs(args);
    if (!nativePhaseAddCallKeys.insert(edgeKey).second) {
      noteUvmFastPathActionHit("func.call.phase.add_duplicate");
      return success();
    }

    noteUvmFastPathActionHit("func.call.phase.add_observed");
    auto &cacheState = processStates[procId];
    if (!cacheState.funcResultCache.empty()) {
      LLVM_DEBUG(llvm::dbgs()
                 << "  func.call: invalidating func result cache ("
                 << cacheState.funcResultCache.size()
                 << " functions cached) due to phase::add\n");
      cacheState.funcResultCache.clear();
    }
  }

  // Intercept get_adjacent_successor_nodes to avoid the 1M ops limit.
  // The interpreted version runs a fixed-point loop that can exceed the op limit
  // on complex phase graphs. We reimplement it directly using native assoc array
  // operations, which is both faster and avoids the convergence issue.
  //
  // Algorithm: starting from phase->m_successors (field [11]), collect all
  // terminal nodes (phase_type == 1 = UVM_PHASE_NODE). Non-terminal nodes
  // are replaced with their own successors recursively until only terminals
  // remain. Result is stored as a dynamic array in %arg1.
  if (calleeName.contains("get_adjacent_successor_nodes")) {
    // Read %arg0 (phase pointer) and %arg1 (output dyn_array pointer)
    InterpretedValue arg0Val = args[0];
    InterpretedValue arg1Val = args[1];
    if (arg0Val.isX() || arg1Val.isX())
      return success();

    uint64_t phaseAddr = arg0Val.getUInt64();
    uint64_t outAddr = arg1Val.getUInt64();

    // Compute field offsets from the MLIR struct type (unaligned layout).
    // Walk the function body to find GEP ops that reference the uvm_phase struct,
    // then use getLLVMStructFieldOffset for layout-safe offset computation.
    unsigned field1Offset = 0;  // phase_type (field [1])
    unsigned field11Offset = 0; // m_successors (field [11])
    {
      LLVM::LLVMStructType phaseStructTy;
      for (Block &block : funcOp.getBody()) {
        for (Operation &op : block) {
          if (auto gepOp = dyn_cast<LLVM::GEPOp>(&op)) {
            if (auto structTy =
                    dyn_cast<LLVM::LLVMStructType>(gepOp.getElemType())) {
              if (structTy.isIdentified() &&
                  structTy.getName().contains("uvm_phase")) {
                phaseStructTy = structTy;
                break;
              }
            }
          }
        }
        if (phaseStructTy)
          break;
      }
      if (phaseStructTy) {
        field1Offset = getLLVMStructFieldOffset(phaseStructTy, 1);
        field11Offset = getLLVMStructFieldOffset(phaseStructTy, 11);
      } else {
        // Fallback: use unaligned offsets computed from known struct layout.
        // uvm_object = uvm_void{i32,ptr}(12) + {ptr,i64}(16) + i32(4) = 32
        // field[1]: i32 at offset 32
        // field[11]: ptr at offset 32+4+8+8+4+4+8+8+4+4+8 = 96
        field1Offset = 32;
        field11Offset = 96;
      }
    }

    // Helper: read the m_successors assoc array pointer (field [11]) from a phase
    auto getSuccessorsArray = [&](uint64_t phasePtr) -> void * {
      uint64_t ptrAddr = phasePtr + field11Offset;
      uint64_t blockOff = 0;
      MemoryBlock *block = findMemoryBlockByAddress(ptrAddr, procId, &blockOff);
      if (!block || !block->initialized || blockOff + 8 > block->data.size())
        return nullptr;
      uint64_t arrayAddr = 0;
      std::memcpy(&arrayAddr, block->data.data() + blockOff, 8);
      if (arrayAddr == 0)
        return nullptr;
      // Validate it's a real assoc array (must have been created via __moore_assoc_create)
      if (!validAssocArrayAddresses.contains(arrayAddr))
        return nullptr;
      return reinterpret_cast<void *>(arrayAddr);
    };

    // Helper: read phase_type (field [1]) from a phase pointer
    auto getPhaseType = [&](uint64_t phasePtr) -> int32_t {
      uint64_t field1Addr = phasePtr + field1Offset;
      uint64_t blockOff = 0;
      MemoryBlock *block = findMemoryBlockByAddress(field1Addr, procId, &blockOff);
      if (!block || !block->initialized || blockOff + 4 > block->data.size())
        return -1; // Unknown
      int32_t phaseType = 0;
      std::memcpy(&phaseType, block->data.data() + blockOff, 4);
      return phaseType;
    };

    // Collect all successor phase pointers from m_successors
    void *succArray = getSuccessorsArray(phaseAddr);
    if (!succArray) {
      // No successors - store empty dynamic array
      uint64_t outOff = 0;
      MemoryBlock *outBlock = findMemoryBlockByAddress(outAddr, procId, &outOff);
      if (outBlock && outBlock->initialized && outOff + 16 <= outBlock->data.size()) {
        std::memset(outBlock->data.data() + outOff, 0, 16);
      }
      return success();
    }

    // Fixed-point: collect terminal nodes (phase_type == 1).
    // Use a set to track visited nodes and avoid cycles.
    std::set<uint64_t> terminalNodes;
    std::set<uint64_t> visited;
    std::vector<uint64_t> worklist;

    // Initialize worklist from m_successors
    {
      uint8_t keyBuf[8] = {0};
      if (__moore_assoc_first(succArray, keyBuf)) {
        uint64_t key = 0;
        std::memcpy(&key, keyBuf, 8);
        worklist.push_back(key);
        while (__moore_assoc_next(succArray, keyBuf)) {
          std::memcpy(&key, keyBuf, 8);
          worklist.push_back(key);
        }
      }
    }

    // Process worklist: replace non-terminals with their successors
    constexpr int kMaxIterations = 10000;
    int iterations = 0;
    while (!worklist.empty() && iterations < kMaxIterations) {
      ++iterations;
      uint64_t nodeAddr = worklist.back();
      worklist.pop_back();

      if (visited.count(nodeAddr))
        continue;
      visited.insert(nodeAddr);

      int32_t phaseType = getPhaseType(nodeAddr);
      if (phaseType == 1) {
        // Terminal node (UVM_PHASE_NODE) - keep it
        terminalNodes.insert(nodeAddr);
      } else {
        // Non-terminal - add its successors to worklist
        void *nodeSuccArray = getSuccessorsArray(nodeAddr);
        if (nodeSuccArray) {
          uint8_t keyBuf[8] = {0};
          if (__moore_assoc_first(nodeSuccArray, keyBuf)) {
            uint64_t key = 0;
            std::memcpy(&key, keyBuf, 8);
            if (!visited.count(key))
              worklist.push_back(key);
            while (__moore_assoc_next(nodeSuccArray, keyBuf)) {
              std::memcpy(&key, keyBuf, 8);
              if (!visited.count(key))
                worklist.push_back(key);
            }
          }
        }
      }
    }

    LLVM_DEBUG(llvm::dbgs() << "  get_adjacent_successor_nodes: "
                            << terminalNodes.size() << " terminals from "
                            << visited.size() << " visited in "
                            << iterations << " iterations\n");

    // Build the output dynamic array
    int32_t count = static_cast<int32_t>(terminalNodes.size());
    int32_t byteCount = count * 8; // array of pointers
    auto dynArray = __moore_dyn_array_new(byteCount);
    // dynArray is struct { ptr, i64 }
    uint8_t *arrayData = reinterpret_cast<uint8_t *>(dynArray.data);

    int idx = 0;
    for (uint64_t nodeAddr : terminalNodes) {
      std::memcpy(arrayData + idx * 8, &nodeAddr, 8);
      ++idx;
    }

    // Store the dyn array struct into %arg1
    uint64_t outOff = 0;
    MemoryBlock *outBlock = findMemoryBlockByAddress(outAddr, procId, &outOff);
    if (outBlock && outOff + 16 <= outBlock->data.size()) {
      uint64_t dataPtr = reinterpret_cast<uint64_t>(dynArray.data);
      int64_t length = static_cast<int64_t>(count);
      std::memcpy(outBlock->data.data() + outOff, &dataPtr, 8);
      std::memcpy(outBlock->data.data() + outOff + 8, &length, 8);
      outBlock->initialized = true;
      // Register the native memory block for the array data
      if (dataPtr && byteCount > 0) {
        nativeMemoryBlocks[dataPtr] = static_cast<size_t>(byteCount);
      }
    }

    return success();
  }

  // Intercept uvm_create_random_seed — creates per-component/type random seeds.
  // The interpreted version is extremely slow (~600K+ steps) due to string
  // concatenation, associative array operations, and uvm_instance_scope() calls.
  // We replace it with a native CRC-based hash matching UVM semantics.
  if (calleeName == "uvm_pkg::uvm_create_random_seed" &&
      callOp.getNumResults() >= 1) {
    // Args: (struct<(ptr,i64)> type_id, struct<(ptr,i64)> inst_id)
    auto readStrArg = [&](size_t argIdx) -> std::string {
      if (argIdx >= args.size())
        return "";
      InterpretedValue strVal = args[argIdx];
      if (strVal.isX() || strVal.getWidth() < 128)
        return "";
      llvm::APInt bits = strVal.getAPInt();
      uint64_t strPtr = bits.extractBits(64, 0).getZExtValue();
      int64_t strLen = bits.extractBits(64, 64).getSExtValue();
      if (strPtr == 0 || strLen <= 0)
        return "";
      auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
      if (dynIt != dynamicStrings.end() && dynIt->second.first &&
          dynIt->second.second > 0)
        return std::string(
            dynIt->second.first,
            std::min(static_cast<size_t>(strLen),
                     static_cast<size_t>(dynIt->second.second)));
      uint64_t off = 0;
      MemoryBlock *gBlock = findBlockByAddress(strPtr, off);
      if (gBlock && gBlock->initialized) {
        size_t avail =
            std::min(static_cast<size_t>(strLen),
                     gBlock->data.size() - static_cast<size_t>(off));
        if (avail > 0)
          return std::string(
              reinterpret_cast<const char *>(gBlock->data.data() + off), avail);
      } else if (strPtr >= 0x10000) {
        const char *p = reinterpret_cast<const char *>(strPtr);
        return std::string(p, static_cast<size_t>(strLen));
      }
      return "";
    };

    std::string typeId = readStrArg(0);
    std::string instId = readStrArg(1);
    if (instId.empty())
      instId = "__global__";

    // Create hash input matching UVM: {type_id, "::", inst_id}
    std::string hashInput = typeId + "::" + instId;

    // Read uvm_global_random_seed
    uint32_t globalSeed = 1;
    {
      auto it = globalAddresses.find("uvm_pkg::uvm_global_random_seed");
      if (it != globalAddresses.end()) {
        uint64_t off = 0;
        MemoryBlock *blk = findBlockByAddress(it->second, off);
        if (blk && blk->initialized && blk->data.size() >= off + 4)
          std::memcpy(&globalSeed, blk->data.data() + off, 4);
      }
      if (globalSeed == 0)
        globalSeed = 1;
    }

    // Look up or create seed entry
    auto &seedEntry = nativeRandomSeedTable[instId][typeId];
    if (seedEntry.first == 0) {
      // First call: compute CRC hash (matching uvm_oneway_hash algorithm)
      uint32_t crc1 = 0xFFFFFFFF;
      for (size_t i = 0; i < hashInput.size(); ++i) {
        uint8_t currentByte = static_cast<uint8_t>(hashInput[i]);
        if (currentByte == 0)
          break;
        for (int bit = 0; bit < 8; ++bit) {
          bool msb = (crc1 >> 31) & 1;
          crc1 <<= 1;
          if (msb ^ ((currentByte >> bit) & 1)) {
            crc1 ^= 0x04c11db6;
            crc1 |= 1;
          }
        }
      }
      uint32_t reversed = ((crc1 & 0xFF) << 24) |
                          (((crc1 >> 8) & 0xFF) << 16) |
                          (((crc1 >> 16) & 0xFF) << 8) | ((crc1 >> 24) & 0xFF);
      seedEntry.first = globalSeed + ~reversed;
      seedEntry.second = 0;
    }

    uint32_t result = seedEntry.first + seedEntry.second;
    seedEntry.second++;

    setValue(procId, callOp.getResult(0),
            InterpretedValue(llvm::APInt(32, static_cast<uint64_t>(result))));
    return success();
  }

  // Intercept uvm_oneway_hash — a CRC-based string hash used by
  // uvm_create_random_seed. The compiled IR version uses llhd.ref types that
  // fail in the interpreter. We implement it natively using the algorithm from
  // uvm_misc.svh (UVM_STR_CRC_POLYNOMIAL = 0x04c11db6).
  if (calleeName == "uvm_pkg::uvm_oneway_hash") {
    // Args: (struct<(ptr,i64)> string_in, i32 seed)
    // Read string from struct<(ptr, i64)> — same pattern as config_db.
    std::string strIn;
    if (callOp.getNumOperands() >= 1) {
      InterpretedValue strVal = args[0];
      if (!strVal.isX() && strVal.getWidth() >= 128) {
        llvm::APInt bits = strVal.getAPInt();
        uint64_t strPtr = bits.extractBits(64, 0).getZExtValue();
        int64_t strLen = bits.extractBits(64, 64).getSExtValue();
        if (strPtr != 0 && strLen > 0) {
          // Try dynamicStrings
          auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
          if (dynIt != dynamicStrings.end() && dynIt->second.first &&
              dynIt->second.second > 0) {
            strIn = std::string(
                dynIt->second.first,
                std::min(static_cast<size_t>(strLen),
                         static_cast<size_t>(dynIt->second.second)));
          } else {
            // Try global/malloc memory
            uint64_t off = 0;
            MemoryBlock *gBlock = findBlockByAddress(strPtr, off);
            if (gBlock && gBlock->initialized) {
              size_t avail =
                  std::min(static_cast<size_t>(strLen),
                           gBlock->data.size() - static_cast<size_t>(off));
              if (avail > 0)
                strIn = std::string(
                    reinterpret_cast<const char *>(gBlock->data.data() + off),
                    avail);
            } else if (strPtr >= 0x10000) {
              // Native memory (direct pointer read)
              const char *p = reinterpret_cast<const char *>(strPtr);
              strIn = std::string(p, static_cast<size_t>(strLen));
            }
          }
        }
      }
    }
    uint32_t seed = 0;
    if (callOp.getNumOperands() >= 2) {
      InterpretedValue seedVal = args[1];
      if (!seedVal.isX())
        seed = static_cast<uint32_t>(seedVal.getUInt64());
    }
    if (seed == 0) {
      // Use uvm_global_random_seed — load from the global variable
      auto it = globalAddresses.find("uvm_pkg::uvm_global_random_seed");
      if (it != globalAddresses.end()) {
        uint64_t off = 0;
        MemoryBlock *blk = findBlockByAddress(it->second, off);
        if (blk && blk->initialized && blk->data.size() >= off + 4) {
          std::memcpy(&seed, blk->data.data() + off, 4);
        }
      }
      if (seed == 0)
        seed = 1; // fallback
    }
    // CRC computation matching uvm_misc.svh
    uint32_t result = seed;
    uint32_t crc1 = 0xFFFFFFFF;
    for (size_t i = 0; i < strIn.size(); ++i) {
      uint8_t currentByte = static_cast<uint8_t>(strIn[i]);
      if (currentByte == 0)
        break;
      for (int bit = 0; bit < 8; ++bit) {
        bool msb = (crc1 >> 31) & 1;
        crc1 <<= 1;
        if (msb ^ ((currentByte >> bit) & 1)) {
          crc1 ^= 0x04c11db6;
          crc1 |= 1;
        }
      }
    }
    // Byte-reverse crc1 and add to result
    uint32_t reversed = ((crc1 & 0xFF) << 24) | (((crc1 >> 8) & 0xFF) << 16) |
                        (((crc1 >> 16) & 0xFF) << 8) | ((crc1 >> 24) & 0xFF);
    result += ~reversed;
    auto resultVal = callOp.getResult(0);
    setValue(procId, resultVal,
            InterpretedValue(llvm::APInt(32, static_cast<uint64_t>(result))));
    return success();
  }

  // Intercept uvm_phase::get_objection and uvm_phase_hopper::get_objection
  // to bypass the interpreted version which fails because get_name() virtual
  // dispatch crashes during objection object creation. We use a native
  // objection handle map instead.
  // This is critical for run_phase: without working objections, raise_objection
  // fails → phase completes immediately → simulation stays at time 0.
  // The phase_hopper variant is needed for newer UVM versions that use a
  // separate phase hopper class with its own get_objection/raise/drop/wait_for.
  if ((calleeName.contains("uvm_phase::get_objection") ||
       calleeName.contains("phase_hopper::get_objection")) &&
      !calleeName.contains("get_objection_count") &&
      !calleeName.contains("get_objection_total")) {
    InterpretedValue phaseVal = args[0]; // %arg0 = this (phase pointer)
    if (phaseVal.isX()) {
      // Return null
      auto result = callOp.getResult(0);
      setValue(procId, result, InterpretedValue(llvm::APInt(64, 0)));
      return success();
    }
    uint64_t phaseAddr = phaseVal.getUInt64();

    // Check if we already have an objection handle for this phase
    auto it = phaseObjectionHandles.find(phaseAddr);
    if (it != phaseObjectionHandles.end()) {
      // Return the handle encoded as a non-null pointer so UVM code sees
      // a valid objection object. The actual objection logic is handled
      // by the raise/drop interceptors below.
      auto result = callOp.getResult(0);
      uint64_t syntheticAddr = 0xE0000000ULL + static_cast<uint64_t>(it->second);
      setValue(procId, result, InterpretedValue(llvm::APInt(64, syntheticAddr)));
      return success();
    }

    // Create a new objection handle for this phase via the runtime.
    std::string phaseName = "phase_" + std::to_string(phaseAddr);
    MooreObjectionHandle handle = __moore_objection_create(
        phaseName.c_str(), static_cast<int64_t>(phaseName.size()));
    phaseObjectionHandles[phaseAddr] = handle;

    auto result = callOp.getResult(0);
    uint64_t syntheticAddr = 0xE0000000ULL + static_cast<uint64_t>(handle);
    setValue(procId, result, InterpretedValue(llvm::APInt(64, syntheticAddr)));
    return success();
  }

  // Intercept uvm_phase::raise_objection and drop_objection (and their
  // phase_hopper variants) to use native objection handles from the
  // get_objection interceptor above.
  if ((calleeName.contains("uvm_phase::raise_objection") ||
       calleeName.contains("uvm_phase::drop_objection") ||
       calleeName.contains("phase_hopper::raise_objection") ||
       calleeName.contains("phase_hopper::drop_objection")) &&
      !calleeName.contains("uvm_objection::")) {
    InterpretedValue phaseVal = args[0]; // %arg0 = this (phase pointer)
    // %arg2 = description string (struct<(ptr,i64)>), %arg3 = count (i32)
    InterpretedValue countVal = args.size() > 3 ? args[3] : InterpretedValue(llvm::APInt(32, 1));

    if (phaseVal.isX())
      return success();

    uint64_t phaseAddr = phaseVal.getUInt64();
    int64_t count = countVal.isX() ? 1 : static_cast<int64_t>(countVal.getUInt64());

    // Get or create the objection handle for this phase
    auto it = phaseObjectionHandles.find(phaseAddr);
    MooreObjectionHandle handle;
    if (it != phaseObjectionHandles.end()) {
      handle = it->second;
    } else {
      std::string phaseName = "phase_" + std::to_string(phaseAddr);
      handle = __moore_objection_create(
          phaseName.c_str(), static_cast<int64_t>(phaseName.size()));
      phaseObjectionHandles[phaseAddr] = handle;
    }

    if (calleeName.contains("raise_objection")) {
      raisePhaseObjection(handle, count);
    } else {
      dropPhaseObjection(handle, count);
    }
    return success();
  }

  // Intercept uvm_objection methods that operate on our synthetic objection
  // pointers (0xE0000000 + handle_id). The phase engine calls these to check
  // whether all objections have been dropped before proceeding.
  if (calleeName.contains("uvm_objection::")) {
    // Map synthetic pointer back to objection handle
    auto syntheticToHandle = [](uint64_t addr) -> MooreObjectionHandle {
      if (addr >= 0xE0000000ULL && addr < 0xF0000000ULL)
        return static_cast<MooreObjectionHandle>(addr - 0xE0000000ULL);
      return MOORE_OBJECTION_INVALID_HANDLE;
    };

    if (calleeName.contains("get_objection_total") ||
        calleeName.contains("get_objection_count")) {
      InterpretedValue selfVal = args[0]; // uvm_objection* this
      if (selfVal.isX()) {
        auto result = callOp.getResult(0);
        setValue(procId, result, InterpretedValue(llvm::APInt(32, 0)));
        return success();
      }
      MooreObjectionHandle handle = syntheticToHandle(selfVal.getUInt64());
      int64_t count = 0;
      if (handle != MOORE_OBJECTION_INVALID_HANDLE)
        count = __moore_objection_get_count(handle);
      auto result = callOp.getResult(0);
      setValue(procId, result,
              InterpretedValue(llvm::APInt(32, static_cast<uint64_t>(count))));
      return success();
    }

    if (calleeName.contains("raise_objection")) {
      InterpretedValue selfVal = args[0];
      InterpretedValue countVal =
          args.size() > 3 ? args[3] : InterpretedValue(llvm::APInt(32, 1));
      if (!selfVal.isX()) {
        MooreObjectionHandle handle = syntheticToHandle(selfVal.getUInt64());
        int64_t count =
            countVal.isX() ? 1 : static_cast<int64_t>(countVal.getUInt64());
        if (handle != MOORE_OBJECTION_INVALID_HANDLE)
          raisePhaseObjection(handle, count);
      }
      return success();
    }

    if (calleeName.contains("drop_objection")) {
      InterpretedValue selfVal = args[0];
      InterpretedValue countVal =
          args.size() > 3 ? args[3] : InterpretedValue(llvm::APInt(32, 1));
      if (!selfVal.isX()) {
        MooreObjectionHandle handle = syntheticToHandle(selfVal.getUInt64());
        int64_t count =
            countVal.isX() ? 1 : static_cast<int64_t>(countVal.getUInt64());
        if (handle != MOORE_OBJECTION_INVALID_HANDLE)
          dropPhaseObjection(handle, count);
      }
      return success();
    }

    // wait_for: phase engine waits until all objections are dropped.
    // We poll the objection count periodically using delta steps (like
    // wait_condition). When count reaches 0 AND at least one objection
    // was raised at some point, the phase can proceed.
    // This is critical: the count starts at 0, but we must NOT return
    // until objections have been raised AND then dropped (e.g., run_phase
    // raises objections, then eventually drops them all).
    if (calleeName.contains("wait_for")) {
      // Get the objection handle from the synthetic self pointer.
      InterpretedValue selfVal = args[0];
      MooreObjectionHandle handle = MOORE_OBJECTION_INVALID_HANDLE;
      if (!selfVal.isX())
        handle = syntheticToHandle(selfVal.getUInt64());

      // Check current objection count.
      int64_t count = 0;
      if (handle != MOORE_OBJECTION_INVALID_HANDLE)
        count = __moore_objection_get_count(handle);

      // Track per-proc state: whether objections were ever raised and
      // how many yields with count==0 after that.
      struct WaitForState {
        bool wasEverRaised = false;
        int zeroYields = 0;
      };
      static std::map<ProcessId, WaitForState> waitForState;
      auto &wfs = waitForState[procId];

      if (count > 0) {
        // Objections are currently raised — mark as seen.
        wfs.wasEverRaised = true;
        wfs.zeroYields = 0;
      } else if (wfs.wasEverRaised) {
        // Count is 0 and objections were raised before — they've been
        // dropped. Yield a few times to let any pending drops settle,
        // then return.
        if (wfs.zeroYields >= 3) {
          wfs = WaitForState{}; // Reset for next use.
          return success();
        }
        ++wfs.zeroYields;
      }
      // If wasEverRaised is false and count==0, keep polling — forked
      // processes haven't raised objections yet.

      // Suspend this process and poll via delta/time steps.
      auto &state = processStates[procId];
      state.waiting = true;

      // Schedule a poll callback. Use the same bounded-delta strategy as
      // wait_condition: delta steps first (keeps $time==0 during UVM init),
      // then fall back to real time to avoid infinite delta loops.
      SimTime currentTime = scheduler.getCurrentTime();
      constexpr uint32_t kMaxDeltaPolls = 1000;
      constexpr int64_t kFallbackPollDelayFs = 10000000; // 10 ps
      SimTime targetTime;
      if (currentTime.deltaStep < kMaxDeltaPolls)
        targetTime = currentTime.nextDelta();
      else
        targetTime = currentTime.advanceTime(kFallbackPollDelayFs);

      // Save the iterator to this call op so we can re-execute it.
      // executeStep() already advanced currentOp past this call, so we
      // need to go back by one to point at this LLVM::CallOp.
      auto callIt = mlir::Block::iterator(callOp.getOperation());

      scheduler.getEventScheduler().schedule(
          targetTime, SchedulingRegion::Active,
          Event([this, procId, callIt]() {
            auto &st = processStates[procId];
            st.waiting = false;
            // Rewind currentOp to re-execute the wait_for call so the
            // interceptor can re-check the objection count.
            st.currentOp = callIt;
            scheduler.scheduleProcess(procId, SchedulingRegion::Active);
          }));

      return success();
    }
  }

  // Intercept UVM config_db implementation set/get/exists methods.
  // These are stub methods generated by MooreToCore for the UVM config_db class.
  // We replace them with a real key-value store so config_db actually works.
  // Note: class name may be "config_db_default_implementation_t", so we match
  // on "config_db" + "implementation" separately.
  if (calleeName.contains("config_db") && calleeName.contains("implementation") &&
      (calleeName.contains("::set") || calleeName.contains("::get") ||
       calleeName.contains("::exists"))) {

    // Helper: read a string from a struct<(ptr, i64)> value argument.
    auto readStringFromStructVal = [&](Value operand) -> std::string {
      InterpretedValue val = getValue(procId, operand);
      if (val.isX() || val.getWidth() < 128)
        return "";
      // Low 64 bits = pointer, high 64 bits = length
      llvm::APInt bits = val.getAPInt();
      uint64_t strPtr = bits.extractBits(64, 0).getZExtValue();
      int64_t strLen = bits.extractBits(64, 64).getSExtValue();
      if (strPtr == 0 || strLen <= 0)
        return "";

      // Try dynamicStrings registry
      auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
      if (dynIt != dynamicStrings.end() && dynIt->second.first &&
          dynIt->second.second > 0) {
        return std::string(dynIt->second.first,
                           std::min(static_cast<size_t>(strLen),
                                    static_cast<size_t>(dynIt->second.second)));
      }

      // Try global/malloc memory via O(log n) range index
      {
        uint64_t off = 0;
        MemoryBlock *gBlock = findBlockByAddress(strPtr, off);
        if (gBlock && gBlock->initialized) {
          size_t avail = std::min(static_cast<size_t>(strLen),
                                  gBlock->data.size() - static_cast<size_t>(off));
          if (avail > 0)
            return std::string(
                reinterpret_cast<const char *>(gBlock->data.data() + off),
                avail);
        }
      }

      // Try native memory (direct pointer read)
      bool isNative = false;
      for (auto &entry : nativeMemoryBlocks) {
        if (strPtr >= entry.first && strPtr < entry.first + entry.second) {
          isNative = true;
          break;
        }
      }
      if (isNative || strPtr >= 0x10000) {
        const char *p = reinterpret_cast<const char *>(strPtr);
        return std::string(p, static_cast<size_t>(strLen));
      }

      return "";
    };

    if (calleeName.contains("::set")) {
      // Signature: (self, cntxt, inst_name, field_name, value, accessor, pool, cntxt_ptr)
      if (callOp.getNumOperands() >= 5) {
        std::string instName = readStringFromStructVal(callOp.getOperand(2));
        std::string fieldName = readStringFromStructVal(callOp.getOperand(3));
        std::string key = instName + "." + fieldName;

        // Serialize the value (arg4) to bytes
        InterpretedValue valueArg = getValue(procId, callOp.getOperand(4));
        unsigned valueBits = valueArg.getWidth();
        unsigned valueBytes = (valueBits + 7) / 8;
        std::vector<uint8_t> valueData(valueBytes, 0);
        if (!valueArg.isX()) {
          llvm::APInt valBits = valueArg.getAPInt();
          for (unsigned i = 0; i < valueBytes; ++i)
            valueData[i] = static_cast<uint8_t>(
                valBits.extractBits(8, i * 8).getZExtValue());
        }

        configDbEntries[key] = std::move(valueData);
        LLVM_DEBUG(llvm::dbgs()
                   << "  config_db::set(\"" << key << "\", "
                   << valueBits << " bits)\n");
      }
      return success();
    }

    if (calleeName.contains("::get")) {
      // Signature: (self, cntxt, inst_name, field_name, output_ref) -> i1
      if (callOp.getNumOperands() >= 5 && callOp.getNumResults() >= 1) {
        std::string instName = readStringFromStructVal(callOp.getOperand(2));
        std::string fieldName = readStringFromStructVal(callOp.getOperand(3));
        std::string key = instName + "." + fieldName;

        auto it = configDbEntries.find(key);
        if (it == configDbEntries.end()) {
          // Try wildcard match: look for entries where field name matches
          for (auto &[k, v] : configDbEntries) {
            size_t dotPos = k.rfind('.');
            if (dotPos != std::string::npos &&
                k.substr(dotPos + 1) == fieldName) {
              it = configDbEntries.find(k);
              break;
            }
          }
        }

        if (it != configDbEntries.end()) {
          // Found: write value to output ref (arg4)
          Value outputRef = callOp.getOperand(4);
          const std::vector<uint8_t> &valueData = it->second;
          InterpretedValue refVal = getValue(procId, outputRef);
          Type refType = outputRef.getType();

          if (auto refT = dyn_cast<llhd::RefType>(refType)) {
            Type innerType = refT.getNestedType();
            unsigned innerBits = getTypeWidth(innerType);
            unsigned innerBytes = (innerBits + 7) / 8;

            llvm::APInt valueBits(innerBits, 0);
            for (unsigned i = 0;
                 i < std::min(innerBytes, (unsigned)valueData.size()); ++i) {
              if (valueData[i] != 0)
                valueBits |= llvm::APInt(innerBits, valueData[i]) << (i * 8);
            }
            InterpretedValue value(valueBits);

            unsigned sigId = resolveSignalId(outputRef);
            if (sigId > 0)
              pendingEpsilonDrives[sigId] = value;
            uint64_t addr = refVal.isX() ? 0 : refVal.getUInt64();
            if (addr > 0) {
              uint64_t offset = 0;
              auto *block = findMemoryBlockByAddress(addr, procId, &offset);
              if (block) {
                writeConfigDbBytesToMemoryBlock(
                    block, offset, valueData, innerBytes,
                    /*zeroFillMissing=*/true);
              } else {
                uint64_t nativeOffset = 0;
                size_t nativeSize = 0;
                if (findNativeMemoryBlockByAddress(addr, &nativeOffset,
                                                   &nativeSize)) {
                  writeConfigDbBytesToNativeMemory(
                      addr, nativeOffset, nativeSize, valueData, innerBytes,
                      /*zeroFillMissing=*/true);
                }
              }
            }
          } else if (isa<LLVM::LLVMPointerType>(refType)) {
            uint64_t addr = refVal.isX() ? 0 : refVal.getUInt64();
            if (addr > 0) {
              uint64_t offset = 0;
              auto *block = findMemoryBlockByAddress(addr, procId, &offset);
              if (block) {
                writeConfigDbBytesToMemoryBlock(
                    block, offset, valueData,
                    static_cast<unsigned>(valueData.size()),
                    /*zeroFillMissing=*/false);
              } else {
                uint64_t nativeOffset = 0;
                size_t nativeSize = 0;
                if (findNativeMemoryBlockByAddress(addr, &nativeOffset,
                                                   &nativeSize)) {
                  writeConfigDbBytesToNativeMemory(
                      addr, nativeOffset, nativeSize, valueData,
                      static_cast<unsigned>(valueData.size()),
                      /*zeroFillMissing=*/false);
                }
              }
            }
          }

          setValue(procId, callOp.getResult(0),
                  InterpretedValue(llvm::APInt(1, 1)));
          LLVM_DEBUG(llvm::dbgs()
                     << "  config_db::get(\"" << key << "\") -> found ("
                     << valueData.size() << " bytes)\n");
        } else {
          setValue(procId, callOp.getResult(0),
                  InterpretedValue(llvm::APInt(1, 0)));
          LLVM_DEBUG(llvm::dbgs()
                     << "  config_db::get(\"" << key << "\") -> not found\n");
        }
        return success();
      }
    }

    if (calleeName.contains("::exists")) {
      if (callOp.getNumOperands() >= 5 && callOp.getNumResults() >= 1) {
        std::string instName = readStringFromStructVal(callOp.getOperand(2));
        std::string fieldName = readStringFromStructVal(callOp.getOperand(3));
        std::string key = instName + "." + fieldName;

        bool found = configDbEntries.count(key) > 0;
        if (!found) {
          for (auto &[k, v] : configDbEntries) {
            size_t dotPos = k.rfind('.');
            if (dotPos != std::string::npos &&
                k.substr(dotPos + 1) == fieldName) {
              found = true;
              break;
            }
          }
        }

        setValue(procId, callOp.getResult(0),
                InterpretedValue(llvm::APInt(1, found ? 1 : 0)));
        LLVM_DEBUG(llvm::dbgs()
                   << "  config_db::exists(\"" << key << "\") -> "
                   << (found ? "true" : "false") << "\n");
        return success();
      }
    }
  }

  // Intercept UVM resource_db_implementation_t::set/read_by_name methods.
  // Like config_db_implementation, these are stub functions that need real
  // key-value store behavior. resource_db is used by the sv-tests UVM
  // testbenches to pass virtual interfaces from the module to UVM components.
  if (calleeName.contains("resource_db") && calleeName.contains("implementation") &&
      (calleeName.contains("::set") || calleeName.contains("::read_by_name"))) {

    // Reuse the config_db string helper
    auto readStringFromStructVal2 = [&](Value operand) -> std::string {
      InterpretedValue val = getValue(procId, operand);
      if (val.isX() || val.getWidth() < 128)
        return "";
      llvm::APInt bits = val.getAPInt();
      uint64_t strPtr = bits.extractBits(64, 0).getZExtValue();
      int64_t strLen = bits.extractBits(64, 64).getSExtValue();
      if (strPtr == 0 || strLen <= 0)
        return "";
      auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
      if (dynIt != dynamicStrings.end() && dynIt->second.first &&
          dynIt->second.second > 0) {
        return std::string(dynIt->second.first,
                           std::min(static_cast<size_t>(strLen),
                                    static_cast<size_t>(dynIt->second.second)));
      }
      uint64_t off = 0;
      MemoryBlock *gBlock = findBlockByAddress(strPtr, off);
      if (gBlock && gBlock->initialized) {
        size_t avail = std::min(static_cast<size_t>(strLen),
                                gBlock->data.size() - static_cast<size_t>(off));
        if (avail > 0)
          return std::string(
              reinterpret_cast<const char *>(gBlock->data.data() + off), avail);
      }
      for (auto &entry : nativeMemoryBlocks) {
        if (strPtr >= entry.first && strPtr < entry.first + entry.second) {
          const char *p = reinterpret_cast<const char *>(strPtr);
          return std::string(p, static_cast<size_t>(strLen));
        }
      }
      if (strPtr >= 0x10000) {
        const char *p = reinterpret_cast<const char *>(strPtr);
        return std::string(p, static_cast<size_t>(strLen));
      }
      return "";
    };

    if (calleeName.contains("::set") && !calleeName.contains("set_default") &&
        !calleeName.contains("set_override") &&
        !calleeName.contains("set_anonymous")) {
      // Signature: (self, scope, field_name, value, accessor)
      if (callOp.getNumOperands() >= 4) {
        std::string scope = readStringFromStructVal2(callOp.getOperand(1));
        std::string fieldName = readStringFromStructVal2(callOp.getOperand(2));
        std::string key = scope + "." + fieldName;

        InterpretedValue valueArg = getValue(procId, callOp.getOperand(3));
        unsigned valueBits = valueArg.getWidth();
        unsigned valueBytes = (valueBits + 7) / 8;
        std::vector<uint8_t> valueData(valueBytes, 0);
        if (!valueArg.isX()) {
          llvm::APInt valBits = valueArg.getAPInt();
          for (unsigned i = 0; i < valueBytes; ++i)
            valueData[i] = static_cast<uint8_t>(
                valBits.extractBits(8, i * 8).getZExtValue());
        }

        configDbEntries[key] = std::move(valueData);
        LLVM_DEBUG(llvm::dbgs()
                   << "  resource_db::set(\"" << key << "\", "
                   << valueBits << " bits)\n");
      }
      return success();
    }

    if (calleeName.contains("::read_by_name")) {
      // Signature: (self, scope, field_name, output_ref, accessor) -> i1
      if (callOp.getNumOperands() >= 4 && callOp.getNumResults() >= 1) {
        std::string scope = readStringFromStructVal2(callOp.getOperand(1));
        std::string fieldName = readStringFromStructVal2(callOp.getOperand(2));
        std::string key = scope + "." + fieldName;

        auto it = configDbEntries.find(key);
        if (it == configDbEntries.end()) {
          for (auto &[k, v] : configDbEntries) {
            size_t dotPos = k.rfind('.');
            if (dotPos != std::string::npos &&
                k.substr(dotPos + 1) == fieldName) {
              it = configDbEntries.find(k);
              break;
            }
          }
        }

        if (it != configDbEntries.end()) {
          Value outputRef = callOp.getOperand(3);
          const std::vector<uint8_t> &valueData = it->second;
          InterpretedValue refVal = getValue(procId, outputRef);
          Type refType = outputRef.getType();

          if (auto refT = dyn_cast<llhd::RefType>(refType)) {
            // llhd.ref output: write via signal drive
            Type innerType = refT.getNestedType();
            unsigned innerBits = getTypeWidth(innerType);
            unsigned innerBytes = (innerBits + 7) / 8;
            llvm::APInt valueBits(innerBits, 0);
            for (unsigned i = 0;
                 i < std::min(innerBytes, (unsigned)valueData.size()); ++i)
              safeInsertBits(valueBits,llvm::APInt(8, valueData[i]), i * 8);
            SignalId sigId2 = resolveSignalId(outputRef);
            if (sigId2 != 0) {
              InterpretedValue driveVal(valueBits);
              pendingEpsilonDrives[sigId2] = driveVal;
            }
            // Also write to memory so llvm.load sees the updated value.
            if (!refVal.isX()) {
              uint64_t addr = refVal.getUInt64();
              if (addr > 0) {
                uint64_t offset = 0;
                auto *block = findMemoryBlockByAddress(addr, procId, &offset);
                if (!block)
                  block = findBlockByAddress(addr, offset);
                if (block) {
                  writeConfigDbBytesToMemoryBlock(
                      block, offset, valueData, innerBytes,
                      /*zeroFillMissing=*/true);
                } else {
                  uint64_t nativeOffset = 0;
                  size_t nativeSize = 0;
                  if (findNativeMemoryBlockByAddress(addr, &nativeOffset,
                                                     &nativeSize)) {
                    writeConfigDbBytesToNativeMemory(
                        addr, nativeOffset, nativeSize, valueData, innerBytes,
                        /*zeroFillMissing=*/true);
                  }
                }
              }
            }
          } else if (isa<LLVM::LLVMPointerType>(refType)) {
            // Pointer output: write directly to memory
            if (!refVal.isX()) {
              uint64_t outputAddr = refVal.getUInt64();
              uint64_t outOff = 0;
              MemoryBlock *outBlock =
                  findMemoryBlockByAddress(outputAddr, procId, &outOff);
              if (!outBlock)
                outBlock = findBlockByAddress(outputAddr, outOff);
              if (outBlock) {
                writeConfigDbBytesToMemoryBlock(
                    outBlock, outOff, valueData,
                    static_cast<unsigned>(valueData.size()),
                    /*zeroFillMissing=*/false);
              } else {
                uint64_t nativeOffset = 0;
                size_t nativeSize = 0;
                if (findNativeMemoryBlockByAddress(outputAddr, &nativeOffset,
                                                   &nativeSize)) {
                  writeConfigDbBytesToNativeMemory(
                      outputAddr, nativeOffset, nativeSize, valueData,
                      static_cast<unsigned>(valueData.size()),
                      /*zeroFillMissing=*/false);
                }
              }
            }
          }

          setValue(procId, callOp.getResult(0),
                  InterpretedValue(llvm::APInt(1, 1))); // true = success
          LLVM_DEBUG(llvm::dbgs()
                     << "  resource_db::read_by_name(\"" << key
                     << "\") -> found\n");
          return success();
        }

        setValue(procId, callOp.getResult(0),
                InterpretedValue(llvm::APInt(1, 0))); // false = not found
        LLVM_DEBUG(llvm::dbgs() << "  resource_db::read_by_name(\"" << key
                                << "\") -> not found\n");
        return success();
      }
    }
  }

  // Intercept UVM report handler configuration functions that use vtable
  // dispatch through unrealized_conversion_cast. The pool vtable entries may
  // be null or mismatched, causing insertBits assertion failures during
  // call_indirect argument setup. These are non-critical configuration
  // functions — safe to no-op.
  if (calleeName.contains("uvm_report_handler") &&
      (calleeName.contains("set_id_action") ||
       calleeName.contains("set_severity_id_action") ||
       calleeName.contains("set_id_verbosity") ||
       calleeName.contains("set_severity_id_verbosity") ||
       calleeName.contains("set_severity_action") ||
       calleeName.contains("set_severity_file"))) {
    LLVM_DEBUG(llvm::dbgs()
               << "  func.call: " << calleeName
               << " intercepted (no-op, avoids vtable dispatch crash)\n");
    return success();
  }

  // Check call depth to prevent stack overflow from deep recursion (UVM patterns)
  // Intercept uvm_wait_for_nba_region: this UVM synchronization primitive
  // increments a counter and waits for it to change. In our interpreter,
  // the memory event watcher never fires because no other process writes
  // to the counter. Replace with a single delta cycle delay (schedule the
  // process to resume in the next Active region at the same simulation time).
  if (calleeName == "uvm_pkg::uvm_wait_for_nba_region") {
    // Yield the current process so other processes (e.g. just-forked
    // master_phase_process children) get a chance to run first.
    // executeStep already advanced currentOp past this call, so when the
    // process resumes it will continue from the next operation.
    auto &nbaState = processStates[procId];
    nbaState.waiting = true;
    scheduler.scheduleProcess(procId, SchedulingRegion::Reactive);
    return success();
  }

  auto &state = processStates[procId];
  constexpr size_t maxCallDepth = 200;
  if (state.callDepth >= maxCallDepth) {
    LLVM_DEBUG(llvm::dbgs() << "  func.call: max call depth (" << maxCallDepth
                            << ") exceeded, returning zero\n");
    for (Value result : callOp.getResults()) {
      unsigned width = getTypeWidth(result.getType());
      setValue(procId, result, InterpretedValue(llvm::APInt(width, 0)));
    }
    return success();
  }

  // Recursive DFS cycle detection: when a function calls itself (directly or
  // via mutual recursion), track the arg0 (`this` pointer) to prevent
  // exponential blowup from DFS traversal over graph diamonds. UVM's
  // m_find_successor iterates successors and recurses without a visited set,
  // causing O(2^N) revisits on diamond patterns in the phase DAG.
  Operation *funcKey = funcOp.getOperation();
  uint64_t arg0Val = 0;
  bool hasArg0 = !args.empty() && !args[0].isX();
  if (hasArg0)
    arg0Val = args[0].getUInt64();

  // Check if recursion depth exceeded for this (func, arg0) pair
  constexpr unsigned maxRecursionDepth = 20;
  auto &depthMap = state.recursionVisited[funcKey];
  if (hasArg0 && state.callDepth > 0) {
    unsigned &depth = depthMap[arg0Val];
    if (depth >= maxRecursionDepth) {
      LLVM_DEBUG(llvm::dbgs()
                 << "  func.call: recursion depth " << depth
                 << " exceeded for '" << funcOp.getName() << "' with arg0=0x"
                 << llvm::format_hex(arg0Val, 16)
                 << " at callDepth " << state.callDepth << ", returning zero\n");
      for (Value result : callOp.getResults()) {
        unsigned width = getTypeWidth(result.getType());
        setValue(procId, result, InterpretedValue(llvm::APInt(width, 0)));
      }
      return success();
    }
  }

  // Increment depth counter before recursing
  bool addedToVisited = hasArg0;
  if (hasArg0) {
    ++depthMap[arg0Val];
  }

  // Execute the function body with depth tracking
  ++state.callDepth;
  llvm::SmallVector<InterpretedValue, 4> returnValues;
  // Pass the call operation so it can be saved in call stack frames
  LogicalResult funcResult =
      interpretFuncBody(procId, funcOp, args, returnValues, callOp);
  --state.callDepth;

  // Decrement depth counter after returning
  if (addedToVisited) {
    auto &depthRef = processStates[procId].recursionVisited[funcKey][arg0Val];
    if (depthRef > 0)
      --depthRef;
  }

  if (failed(funcResult)) {
    // Check if the failure was actually a suspension
    auto &failState = processStates[procId];
    if (failState.waiting)
      return success();
    // Absorb BFM/internal function failures gracefully — log a warning
    // and return zero results. BFM functions may fail because they
    // access hardware signals that aren't connected in dual-top mode.
    // Without this, a single BFM failure kills the entire process tree.
    if (!isAbortRequested()) {
      static unsigned funcCallWarnCount = 0;
      if (funcCallWarnCount < 5) {
        ++funcCallWarnCount;
        llvm::errs() << "[circt-sim] WARNING: func.call to '"
                     << callOp.getCallee()
                     << "' failed internally (absorbing)\n";
      }
    }
    for (Value result : callOp.getResults()) {
      unsigned width = getTypeWidth(result.getType());
      setValue(procId, result, InterpretedValue(llvm::APInt(width, 0)));
    }
    return success();
  }

  // Check if process suspended during function execution (e.g., due to wait)
  // If so, return early without setting results - the function didn't complete
  auto &postCallState = processStates[procId];
  if (postCallState.waiting) {
    LLVM_DEBUG(llvm::dbgs() << "  func.call: process suspended during call to '"
                            << callOp.getCallee() << "'\n");
    return success();
  }

  // Map return values to call results
  for (auto [result, retVal] : llvm::zip(callOp.getResults(), returnValues)) {
    setValue(procId, result, retVal);
  }

  // Store result in function cache for cacheable functions
  if (isCacheableFunc && !returnValues.empty()) {
    auto &cacheStore = processStates[procId];
    cacheStore.funcResultCache[funcOp.getOperation()][cacheArgHash] =
        llvm::SmallVector<InterpretedValue, 2>(returnValues.begin(),
                                                returnValues.end());
    LLVM_DEBUG(llvm::dbgs()
               << "  func.call: cached result for '" << callOp.getCallee()
               << "' (argHash=0x" << llvm::format_hex(cacheArgHash, 16)
               << ")\n");
  }

  return success();
}

LogicalResult LLHDProcessInterpreter::interpretFuncBody(
    ProcessId procId, mlir::func::FuncOp funcOp,
    llvm::ArrayRef<InterpretedValue> args,
    llvm::SmallVectorImpl<InterpretedValue> &results,
    mlir::Operation *callOp, mlir::Block *resumeBlock,
    mlir::Block::iterator resumeOp) {
  if (funcOp.getBody().empty())
    return failure();

  // Intercept UVM phase objection functions at the func body level.
  // These are called via call_indirect (vtable dispatch) which bypasses the
  // interceptors in interpretFuncCall. We handle them here to ensure they
  // work regardless of which call_indirect path dispatched the call.
  //
  // We intercept both:
  //   uvm_phase::raise_objection(%arg0=phase, %arg1=obj, %arg2=desc, %arg3=count)
  //   uvm_phase_hopper::raise_objection(%arg0=hopper/phase, %arg1=obj, %arg2=desc, %arg3=count)
  // The hopper IS a phase (uvm_phase_hopper extends uvm_phase), so %arg0 can
  // be used as the phase address in both cases.
  StringRef funcName = funcOp.getSymName();

  // Handle dispatch-agnostic UVM fast-paths at function entry. This catches
  // fallback call_indirect dispatch paths that bypass call-site interceptors.
  if (handleUvmFuncBodyFastPath(procId, funcOp, args, results, callOp))
    return success();

  if ((funcName.contains("raise_objection") ||
       funcName.contains("drop_objection")) &&
      (funcName.contains("uvm_phase::") || funcName.contains("uvm_phase_hopper::")) &&
      !funcName.contains("uvm_objection::") &&
      !args.empty() && !args[0].isX()) {
    // For uvm_phase::raise_objection, args[0] is the phase node.
    // For uvm_phase_hopper::raise_objection, args[0] is the hopper (NOT the phase).
    // Use currentExecutingPhaseAddr[procId] if it's a hopper call; otherwise use args[0].
    uint64_t phaseAddr;
    if (funcName.contains("phase_hopper") && currentExecutingPhaseAddr[procId] != 0) {
      phaseAddr = currentExecutingPhaseAddr[procId];
    } else {
      phaseAddr = args[0].getUInt64();
    }
    InterpretedValue countVal =
        args.size() > 3 ? args[3] : InterpretedValue(llvm::APInt(32, 1));
    int64_t count = countVal.isX() ? 1 : static_cast<int64_t>(countVal.getUInt64());
    auto objIt = phaseObjectionHandles.find(phaseAddr);
    MooreObjectionHandle handle;
    if (objIt != phaseObjectionHandles.end()) {
      handle = objIt->second;
    } else {
      std::string phaseName = "phase_" + std::to_string(phaseAddr);
      handle = __moore_objection_create(
          phaseName.c_str(), static_cast<int64_t>(phaseName.size()));
      phaseObjectionHandles[phaseAddr] = handle;
    }
    if (funcName.contains("raise_objection")) {
      raisePhaseObjection(handle, count);
    } else {
      dropPhaseObjection(handle, count);
    }
    return success();
  }


  // Record function AND task phase IMP addresses from their ::new calls.
  // These are the singleton IMP objects for each phase.
  // Function phases: build=0, connect=1, EOE=2, SOS=3.
  // Task phases: run=4, extract=5, check=6, report=7, final=8.
  if (funcName.find("::new") != std::string::npos &&
      !args.empty() && !args[0].isX()) {
    uint64_t impAddr = args[0].getUInt64();
    int order = -1;
    if (funcName.find("uvm_build_phase::new") != std::string::npos)
      order = 0;
    else if (funcName.find("uvm_connect_phase::new") != std::string::npos)
      order = 1;
    else if (funcName.find("uvm_end_of_elaboration_phase::new") != std::string::npos)
      order = 2;
    else if (funcName.find("uvm_start_of_simulation_phase::new") != std::string::npos)
      order = 3;
    else if (funcName.find("uvm_run_phase::new") != std::string::npos)
      order = 4;
    else if (funcName.find("uvm_extract_phase::new") != std::string::npos)
      order = 5;
    else if (funcName.find("uvm_check_phase::new") != std::string::npos)
      order = 6;
    else if (funcName.find("uvm_report_phase::new") != std::string::npos)
      order = 7;
    else if (funcName.find("uvm_final_phase::new") != std::string::npos)
      order = 8;
    if (order >= 0) {
      functionPhaseImpOrder[impAddr] = order;
      functionPhaseImpCompleted[impAddr] = false;
      if (functionPhaseImpSequence.size() <= static_cast<size_t>(order))
        functionPhaseImpSequence.resize(order + 1, 0);
      functionPhaseImpSequence[order] = impAddr;
    }
  }

  // Intercept process_phase to enforce function phase IMP ordering.
  // The UVM phase hopper schedules all function phase IMP nodes
  // simultaneously (they have predecessors=0 in the phase graph).
  // Without intervention, they execute in arbitrary fork order.
  // We enforce the correct IEEE 1800.2 order:
  //   build → connect → end_of_elaboration → start_of_simulation
  // by blocking process_phase until the predecessor IMP has completed.
  //
  // process_phase is called from a sim.fork join_none child in run_phases,
  // so callOp is at the process (fork region) level. We can use the
  // currentOp-reset pattern to re-execute the call_indirect on wake-up.
  if (funcName == "uvm_pkg::uvm_phase_hopper::process_phase") {
    if (args.size() >= 2 && !args[1].isX() && callOp) {
      uint64_t phaseAddr = args[1].getUInt64();
      // Read the IMP pointer from phase field [3] (m_imp) at offset 44
      // Layout: uvm_object=32 + i32 m_phase_type=4 + ptr m_parent=8 = 44
      uint64_t impAddr = 0;
      {
        uint64_t impOff = 0;
        MemoryBlock *impBlk = findBlockByAddress(phaseAddr + 44, impOff);
        if (impBlk && impOff + 8 <= impBlk->data.size()) {
          for (int i = 0; i < 8; ++i)
            impAddr |= static_cast<uint64_t>(impBlk->data[impOff + i])
                       << (i * 8);
        }
      }
      auto impOrderIt = functionPhaseImpOrder.find(impAddr);
      if (impOrderIt != functionPhaseImpOrder.end()) {
        int myOrder = impOrderIt->second;
        if (myOrder > 0) {
          uint64_t predImpAddr =
              (static_cast<size_t>(myOrder - 1) < functionPhaseImpSequence.size())
                  ? functionPhaseImpSequence[myOrder - 1]
                  : 0;
          if (predImpAddr != 0 && !functionPhaseImpCompleted[predImpAddr]) {
            // Predecessor hasn't completed. Add to wait list (notification-
            // based, no polling). finish_phase will wake us up.
            auto &state = processStates[procId];
            state.waiting = true;
            auto callOpIt = mlir::Block::iterator(callOp);
            impWaitingProcesses[predImpAddr].push_back({procId, callOpIt});
            return success();
          }
        }
      } else if (impAddr != 0) {
        // Unknown IMP — not a recognized function or task phase.
        // Block until all registered phases have completed.
        bool allComplete = true;
        for (auto &[addr, done] : functionPhaseImpCompleted) {
          if (!done) { allComplete = false; break; }
        }
        if (!allComplete && !functionPhaseImpCompleted.empty()) {
          auto &state = processStates[procId];
          state.waiting = true;
          auto callOpIt = mlir::Block::iterator(callOp);
          impWaitingProcesses[0].push_back({procId, callOpIt});
          return success();
        }
      }
    }
  }

  // Intercept finish_phase to mark function phase IMPs as completed.
  // This allows the next function phase IMP (blocked in process_phase
  // above) to proceed.
  if (funcName == "uvm_pkg::uvm_phase_hopper::finish_phase") {
    if (args.size() >= 2 && !args[1].isX()) {
      uint64_t phaseAddr = args[1].getUInt64();
      // Read the IMP pointer from phase field [3] (m_imp) at offset 44
      uint64_t impAddr = 0;
      {
        uint64_t impOff = 0;
        MemoryBlock *impBlk = findBlockByAddress(phaseAddr + 44, impOff);
        if (impBlk && impOff + 8 <= impBlk->data.size()) {
          for (int i = 0; i < 8; ++i)
            impAddr |= static_cast<uint64_t>(impBlk->data[impOff + i])
                       << (i * 8);
        }
      }
      auto impOrderIt = functionPhaseImpOrder.find(impAddr);
      if (impOrderIt != functionPhaseImpOrder.end()) {
        functionPhaseImpCompleted[impAddr] = true;
        // [IMP-DIAG] diagnostic removed
        // Wake up processes waiting for this IMP to complete.
        auto waitIt = impWaitingProcesses.find(impAddr);
        if (waitIt != impWaitingProcesses.end()) {
          for (auto &waiter : waitIt->second) {
            auto &st = processStates[waiter.procId];
            st.waiting = false;
            st.currentOp = waiter.resumeOp;
            scheduler.scheduleProcess(waiter.procId,
                                      SchedulingRegion::Active);
          }
          impWaitingProcesses.erase(waitIt);
        }

        // If all phases are now complete, wake unknown IMP waiters
        // (stored under sentinel key 0).
        bool allComplete = true;
        for (auto &[addr, done] : functionPhaseImpCompleted) {
          if (!done) { allComplete = false; break; }
        }
        if (allComplete) {
          auto taskWaitIt = impWaitingProcesses.find(0);
          if (taskWaitIt != impWaitingProcesses.end()) {
            for (auto &waiter : taskWaitIt->second) {
              auto &st = processStates[waiter.procId];
              st.waiting = false;
              st.currentOp = waiter.resumeOp;
              scheduler.scheduleProcess(waiter.procId,
                                        SchedulingRegion::Active);
            }
            impWaitingProcesses.erase(taskWaitIt);
          }
        }
      }
    }
    // Don't return success() - let finish_phase execute normally
    // (it sets state=DONE and schedules successors)
  }

  // Intercept uvm_phase_hopper::execute_phase for task phases.
  // The original MLIR uses a complex sim.fork join_any structure with 3
  // branches (phase_done monitor, objection poller, timeout). Due to
  // timing issues in the interpreter, one branch completes immediately,
  // causing the join_any to return → execute_phase returns → subsequent
  // phases (extract, check, report) run before run_phase finishes.
  //
  // Fix: For task phases, we bypass the complex fork structure entirely.
  // Instead, we call traverse_on (which dispatches exec_task → component
  // run_phase via fork), then poll the objection count natively until it
  // drops to 0 (meaning run_phase completed and objections were dropped).
  if (funcName == "uvm_pkg::uvm_phase_hopper::execute_phase") {
    if (args.size() >= 2 && !args[1].isX()) {
      uint64_t phaseAddr = args[1].getUInt64();
      // Read the phase name from memory to identify the phase
      // uvm_phase extends uvm_object. uvm_object layout:
      //   [0] = uvm_void (i32 class_id, ptr vtable) = 12 bytes
      //   [1] = struct<(ptr, i64)> = name string (ptr + len) at offset 12
      // So name ptr at offset 12, name len at offset 20
      std::string phaseName = "<unknown>";
      uint64_t nameOff = 0;
      MemoryBlock *nameBlk =
          findBlockByAddress(phaseAddr + 12, nameOff);
      if (nameBlk && nameOff + 16 <= nameBlk->data.size()) {
        uint64_t namePtr = 0;
        for (int i = 0; i < 8; ++i)
          namePtr |= static_cast<uint64_t>(nameBlk->data[nameOff + i])
                     << (i * 8);
        uint64_t nameLen = 0;
        for (int i = 0; i < 8; ++i)
          nameLen |= static_cast<uint64_t>(nameBlk->data[nameOff + 8 + i])
                     << (i * 8);
        if (namePtr != 0 && nameLen > 0 && nameLen < 200) {
          uint64_t strOff = 0;
          MemoryBlock *strBlk = findBlockByAddress(namePtr, strOff);
          if (strBlk && strOff + nameLen <= strBlk->data.size()) {
            phaseName.assign(
                reinterpret_cast<const char *>(strBlk->data.data() + strOff),
                nameLen);
          }
        }
      }
      // Track which phase is currently being executed
      currentExecutingPhaseAddr[procId] = phaseAddr;

      // Ensure we have an objection handle for this phase
      auto objIt = phaseObjectionHandles.find(phaseAddr);
      if (objIt == phaseObjectionHandles.end()) {
        std::string pn = "phase_" + std::to_string(phaseAddr);
        MooreObjectionHandle handle = __moore_objection_create(
            pn.c_str(), static_cast<int64_t>(pn.size()));
        phaseObjectionHandles[phaseAddr] = handle;
      }

      // We let the function run naturally. The function will:
      // 1. Set phase state to EXECUTING (already done before calling us)
      // 2. Check get_phase_type: if non-IMP → ^bb1 (simple path, ok)
      // 3. If IMP: check dyn_cast for task_phase → ^bb4 (fork path)
      //
      // For ^bb4, the MLIR creates master_phase_process fork (join_none)
      // which calls traverse_on, then creates the problematic join_any.
      //
      // Set a flag so that when the sim.fork join_any is created,
      // we convert it to block on objections instead.
      // Don't set executePhaseBlockingPhaseMap here — we don't yet know
      // if this is a task phase. The map entry is set when the
      // "master_phase_process" join_none fork is detected in interpretSimFork.
    }
  }

  // Redirect base-class stubs to derived-class overrides when the runtime
  // vtable points to the correct derived class but static vtable resolution
  // picks the base-class stub (because the GEP uses the compile-time struct
  // type). This fixes exec_task/traverse for task phases like run_phase.
  if (funcName == "uvm_pkg::uvm_phase::exec_task" ||
      funcName == "uvm_pkg::uvm_phase::traverse" ||
      funcName == "uvm_pkg::uvm_phase::execute") {
    // The function body is empty (just "return"). Try to find the correct
    // derived-class override by reading the runtime vtable from the object.
    if (!args.empty() && !args[0].isX()) {
      uint64_t objAddr = args[0].getUInt64();
      // The vtable pointer is at offset [0,0,0,1] in the object struct —
      // but the object layout varies. Read the vtable address from memory:
      // For UVM objects, vtable ptr is at byte offset 4 (after the 4-byte
      // class ID at offset 0).
      uint64_t vtableOff = 0;
      MemoryBlock *objBlock = findBlockByAddress(objAddr, vtableOff);
      if (objBlock && objBlock->initialized &&
          objBlock->data.size() >= vtableOff + 12) {
        // Read vtable pointer from byte offset 4 (ptr is 8 bytes)
        uint64_t vtableAddr = 0;
        for (unsigned i = 0; i < 8; ++i)
          vtableAddr |= static_cast<uint64_t>(
                            objBlock->data[vtableOff + 4 + i])
                        << (i * 8);
        // Look up which vtable global this address belongs to
        auto vtableIt = addressToGlobal.find(vtableAddr);
        if (vtableIt != addressToGlobal.end()) {
          std::string vtableName = vtableIt->second;
          // Derive the class name from "__vtable__"
          auto pos = vtableName.find("::__vtable__");
          if (pos != std::string::npos) {
            std::string className = vtableName.substr(0, pos);
            // Determine which method slot we need
            int64_t methodSlot = -1;
            if (funcName.contains("exec_task"))
              methodSlot = 26;
            else if (funcName.contains("traverse"))
              methodSlot = 31;
            else if (funcName.contains("execute"))
              methodSlot = 32;

            // Read the function address from the vtable at the slot
            auto globalIt = globalMemoryBlocks.find(vtableName);
            if (globalIt != globalMemoryBlocks.end() && methodSlot >= 0) {
              auto &vtableBlock = globalIt->second;
              unsigned slotOffset = methodSlot * 8;
              if (slotOffset + 8 <= vtableBlock.size) {
                uint64_t funcAddr2 = 0;
                for (unsigned i = 0; i < 8; ++i)
                  funcAddr2 |=
                      static_cast<uint64_t>(vtableBlock.data[slotOffset + i])
                      << (i * 8);
                if (funcAddr2 != 0) {
                  auto funcIt = addressToFunction.find(funcAddr2);
                  if (funcIt != addressToFunction.end()) {
                    StringRef derivedName = funcIt->second;
                    if (derivedName != funcName) {
                      // Found a derived override — call it instead
                      auto &state = processStates[procId];
                      Operation *parent = state.processOrInitialOp;
                      while (parent && !isa<ModuleOp>(parent))
                        parent = parent->getParentOp();
                      ModuleOp moduleOp =
                          parent ? cast<ModuleOp>(parent) : rootModule;
                      auto derivedFuncOp =
                          moduleOp.lookupSymbol<func::FuncOp>(derivedName);
                      if (derivedFuncOp) {
                        return interpretFuncBody(procId, derivedFuncOp, args,
                                                 results, callOp, resumeBlock,
                                                 resumeOp);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Fix uvm_sequence_base::start initialization: ensure the semaphore mutex
  // (field [0, 1]) and m_sequence_state (field [0, 2]) are properly initialized
  // even if the constructor chain didn't complete. Without this fix, start()
  // fails with SEQ_NOT_DONE because semaphore_try_get on a null handle returns
  // 0 (failure). After fixing, fall through to execute the normal start() body
  // which uses fork/join for proper blocking behavior.
  if (funcName.contains("uvm_sequence_base") &&
      funcName.contains("::start") && args.size() >= 3) {
    uint64_t selfAddr = args[0].isX() ? 0 : args[0].getUInt64();
    if (selfAddr != 0) {
      // uvm_sequence_base struct layout (UNALIGNED):
      //   [0] = uvm_sequence_item (134 bytes)
      //   [1] = ptr (m_sequence_state_mutex semaphore) @ offset 134
      //   [2] = i32 (m_sequence_state) @ offset 142
      constexpr size_t kSemOffset = 134;
      constexpr size_t kStateOffset = 142;

      // Fix semaphore: if null, create a new one with initial count 1
      uint64_t semOff = 0;
      MemoryBlock *blk = findBlockByAddress(selfAddr + kSemOffset, semOff);
      if (!blk)
        blk = findMemoryBlockByAddress(selfAddr + kSemOffset, procId, &semOff);
      if (blk && semOff + 8 <= blk->data.size()) {
        uint64_t semHandle = 0;
        for (int i = 0; i < 8; ++i)
          semHandle |= static_cast<uint64_t>(blk->data[semOff + i]) << (i * 8);
        if (semHandle == 0) {
          int64_t newSem = __moore_semaphore_create(1);
          for (int i = 0; i < 8; ++i)
            blk->data[semOff + i] =
                static_cast<uint8_t>((newSem >> (i * 8)) & 0xFF);
        }
      }

      // Fix state: if 0 (uninitialized), set to UVM_CREATED (1)
      uint64_t stateOff = 0;
      blk = findBlockByAddress(selfAddr + kStateOffset, stateOff);
      if (!blk)
        blk = findMemoryBlockByAddress(selfAddr + kStateOffset, procId,
                                       &stateOff);
      if (blk && stateOff + 4 <= blk->data.size()) {
        uint32_t state = 0;
        for (int i = 0; i < 4; ++i)
          state |= static_cast<uint32_t>(blk->data[stateOff + i]) << (i * 8);
        if (state == 0) {
          uint32_t created = 1; // UVM_CREATED
          for (int i = 0; i < 4; ++i)
            blk->data[stateOff + i] =
                static_cast<uint8_t>((created >> (i * 8)) & 0xFF);
          LLVM_DEBUG(llvm::dbgs()
                     << "  start() init fix: set m_sequence_state to CREATED"
                     << " for seq 0x" << llvm::format_hex(selfAddr, 16)
                     << "\n");
        }
      }
    }
    // Fall through to execute normal start() body (with fork/join blocking)
  }

  Block &entryBlock = funcOp.getBody().front();

  // Track temporary signal mappings created for !llhd.ref function arguments.
  // When a function receives an !llhd.ref argument (e.g., from uvm_config_db),
  // we need to propagate the signal mapping from the caller so that llhd.drv
  // and llhd.prb inside the function can resolve the signal ID.
  llvm::SmallVector<Value, 4> tempSignalMappings;

  // Track recursion depth. When a function calls itself (directly or
  // indirectly), the inner call's SSA values overwrite the outer call's in the
  // shared valueMap/memoryBlocks (since same mlir::Value objects are reused).
  // We only need to save/restore when depth > 1 (i.e., this is a recursive call).
  // Use a local key to avoid dangling reference - DenseMap may rehash when
  // a different function inserts into funcCallDepth during recursive calls.
  Operation *funcKey = funcOp.getOperation();
  unsigned currentDepth = ++funcCallDepth[funcKey];
  bool isRecursive = (currentDepth > 1);

  llvm::DenseMap<Value, InterpretedValue> savedFuncValues;
  llvm::DenseMap<Value, MemoryBlock> savedFuncMemBlocks;
  if (isRecursive) {
    auto &state = processStates[procId];
    for (Block &block : funcOp.getBody()) {
      for (auto arg : block.getArguments()) {
        auto it = state.valueMap.find(arg);
        if (it != state.valueMap.end())
          savedFuncValues[arg] = it->second;
        auto mIt = state.memoryBlocks.find(arg);
        if (mIt != state.memoryBlocks.end())
          savedFuncMemBlocks[arg] = mIt->second;
      }
      for (Operation &op : block) {
        for (auto result : op.getResults()) {
          auto it = state.valueMap.find(result);
          if (it != state.valueMap.end())
            savedFuncValues[result] = it->second;
          auto mIt = state.memoryBlocks.find(result);
          if (mIt != state.memoryBlocks.end())
            savedFuncMemBlocks[result] = mIt->second;
        }
      }
    }
  }

  // Set function arguments (only if not resuming from a saved position)
  if (!resumeBlock) {
    // Get the call operands so we can trace signal refs through function args.
    // For func.call, getOperands() returns just the arguments.
    // For func.call_indirect, the first operand is the callee; use
    // getArgOperands() to skip it and get only the function arguments.
    llvm::SmallVector<Value, 8> callOperands;
    if (callOp) {
      if (auto callIndirectOp = dyn_cast<mlir::func::CallIndirectOp>(callOp)) {
        for (Value operand : callIndirectOp.getArgOperands())
          callOperands.push_back(operand);
      } else {
        for (Value operand : callOp->getOperands())
          callOperands.push_back(operand);
      }
    }

    unsigned idx = 0;
    for (auto [arg, val] : llvm::zip(entryBlock.getArguments(), args)) {
      setValue(procId, arg, val);

      // If the argument type is !llhd.ref<...>, try to propagate signal mapping
      // from the caller. This enables llhd.drv/llhd.prb on ref arguments
      // passed through function calls (e.g., uvm_config_db::set stores values
      // into associative arrays via ref arguments).
      if (isa<llhd::RefType>(arg.getType()) && idx < callOperands.size()) {
        // Record the caller's operand so remapRefBlockArgSource can trace
        // function entry block arguments back to the caller's Value.
        // This is essential for memory-backed ref drives inside functions
        // (e.g., from_class struct field writes via sig.struct_extract).
        auto &state = processStates[procId];
        state.refBlockArgSources[arg] = callOperands[idx];

        if (SignalId sigId = resolveSignalId(callOperands[idx])) {
          valueToSignal[arg] = sigId;
          tempSignalMappings.push_back(arg);
          LLVM_DEBUG(llvm::dbgs()
                     << "  Created temp signal mapping for func arg " << idx
                     << " -> signal " << sigId << "\n");
        }
      }
      ++idx;
    }
  }

  // Helper to restore saved function values and decrement recursion depth.
  auto restoreSavedFuncValues = [&]() {
    --funcCallDepth[funcKey];
    if (isRecursive) {
      auto &state = processStates[procId];
      for (const auto &[val, saved] : savedFuncValues)
        state.valueMap[val] = saved;
      for (auto &[val, saved] : savedFuncMemBlocks)
        state.memoryBlocks[val] = saved;
    }
  };

  // Set the current function name for progress reporting
  auto &funcState = processStates[procId];
  std::string prevFuncName = funcState.currentFuncName;
  funcState.currentFuncName = funcOp.getName().str();

  // Track last function for crash diagnostics (static buffer, survives crash)
  {
    StringRef fn = funcOp.getName();
    size_t len = std::min(fn.size(), (size_t)255);
    std::memcpy(g_lastFuncName, fn.data(), len);
    g_lastFuncName[len] = '\0';
    g_lastFuncProcId = procId;
  }

  // Helper to clean up temporary signal mappings and restore values before
  // returning. Restoring values is critical for recursive calls to the same
  // function - without it, the inner call's values corrupt the outer call's.
  auto cleanupTempMappings = [&]() {
    for (Value v : tempSignalMappings)
      valueToSignal.erase(v);
    restoreSavedFuncValues();
    // Restore previous function name for progress reporting
    auto it = processStates.find(procId);
    if (it != processStates.end())
      it->second.currentFuncName = prevFuncName;
  };

  // Execute operations until we hit a return
  Block *currentBlock = resumeBlock ? resumeBlock : &entryBlock;
  size_t maxOps = 1000000; // Prevent infinite loops (totalSteps is the real limit)
  size_t opCount = 0;

  // Track if we're starting from a resume point
  bool skipToResumeOp = (resumeBlock != nullptr);

  while (currentBlock && opCount < maxOps) {
    // Check if termination was requested (e.g., UVM die() -> sim.terminate).
    // This prevents spending time executing function bodies in processes that
    // are still running after the simulation has been told to stop.
    // Skip during global init as sim.terminate can be triggered re-entrantly.
    if (terminationRequested && !inGlobalInit) {
      LLVM_DEBUG(llvm::dbgs()
                 << "  terminationRequested: aborting function '"
                 << funcOp.getName() << "' for process " << procId << "\n");
      cleanupTempMappings();
      return failure();
    }
    bool tookBranch = false;  // Track if we branched to another block
    for (auto opIt = currentBlock->begin(); opIt != currentBlock->end();
         ++opIt) {
      Operation &op = *opIt;

      // If resuming, skip operations until we reach the resume point
      if (skipToResumeOp) {
        if (&op == &*resumeOp) {
          skipToResumeOp = false;
          LLVM_DEBUG(llvm::dbgs()
                     << "  Resuming function " << funcOp.getName()
                     << " from saved position\n");
        } else {
          continue;
        }
      }

      ++opCount;
      // Track func body steps in process state for global step limiting
      // Use cached active process state to avoid std::map lookup per op.
      {
        ProcessExecutionState *statePtr =
            (procId == activeProcessId && activeProcessState)
                ? activeProcessState
                : &processStates[procId];
        ++statePtr->totalSteps;
        ++statePtr->funcBodySteps;
        maybeSampleMemoryState(statePtr->totalSteps);
        if (collectOpStats)
          ++opStats[op.getName().getStringRef()];
        // Progress report every ~16M func body steps (power-of-2 for cheap
        // bitwise check instead of expensive integer division)
        if ((statePtr->funcBodySteps & 0xFFFFFF) == 0) {
          llvm::errs() << "[circt-sim] func progress: process " << procId
                       << " funcBodySteps=" << statePtr->funcBodySteps
                       << " totalSteps=" << statePtr->totalSteps
                       << " in '" << funcOp.getName() << "'"
                       << " (callDepth=" << statePtr->callDepth << ")"
                       << " op=" << op.getName().getStringRef()
                       << "\n";
        }
        // Enforce global process step limit inside function bodies
        if (maxProcessSteps > 0 &&
            statePtr->totalSteps > (size_t)maxProcessSteps) {
          llvm::errs()
              << "[circt-sim] ERROR(PROCESS_STEP_OVERFLOW in func): process "
              << procId << " exceeded " << maxProcessSteps
              << " total steps in function '" << funcOp.getName() << "'"
              << " (totalSteps=" << statePtr->totalSteps << ")\n";
          statePtr->halted = true;
          cleanupTempMappings();
          return failure();
        }
        // Periodically check for abort (timeout watchdog, every ~16K ops)
        if ((statePtr->funcBodySteps & 0x3FFF) == 0 && isAbortRequested()) {
          statePtr->halted = true;
          cleanupTempMappings();
          if (abortCallback)
            abortCallback();
          return failure();
        }
      }
      if (opCount >= maxOps) {
        llvm::errs() << "circt-sim: Function '" << funcOp.getName()
                     << "' exceeded " << maxOps << " operations for process "
                     << procId << "\n";
        llvm::errs() << "  Last op: ";
        op.print(llvm::errs(), OpPrintingFlags().printGenericOpForm());
        llvm::errs() << "\n";
        cleanupTempMappings();
        return failure();
      }
      // Check if the process was suspended (e.g., by process::suspend() on self)
      // Use cached active process state to avoid repeated std::map lookups.
      {
        ProcessExecutionState *suspCheckState =
            (procId == activeProcessId && activeProcessState)
                ? activeProcessState
                : &processStates[procId];
        if (suspCheckState->waiting) {
          // Save the current position for resumption
          suspCheckState->currentOp = std::next(opIt);
          suspCheckState->currentBlock = currentBlock;
          suspCheckState->resumeAtCurrentOp = true;
          cleanupTempMappings();
          return success();
        }
      }

      if (auto returnOp = dyn_cast<mlir::func::ReturnOp>(&op)) {
        // Gather return values
        for (Value operand : returnOp.getOperands()) {
          results.push_back(getValue(procId, operand));
        }
        cleanupTempMappings();
        return success();
      }

      // Handle branch operations
      if (auto branchOp = dyn_cast<mlir::cf::BranchOp>(&op)) {
        // Transfer operands to block arguments
        Block *dest = branchOp.getDest();
        for (auto [arg, operand] :
             llvm::zip(dest->getArguments(), branchOp.getDestOperands())) {
          setValue(procId, arg, getValue(procId, operand));
        }
        currentBlock = dest;
        tookBranch = true;
        break;
      }

      if (auto condBranchOp = dyn_cast<mlir::cf::CondBranchOp>(&op)) {
        InterpretedValue cond = getValue(procId, condBranchOp.getCondition());

        Block *dest;
        if (!cond.isX() && cond.getUInt64() != 0) {
          dest = condBranchOp.getTrueDest();
          for (auto [arg, operand] :
               llvm::zip(dest->getArguments(),
                         condBranchOp.getTrueDestOperands())) {
            setValue(procId, arg, getValue(procId, operand));
          }
        } else {
          dest = condBranchOp.getFalseDest();
          for (auto [arg, operand] :
               llvm::zip(dest->getArguments(),
                         condBranchOp.getFalseDestOperands())) {
            setValue(procId, arg, getValue(procId, operand));
          }
        }
        currentBlock = dest;
        tookBranch = true;
        break;
      }
      if (failed(interpretOperation(procId, &op))) {
        llvm::errs() << "circt-sim: Failed in func body for process " << procId
                     << "\n";
        llvm::errs() << "  Function: " << funcOp.getName() << "\n";
        llvm::errs() << "  Operation: ";
        op.print(llvm::errs(), OpPrintingFlags().printGenericOpForm());
        llvm::errs() << "\n";
        llvm::errs() << "  Location: " << op.getLoc() << "\n";
        cleanupTempMappings();
        return failure();
      }

      // Check if process was halted or is waiting (e.g., by sim.terminate,
      // llvm.unreachable, moore.wait_event, or sim.fork with blocking join).
      // This is critical for UVM where wait_for_objection() contains event
      // waits that must suspend execution, and run_test() forks phase
      // execution.
      // Use cached active process state to avoid repeated std::map lookups.
      {
      ProcessExecutionState *haltCheckState =
          (procId == activeProcessId && activeProcessState)
              ? activeProcessState
              : &processStates[procId];
      if (haltCheckState->halted || haltCheckState->waiting) {
        LLVM_DEBUG(llvm::dbgs() << "  Process halted/waiting during function body '"
                                << funcOp.getName() << "' - saving call stack frame\n");

        // If waiting (not halted), save the call stack frame so we can resume
        // from the NEXT operation after the one that caused the wait.
        if (haltCheckState->waiting && callOp) {
          // Compute the next operation iterator
          auto nextOpIt = opIt;
          ++nextOpIt;

          // Only save if there are more operations to execute in this function
          if (nextOpIt != currentBlock->end() ||
              currentBlock != &entryBlock) {
            CallStackFrame frame(funcOp, currentBlock, nextOpIt, callOp);
            frame.args.assign(args.begin(), args.end());
            haltCheckState->callStack.push_back(std::move(frame));
            LLVM_DEBUG(llvm::dbgs()
                       << "    Saved call frame for function '"
                       << funcOp.getName() << "' with " << args.size()
                       << " args, will resume after current op\n");
          }
        }

        cleanupTempMappings();
        return success();
      }
      }
    }
    // If we finished the block without a branch, we're done with this block
    // Move to the next block or exit
    if (!tookBranch)
      currentBlock = nullptr;
  }

  cleanupTempMappings();
  return failure();
}

//===----------------------------------------------------------------------===//
// Value Management
//===----------------------------------------------------------------------===//

InterpretedValue LLHDProcessInterpreter::getValue(ProcessId procId,
                                                   Value value) {
  // Use the cached active process state when available to avoid
  // an O(log n) std::map lookup on every getValue call.
  ProcessExecutionState *statePtr;
  if (procId == activeProcessId && activeProcessState) {
    statePtr = activeProcessState;
  } else {
    auto it = processStates.find(procId);
    if (it == processStates.end())
      return InterpretedValue::makeX(getTypeWidth(value.getType()));
    statePtr = &it->second;
  }

  // Check the cache FIRST. If a value has been explicitly set (e.g., by
  // interpretProbe when the probe operation was executed), use that cached
  // value. This is critical for patterns like posedge detection where we
  // need to compare old vs new signal values:
  //   %old = llhd.prb %sig   // executed before wait, cached
  //   llhd.wait ...
  //   %new = llhd.prb %sig   // executed after wait, gets fresh value
  //   %edge = comb.and %new, (not %old)  // needs OLD cached value for %old
  // Without this check, signal values would be re-read every time, causing
  // %old to return the current (new) value instead of the cached old value.
  auto &valueMap = statePtr->valueMap;
  auto valIt = valueMap.find(value);
  if (valIt != valueMap.end())
    return valIt->second;

  // Check module-level init values (for values computed during module init)
  auto moduleIt = moduleInitValueMap.find(value);
  if (moduleIt != moduleInitValueMap.end())
    return moduleIt->second;

  // For direct signal references not in cache, read the current value.
  if (SignalId sigId = getSignalId(value)) {
    const SignalValue &sv = scheduler.getSignalValue(sigId);
    InterpretedValue iv;
    if (sv.isUnknown()) {
      if (auto encoded = getEncodedUnknownForType(value.getType()))
        iv = InterpretedValue(*encoded);
      else
        iv = InterpretedValue::makeX(getTypeWidth(value.getType()));
    } else {
      iv = InterpretedValue::fromSignalValue(sv);
    }
    valueMap[value] = iv;
    return iv;
  }

  auto instMapIt = instanceOutputMap.find(activeInstanceId);
  if (instMapIt != instanceOutputMap.end()) {
    auto instIt = instMapIt->second.find(value);
    if (instIt != instMapIt->second.end()) {
      const auto &info = instIt->second;
      ScopedInstanceContext instScope(*this, info.instanceId);
      if (info.inputMap.empty())
        return getValue(procId, info.outputValue);
      ScopedInputValueMap scope(*this, info.inputMap);
      return getValue(procId, info.outputValue);
    }
  }

  // Handle block arguments that are mapped via inputValueMap (child module
  // inputs mapped to parent values). This is needed when a child module's input
  // is used in a drive and the parent passes a process result as the input.
  if (auto arg = dyn_cast<mlir::BlockArgument>(value)) {
    Value mappedValue;
    InstanceId mappedInstance = activeInstanceId;
    if (lookupInputMapping(arg, mappedValue, mappedInstance) &&
        mappedValue != value) {
      ScopedInstanceContext scope(*this, mappedInstance);
      return getValue(procId, mappedValue);
    }
  }

  // Handle process results. When a value is the result of an llhd::ProcessOp,
  // look up the yielded value from that process's valueMap.
  if (auto result = dyn_cast<OpResult>(value)) {
    if (auto processOp = dyn_cast<llhd::ProcessOp>(result.getOwner())) {
      ProcessId procId = InvalidProcessId;
      if (activeInstanceId != 0) {
        auto ctxIt = instanceOpToProcessId.find(activeInstanceId);
        if (ctxIt != instanceOpToProcessId.end()) {
          auto procIt = ctxIt->second.find(processOp.getOperation());
          if (procIt != ctxIt->second.end())
            procId = procIt->second;
        }
      }
      if (procId == InvalidProcessId) {
        auto procIt = opToProcessId.find(processOp.getOperation());
        if (procIt != opToProcessId.end())
          procId = procIt->second;
      }
      if (procId != InvalidProcessId) {
        auto stateIt = processStates.find(procId);
        if (stateIt != processStates.end()) {
          auto valIt = stateIt->second.valueMap.find(value);
          if (valIt != stateIt->second.valueMap.end())
            return valIt->second;
        }
      }
      // Process result not yet computed - return X
      return InterpretedValue::makeX(getTypeWidth(value.getType()));
    }
  }

  if (auto combOp = value.getDefiningOp<llhd::CombinationalOp>()) {
    llvm::SmallVector<InterpretedValue, 4> results;
    (void)evaluateCombinationalOp(combOp, results);
    auto result = dyn_cast<OpResult>(value);
    if (result && result.getResultNumber() < results.size())
      return results[result.getResultNumber()];
    return InterpretedValue::makeX(getTypeWidth(value.getType()));
  }

  // For probe operations that are NOT in the cache, do a live re-read.
  // This handles the case where a probe result is used but the probe
  // operation itself was defined outside the process (e.g., at module level).
  if (auto probeOp = value.getDefiningOp<llhd::ProbeOp>()) {
    SignalId sigId = resolveSignalId(probeOp.getSignal());
    if (sigId != 0) {
      const SignalValue &sv = scheduler.getSignalValue(sigId);
      InterpretedValue iv = InterpretedValue::fromSignalValue(sv);
      LLVM_DEBUG(llvm::dbgs() << "  Live probe of signal " << sigId << " = "
                              << (sv.isUnknown() ? "X"
                                                  : std::to_string(sv.getValue()))
                              << "\n");
      // Cache the value for consistency within this execution
      valueMap[value] = iv;
      return iv;
    }
  }

  // Check if this is a constant defined outside the process
  if (auto constOp = value.getDefiningOp<hw::ConstantOp>()) {
    APInt constVal = constOp.getValue();
    InterpretedValue iv(constVal);
    valueMap[value] = iv;
    return iv;
  }

  // Check if this is an arith.constant defined outside the process
  if (auto arithConstOp = value.getDefiningOp<arith::ConstantOp>()) {
    if (auto intAttr = dyn_cast<IntegerAttr>(arithConstOp.getValue())) {
      InterpretedValue iv(intAttr.getValue());
      valueMap[value] = iv;
      return iv;
    }
  }

  // Check if this is an llvm.mlir.constant defined outside the process
  if (auto llvmConstOp = value.getDefiningOp<LLVM::ConstantOp>()) {
    if (auto intAttr = dyn_cast<IntegerAttr>(llvmConstOp.getValue())) {
      InterpretedValue iv(intAttr.getValue());
      valueMap[value] = iv;
      return iv;
    }
  }

  // Check if this is an aggregate constant (struct/array)
  if (auto aggConstOp = value.getDefiningOp<hw::AggregateConstantOp>()) {
    APInt constVal = flattenAggregateConstant(aggConstOp);
    InterpretedValue iv(constVal);
    valueMap[value] = iv;
    return iv;
  }

  // Check if this is a bitcast operation
  if (auto bitcastOp = value.getDefiningOp<hw::BitcastOp>()) {
    InterpretedValue inputVal = getValue(procId, bitcastOp.getInput());
    unsigned outputWidth = getTypeWidth(bitcastOp.getType());
    InterpretedValue iv;
    if (inputVal.isX()) {
      iv = InterpretedValue::makeX(outputWidth);
    } else {
      APInt result = inputVal.getAPInt();
      if (result.getBitWidth() < outputWidth)
        result = result.zext(outputWidth);
      else if (result.getBitWidth() > outputWidth)
        result = result.trunc(outputWidth);
      iv = InterpretedValue(result);
    }
    valueMap[value] = iv;
    return iv;
  }

  if (auto *defOp = value.getDefiningOp()) {
    if (isa<hw::StructExtractOp, hw::StructCreateOp, hw::StructInjectOp,
            comb::XorOp, comb::AndOp, comb::OrOp, comb::ICmpOp, comb::MuxOp,
            comb::ConcatOp, comb::ExtractOp, comb::AddOp, comb::SubOp>(defOp)) {
      InterpretedValue iv = evaluateContinuousValue(value);
      valueMap[value] = iv;
      return iv;
    }
    if (defOp->getName().getStringRef() == "hw.struct_inject") {
      InterpretedValue iv = evaluateContinuousValue(value);
      valueMap[value] = iv;
      return iv;
    }
  }

  // NOTE: Probe operations are handled at the top of this function
  // to ensure they always re-read the current signal value.

  // Check if this is a constant_time operation
  if (auto constTimeOp = value.getDefiningOp<llhd::ConstantTimeOp>()) {
    // Return a placeholder - actual time conversion happens in convertTimeValue
    InterpretedValue iv(0, 64);
    valueMap[value] = iv;
    return iv;
  }

  // Check if this is an llvm.mlir.addressof operation (for vtable support)
  if (auto addrOfOp = value.getDefiningOp<LLVM::AddressOfOp>()) {
    StringRef globalName = addrOfOp.getGlobalName();
    auto addrIt = globalAddresses.find(globalName);
    if (addrIt != globalAddresses.end()) {
      uint64_t addr = addrIt->second;
      InterpretedValue iv(addr, 64);
      valueMap[value] = iv;
      return iv;
    }
    // Global not found - return X
    return InterpretedValue::makeX(64);
  }

  // Check if this is an llvm.mlir.zero (null pointer constant)
  if (auto zeroOp = value.getDefiningOp<LLVM::ZeroOp>()) {
    InterpretedValue iv(0, 64);
    valueMap[value] = iv;
    return iv;
  }

  // Check if this is an llvm.mlir.undef (undefined value)
  if (auto undefOp = value.getDefiningOp<LLVM::UndefOp>()) {
    unsigned width = getTypeWidth(undefOp.getType());
    // Initialize undef to zero (safe default for building structs)
    InterpretedValue iv(APInt::getZero(width));
    valueMap[value] = iv;
    return iv;
  }

  // Check if this is an UnrealizedConversionCastOp - propagate value through
  if (auto castOp = value.getDefiningOp<UnrealizedConversionCastOp>()) {
    if (!castOp.getInputs().empty()) {
      InterpretedValue inputVal = getValue(procId, castOp.getInputs()[0]);
      // Adjust width if needed
      unsigned outputWidth = getTypeWidth(value.getType());
      InterpretedValue result;
      if (inputVal.isX()) {
        result = InterpretedValue::makeX(outputWidth);
      } else if (inputVal.getWidth() == outputWidth) {
        result = inputVal;
      } else {
        APInt apVal = inputVal.getAPInt();
        if (outputWidth < apVal.getBitWidth()) {
          result = InterpretedValue(apVal.trunc(outputWidth));
        } else {
          result = InterpretedValue(apVal.zext(outputWidth));
        }
      }
      valueMap[value] = result;
      return result;
    }
  }

  // Check if this is a signal reference
  auto sigIt = valueToSignal.find(value);
  if (sigIt != valueToSignal.end()) {
    // This is a signal reference, return the signal value
    const SignalValue &sv = scheduler.getSignalValue(sigIt->second);
    return InterpretedValue::fromSignalValue(sv);
  }

  // Check if this is an llvm.getelementptr operation that needs on-demand
  // evaluation. This is needed for memory event tracing in moore.wait_event
  // where GEP operations in the wait body haven't been executed yet.
  if (auto gepOp = value.getDefiningOp<LLVM::GEPOp>()) {
    // Get the base pointer value (may recursively evaluate)
    InterpretedValue baseVal = getValue(procId, gepOp.getBase());
    if (baseVal.isX()) {
      InterpretedValue result = InterpretedValue::makeX(64);
      valueMap[value] = result;
      return result;
    }

    uint64_t baseAddr = baseVal.getUInt64();
    uint64_t offset = 0;

    // Get the element type
    Type elemType = gepOp.getElemType();

    // Process indices using the GEPIndicesAdaptor
    auto indices = gepOp.getIndices();
    Type currentType = elemType;

    size_t idx = 0;
    bool hasUnknownIndex = false;
    for (auto indexValue : indices) {
      int64_t indexVal = 0;

      // Check if this is a constant index (IntegerAttr) or dynamic (Value)
      if (auto intAttr = llvm::dyn_cast_if_present<IntegerAttr>(indexValue)) {
        indexVal = intAttr.getInt();
      } else if (auto dynamicIdx = llvm::dyn_cast_if_present<Value>(indexValue)) {
        InterpretedValue dynVal = getValue(procId, dynamicIdx);
        if (dynVal.isX()) {
          hasUnknownIndex = true;
          break;
        }
        indexVal = static_cast<int64_t>(dynVal.getUInt64());
      }

      if (idx == 0) {
        offset += indexVal * getLLVMTypeSizeForGEP(elemType);
      } else if (auto structType = dyn_cast<LLVM::LLVMStructType>(currentType)) {
        auto body = structType.getBody();
        for (int64_t i = 0; i < indexVal && static_cast<size_t>(i) < body.size(); ++i) {
          offset += getLLVMTypeSizeForGEP(body[i]);
        }
        if (static_cast<size_t>(indexVal) < body.size()) {
          currentType = body[indexVal];
        }
      } else if (auto arrayType = dyn_cast<LLVM::LLVMArrayType>(currentType)) {
        offset += indexVal * getLLVMTypeSizeForGEP(arrayType.getElementType());
        currentType = arrayType.getElementType();
      } else {
        offset += indexVal * getLLVMTypeSizeForGEP(currentType);
      }
      ++idx;
    }

    if (hasUnknownIndex) {
      InterpretedValue result = InterpretedValue::makeX(64);
      valueMap[value] = result;
      return result;
    }

    uint64_t resultAddr = baseAddr + offset;
    InterpretedValue result(resultAddr, 64);
    valueMap[value] = result;

    LLVM_DEBUG(llvm::dbgs() << "  getValue GEP on-demand: base=0x"
                            << llvm::format_hex(baseAddr, 16) << " offset="
                            << offset << " result=0x"
                            << llvm::format_hex(resultAddr, 16) << "\n");

    return result;
  }

  // Check if this is an llvm.load operation that needs on-demand evaluation.
  // This is needed for memory event tracing in moore.wait_event where the
  // base pointer might come from a class instance loaded from memory.
  if (auto loadOp = value.getDefiningOp<LLVM::LoadOp>()) {
    // Get the pointer value (may recursively evaluate GEPs)
    InterpretedValue ptrVal = getValue(procId, loadOp.getAddr());
    if (ptrVal.isX()) {
      unsigned bitWidth = getTypeWidth(loadOp.getType());
      InterpretedValue result = InterpretedValue::makeX(bitWidth);
      valueMap[value] = result;
      return result;
    }

    uint64_t addr = ptrVal.getUInt64();
    Type resultType = loadOp.getType();
    unsigned bitWidth = getTypeWidth(resultType);
    unsigned loadSize = getLLVMTypeSize(resultType);

    // Find the memory block containing this address
    MemoryBlock *block = nullptr;
    uint64_t offset = 0;

    // Check global and malloc memory blocks via O(log n) range index
    block = findBlockByAddress(addr, offset);

    // Check module-level allocas
    if (!block) {
      for (auto &[val, memBlock] : moduleLevelAllocas) {
        auto addrIt = moduleInitValueMap.find(val);
        if (addrIt != moduleInitValueMap.end()) {
          uint64_t blockAddr = addrIt->second.getUInt64();
          if (addr >= blockAddr && addr < blockAddr + memBlock.size) {
            block = &memBlock;
            offset = addr - blockAddr;
            break;
          }
        }
      }
    }

    // Check process-local memory blocks
    if (!block) {
      auto &procState = processStates[procId];
      for (auto &[val, memBlock] : procState.memoryBlocks) {
        auto addrIt = procState.valueMap.find(val);
        if (addrIt != procState.valueMap.end()) {
          uint64_t blockAddr = addrIt->second.getUInt64();
          if (addr >= blockAddr && addr < blockAddr + memBlock.size) {
            block = &memBlock;
            offset = addr - blockAddr;
            break;
          }
        }
      }
    }

    if (block && block->initialized && offset + loadSize <= block->size) {
      // Read bytes from memory
      APInt loadedValue(bitWidth, 0);
      for (unsigned i = 0; i < loadSize && i < (bitWidth + 7) / 8; ++i) {
        uint64_t byte = block->data[offset + i];
        loadedValue |= APInt(bitWidth, byte) << (i * 8);
      }
      InterpretedValue result(loadedValue);
      valueMap[value] = result;

      LLVM_DEBUG(llvm::dbgs() << "  getValue load on-demand: addr=0x"
                              << llvm::format_hex(addr, 16) << " value="
                              << loadedValue.getZExtValue() << "\n");

      return result;
    }

    // Memory not found or not initialized - return X
    InterpretedValue result = InterpretedValue::makeX(bitWidth);
    valueMap[value] = result;
    return result;
  }

  // Check if this is an LLVM call at module level (e.g., string conversion)
  // Execute the call on demand when its result is needed.
  if (auto callOp = value.getDefiningOp<LLVM::CallOp>()) {
    // Check call depth to prevent stack overflow from deep recursion (UVM patterns)
    // This path can recurse: getValue -> interpretLLVMCall -> interpretLLVMFuncBody
    // -> interpretOperation -> getValue
    auto &state = processStates[procId];
    constexpr size_t maxCallDepth = 200;
    if (state.callDepth >= maxCallDepth) {
      LLVM_DEBUG(llvm::dbgs() << "  getValue: max call depth (" << maxCallDepth
                              << ") exceeded for LLVM call, returning zero\n");
      return InterpretedValue(
          llvm::APInt(getTypeWidth(value.getType()), 0));
    }

    // Interpret the call to compute and cache its result with depth tracking
    ++state.callDepth;
    LogicalResult callResult = interpretLLVMCall(procId, callOp);
    --state.callDepth;

    if (succeeded(callResult)) {
      // Now try to get the cached result
      auto it = valueMap.find(value);
      if (it != valueMap.end())
        return it->second;
    }
  }

  // Unknown value - return X
  LLVM_DEBUG(llvm::dbgs() << "  Warning: Unknown value, returning X\n");
  return InterpretedValue::makeX(getTypeWidth(value.getType()));
}

void LLHDProcessInterpreter::setValue(ProcessId procId, Value value,
                                       InterpretedValue val) {
  // Use the cached active process state when available.
  if (procId == activeProcessId && activeProcessState) {
    activeProcessState->valueMap[value] = val;
    return;
  }
  auto it = processStates.find(procId);
  if (it == processStates.end())
    return;

  it->second.valueMap[value] = val;
}

unsigned LLHDProcessInterpreter::getTypeWidth(Type type) {
  // Fast path for integer types (most common case) - no cache needed.
  if (auto intType = dyn_cast<IntegerType>(type))
    return intType.getWidth();

  // Check the cache for composite/complex types to avoid repeated recursive
  // computation (struct/array types recurse through all elements).
  static llvm::DenseMap<Type, unsigned> typeWidthCache;
  auto cacheIt = typeWidthCache.find(type);
  if (cacheIt != typeWidthCache.end())
    return cacheIt->second;

  unsigned result = getTypeWidthUncached(type);
  typeWidthCache[type] = result;
  return result;
}

unsigned LLHDProcessInterpreter::getTypeWidthUncached(Type type) {

  // Handle LLHD ref types
  if (auto refType = dyn_cast<llhd::RefType>(type))
    return getTypeWidth(refType.getNestedType());

  // Handle LLHD time type (arbitrary width for now)
  if (isa<llhd::TimeType>(type))
    return 64;

  // Handle index type (use 64-bit for indices)
  if (isa<IndexType>(type))
    return 64;

  // Handle hw.array types
  if (auto arrayType = dyn_cast<hw::ArrayType>(type))
    return getTypeWidth(arrayType.getElementType()) * arrayType.getNumElements();

  // Handle hw.struct types
  if (auto structType = dyn_cast<hw::StructType>(type)) {
    unsigned totalWidth = 0;
    for (auto field : structType.getElements())
      totalWidth += getTypeWidth(field.type);
    return totalWidth;
  }

  // Handle LLVM pointer types (64 bits)
  if (isa<LLVM::LLVMPointerType>(type))
    return 64;

  // Handle LLVM struct types
  if (auto llvmStructType = dyn_cast<LLVM::LLVMStructType>(type)) {
    unsigned totalWidth = 0;
    for (Type elemType : llvmStructType.getBody())
      totalWidth += getTypeWidth(elemType);
    return totalWidth;
  }

  // Handle LLVM array types
  if (auto llvmArrayType = dyn_cast<LLVM::LLVMArrayType>(type))
    return getTypeWidth(llvmArrayType.getElementType()) *
           llvmArrayType.getNumElements();

  // Handle function types (for function pointers/indirect calls)
  if (isa<FunctionType>(type))
    return 64;

  // Default to 1 bit for unknown types
  return 1;
}

SignalEncoding LLHDProcessInterpreter::getSignalEncoding(Type type) {
  if (auto refType = dyn_cast<llhd::RefType>(type))
    return getSignalEncoding(refType.getNestedType());
  if (isa<seq::ClockType>(type))
    return SignalEncoding::TwoState;
  if (auto structType = dyn_cast<hw::StructType>(type)) {
    auto elements = structType.getElements();
    if (elements.size() == 2 &&
        elements[0].name.getValue() == "value" &&
        elements[1].name.getValue() == "unknown") {
      unsigned valueWidth = getTypeWidth(elements[0].type);
      unsigned unknownWidth = getTypeWidth(elements[1].type);
      if (valueWidth == unknownWidth)
        return SignalEncoding::FourStateStruct;
    }
  }
  return SignalEncoding::TwoState;
}

//===----------------------------------------------------------------------===//
// Sim Dialect Operation Handlers
//===----------------------------------------------------------------------===//

LogicalResult
LLHDProcessInterpreter::interpretProcPrint(ProcessId procId,
                                            sim::PrintFormattedProcOp printOp) {
  LLVM_DEBUG(llvm::dbgs() << "  Interpreting sim.proc.print\n");

  // Evaluate the format string and print it
  std::string output = evaluateFormatString(procId, printOp.getInput());

  // Print to stdout
  llvm::outs() << output;
  llvm::outs().flush();

  return success();
}

// Helper: given a block argument, find the corresponding operand from a
// predecessor's terminator.  Returns nullptr on failure.
static Value traceBlockArgThroughPred(Block *pred, Block *block,
                                      unsigned argIdx) {
  auto *terminator = pred->getTerminator();
  if (auto brOp = dyn_cast<mlir::cf::BranchOp>(terminator)) {
    if (argIdx < brOp.getDestOperands().size())
      return brOp.getDestOperands()[argIdx];
  } else if (auto condBrOp = dyn_cast<mlir::cf::CondBranchOp>(terminator)) {
    if (condBrOp.getTrueDest() == block &&
        argIdx < condBrOp.getTrueDestOperands().size())
      return condBrOp.getTrueDestOperands()[argIdx];
    if (condBrOp.getFalseDest() == block &&
        argIdx < condBrOp.getFalseDestOperands().size())
      return condBrOp.getFalseDestOperands()[argIdx];
  } else if (auto waitOp = dyn_cast<llhd::WaitOp>(terminator)) {
    if (argIdx < waitOp.getDestOperands().size())
      return waitOp.getDestOperands()[argIdx];
  }
  return nullptr;
}

// Recursively trace a block argument back to the original defining op,
// using DFS with a visited set to handle cycles in the CFG.
static Value traceFStringBlockArg(Value fmtValue,
                                  SmallPtrSetImpl<Value> &visited) {
  while (!fmtValue.getDefiningOp()) {
    if (!visited.insert(fmtValue).second)
      return nullptr; // cycle
    auto arg = dyn_cast<BlockArgument>(fmtValue);
    if (!arg)
      return nullptr;
    Block *block = arg.getOwner();
    unsigned argIdx = arg.getArgNumber();
    Value best;
    for (auto *pred : block->getPredecessors()) {
      Value candidate = traceBlockArgThroughPred(pred, block, argIdx);
      if (!candidate)
        continue;
      if (candidate.getDefiningOp())
        return candidate; // found a defining op directly
      // candidate is another block arg - try recursing if not visited
      if (!visited.count(candidate)) {
        Value resolved = traceFStringBlockArg(candidate, visited);
        if (resolved && resolved.getDefiningOp())
          return resolved;
      }
      if (!best)
        best = candidate;
    }
    if (!best)
      return nullptr;
    fmtValue = best;
  }
  return fmtValue;
}

std::string LLHDProcessInterpreter::evaluateFormatString(ProcessId procId,
                                                          Value fmtValue) {
  // Trace through block arguments to find the original defining op.
  if (!fmtValue.getDefiningOp()) {
    SmallPtrSet<Value, 8> visited;
    Value resolved = traceFStringBlockArg(fmtValue, visited);
    if (resolved)
      fmtValue = resolved;
  }
  Operation *defOp = fmtValue.getDefiningOp();
  if (!defOp)
    return "<unknown>";

  // Handle sim.fmt.literal - literal string
  if (auto litOp = dyn_cast<sim::FormatLiteralOp>(defOp)) {
    return litOp.getLiteral().str();
  }

  // Handle sim.fmt.concat - concatenation of format strings
  if (auto concatOp = dyn_cast<sim::FormatStringConcatOp>(defOp)) {
    std::string result;
    for (Value input : concatOp.getInputs()) {
      result += evaluateFormatString(procId, input);
    }
    return result;
  }

  // Handle sim.fmt.hex - hexadecimal integer format
  if (auto hexOp = dyn_cast<sim::FormatHexOp>(defOp)) {
    InterpretedValue val = getValue(procId, hexOp.getValue());
    if (val.isX())
      return "x";
    llvm::SmallString<32> hexStr;
    bool isUpper = hexOp.getIsHexUppercase();
    // Use toString() directly to control case: toStringUnsigned() calls
    // toString with UpperCase defaulting to true, which always produces A-F.
    // IEEE 1800-2017 %h requires lowercase a-f.
    val.getAPInt().toString(hexStr, /*Radix=*/16, /*Signed=*/false,
                            /*formatAsCLiteral=*/false, /*UpperCase=*/isUpper);
    std::string result(hexStr.str());
    // Apply zero-padding for specifierWidth (e.g., %08x).
    if (auto widthAttr = hexOp.getSpecifierWidth()) {
      unsigned width = widthAttr.value();
      if (result.size() < width)
        result.insert(0, width - result.size(), '0');
    }
    return result;
  }

  // Handle sim.fmt.dec - decimal integer format
  if (auto decOp = dyn_cast<sim::FormatDecOp>(defOp)) {
    InterpretedValue val = getValue(procId, decOp.getValue());
    if (val.isX())
      return "x";
    if (decOp.getIsSigned()) {
      return std::to_string(val.getAPInt().getSExtValue());
    }
    return std::to_string(val.getUInt64());
  }

  // Handle sim.fmt.bin - binary integer format
  if (auto binOp = dyn_cast<sim::FormatBinOp>(defOp)) {
    InterpretedValue val = getValue(procId, binOp.getValue());
    if (val.isX())
      return "x";
    llvm::SmallString<64> binStr;
    val.getAPInt().toStringUnsigned(binStr, 2);
    return std::string(binStr.str());
  }

  // Handle sim.fmt.oct - octal integer format
  if (auto octOp = dyn_cast<sim::FormatOctOp>(defOp)) {
    InterpretedValue val = getValue(procId, octOp.getValue());
    if (val.isX())
      return "x";
    llvm::SmallString<32> octStr;
    val.getAPInt().toStringUnsigned(octStr, 8);
    return std::string(octStr.str());
  }

  auto formatReal = [&](Value typedValue, InterpretedValue rawValue,
                        bool isLeftAligned,
                        std::optional<unsigned> fieldWidth,
                        std::optional<unsigned> fracDigits,
                        char specifier) -> std::string {
    if (rawValue.isX())
      return "x";

    double value = 0.0;
    if (isa<Float32Type>(typedValue.getType())) {
      uint32_t bits = static_cast<uint32_t>(rawValue.getUInt64() & 0xFFFFFFFFu);
      float f = 0.0f;
      std::memcpy(&f, &bits, sizeof(f));
      value = static_cast<double>(f);
    } else {
      uint64_t bits = rawValue.getUInt64();
      std::memcpy(&value, &bits, sizeof(value));
    }

    unsigned digits = fracDigits.value_or(6);
    std::string fmt = "%";
    if (isLeftAligned)
      fmt += "-";
    if (fieldWidth.has_value())
      fmt += std::to_string(*fieldWidth);
    fmt += ".";
    fmt += std::to_string(digits);
    fmt.push_back(specifier);

    int len = std::snprintf(nullptr, 0, fmt.c_str(), value);
    if (len <= 0)
      return "";
    std::string out(static_cast<size_t>(len), '\0');
    std::snprintf(out.data(), out.size() + 1, fmt.c_str(), value);
    return out;
  };

  // Handle sim.fmt.exp - scientific real format
  if (auto expOp = dyn_cast<sim::FormatScientificOp>(defOp)) {
    InterpretedValue val = getValue(procId, expOp.getValue());
    return formatReal(expOp.getValue(), val, expOp.getIsLeftAligned(),
                      expOp.getFieldWidth(), expOp.getFracDigits(), 'e');
  }

  // Handle sim.fmt.flt - fixed-point real format
  if (auto fltOp = dyn_cast<sim::FormatFloatOp>(defOp)) {
    InterpretedValue val = getValue(procId, fltOp.getValue());
    return formatReal(fltOp.getValue(), val, fltOp.getIsLeftAligned(),
                      fltOp.getFieldWidth(), fltOp.getFracDigits(), 'f');
  }

  // Handle sim.fmt.gen - general real format
  if (auto genOp = dyn_cast<sim::FormatGeneralOp>(defOp)) {
    InterpretedValue val = getValue(procId, genOp.getValue());
    return formatReal(genOp.getValue(), val, genOp.getIsLeftAligned(),
                      genOp.getFieldWidth(), genOp.getFracDigits(), 'g');
  }

  // Handle sim.fmt.char - character format
  if (auto charOp = dyn_cast<sim::FormatCharOp>(defOp)) {
    InterpretedValue val = getValue(procId, charOp.getValue());
    if (val.isX())
      return "?";
    char c = static_cast<char>(val.getUInt64() & 0xFF);
    return std::string(1, c);
  }

  // Handle sim.fmt.dyn_string - dynamic string
  if (auto dynStrOp = dyn_cast<sim::FormatDynStringOp>(defOp)) {
    // The dynamic string value is a struct {ptr, len}
    // Get the packed value (128-bit: ptr in lower 64, len in upper 64)
    InterpretedValue structVal = getValue(procId, dynStrOp.getValue());

    // Extract pointer and length from the packed 128-bit value
    APInt packedVal = structVal.getAPInt();
    int64_t ptrVal = 0;
    int64_t lenVal = 0;

    if (packedVal.getBitWidth() >= 128) {
      ptrVal = packedVal.extractBits(64, 0).getSExtValue();
      lenVal = packedVal.extractBits(64, 64).getSExtValue();
    } else if (packedVal.getBitWidth() >= 64) {
      // Might be a simpler representation
      ptrVal = packedVal.getSExtValue();
    }

    // Look up in our dynamic strings registry
    auto it = dynamicStrings.find(ptrVal);
    if (it != dynamicStrings.end()) {
      // Found in registry - return the string (may be empty)
      if (it->second.first && it->second.second > 0)
        return std::string(it->second.first, it->second.second);
      // Empty string
      return "";
    }

    // Try reverse address-to-global lookup for string globals
    auto globalIt = addressToGlobal.find(static_cast<uint64_t>(ptrVal));
    if (globalIt != addressToGlobal.end()) {
      std::string globalName = globalIt->second;
      auto blockIt = globalMemoryBlocks.find(globalName);
      if (blockIt != globalMemoryBlocks.end()) {
        const MemoryBlock &block = blockIt->second;
        // Use the length from the struct, or the block size if length is invalid
        size_t effectiveLen = (lenVal > 0 && static_cast<size_t>(lenVal) <= block.data.size())
                                  ? static_cast<size_t>(lenVal)
                                  : block.data.size();
        // Find null terminator if present
        size_t actualLen = 0;
        for (size_t i = 0; i < effectiveLen; ++i) {
          if (block.data[i] == 0)
            break;
          actualLen++;
        }
        if (actualLen > 0) {
          return std::string(reinterpret_cast<const char *>(block.data.data()),
                             actualLen);
        }
      }
    }

    // Fallback: try to interpret as direct pointer (unsafe, for debugging)
    if (ptrVal != 0 && lenVal > 0 && lenVal < 1024) {
      const char *ptr = reinterpret_cast<const char *>(ptrVal);
      // Safety check - only dereference if it looks valid
      if (ptr) {
        return std::string(ptr, lenVal);
      }
    }

    return "<dynamic string>";
  }

  // Handle arith.select - conditional selection of format strings
  if (auto selectOp = dyn_cast<arith::SelectOp>(defOp)) {
    InterpretedValue condVal = getValue(procId, selectOp.getCondition());
    if (condVal.isX()) {
      // Return some indication for X condition
      return "<X>";
    }
    bool condition = condVal.getAPInt().getBoolValue();
    Value selectedValue =
        condition ? selectOp.getTrueValue() : selectOp.getFalseValue();
    return evaluateFormatString(procId, selectedValue);
  }

  // Unknown format operation
  return "<unsupported format>";
}

LogicalResult LLHDProcessInterpreter::interpretTerminate(
    ProcessId procId, sim::TerminateOp terminateOp) {
  bool success = terminateOp.getSuccess();
  bool verbose = terminateOp.getVerbose();
  auto &state = processStates[procId];

  LLVM_DEBUG(llvm::dbgs() << "  Interpreting sim.terminate ("
                          << (success ? "success" : "failure") << ", "
                          << (verbose ? "verbose" : "quiet") << ")\n");

  // When sim.terminate is triggered from within a phase function's execution
  // (e.g., die() called from check_phase → uvm_report_error), absorb it
  // so the phase can complete and remaining phases (report, final) can run.
  // This happens when the scoreboard's check_phase reports errors for zero
  // transactions — die() calls $finish which triggers sim.terminate, but
  // the UVM phase machinery needs to run through to completion.
  {
    auto phaseIt = currentExecutingPhaseAddr.find(procId);
    if (phaseIt != currentExecutingPhaseAddr.end() && state.callDepth > 0) {
      LLVM_DEBUG(llvm::dbgs()
                 << "  sim.terminate absorbed during phase execution"
                 << " (callDepth=" << state.callDepth << ")\n");
      // Don't set terminationRequested or waiting — just return success
      // so the phase function can continue. The terminate will fire again
      // later from the main run_test $finish path.
      return mlir::success();
    }
  }

  // Check if this process has active forked children that haven't completed,
  // OR if any UVM phase IMPs haven't completed yet.
  // This is important for UVM where run_test() forks phase execution and then
  // calls $finish, but the phases should complete first.
  // The direct-children check catches the initial fork, and the IMP check
  // catches the case where the fork child terminates but the phase hopper
  // grandchild is still running through remaining phases.
  bool phasesStillRunning = false;
  if (!functionPhaseImpCompleted.empty()) {
    for (auto &[addr, done] : functionPhaseImpCompleted) {
      if (!done) { phasesStillRunning = true; break; }
    }
  }
  if (forkJoinManager.hasActiveChildren(procId) || phasesStillRunning) {
    LLVM_DEBUG(llvm::dbgs()
               << "  Terminate deferred - process has active forked children\n");

    if (!inGlobalInit && !success) {
      terminationRequested = true;
      if (terminateCallback) {
        terminateCallback(success, verbose);
      }
    } else if (!inGlobalInit && success && !finishGracePeriodActive) {
      // Start a wall-clock grace period for successful $finish with active
      // children. This gives UVM cleanup phases time to run (extract, check,
      // report, final) but prevents infinite hangs from the phase hopper loop.
      // Uses wall-clock time because UVM phase execution happens at sim time 0.
      finishGracePeriodActive = true;
      finishGracePeriodStart = std::chrono::steady_clock::now();
      LLVM_DEBUG(llvm::dbgs()
                 << "  Started $finish grace period ("
                 << kFinishGracePeriodSecs << "s wall-clock)\n");
    }

    // Suspend the process instead of terminating - it will be resumed when
    // all children complete (via the fork/join completion mechanism)
    state.waiting = true;

    // Store the terminate operation so we can re-execute it when children complete
    state.destBlock = terminateOp->getBlock();
    state.currentOp = mlir::Block::iterator(terminateOp);
    state.resumeAtCurrentOp = true; // Resume at terminate op, not block beginning

    Process *proc = scheduler.getProcess(procId);
    if (proc)
      proc->setState(ProcessState::Waiting);

    return mlir::success();
  }

  // Print diagnostic info about the termination source for debugging
  // This helps identify where fatal errors occur (e.g., UVM die() -> $finish)
  if (verbose) {
    llvm::errs() << "[circt-sim] sim.terminate triggered in process ID "
                 << procId << " at ";
    terminateOp.getLoc().print(llvm::errs());
    llvm::errs() << "\n";
  }

  // During global initialization (e.g., UVM global constructors), do not halt
  // the process. UVM's m_uvm_get_root() can be called re-entrantly during
  // uvm_root::new(), which triggers uvm_fatal -> die() -> sim.terminate.
  // If we halt here, the first call to m_uvm_get_root() never stores to
  // uvm_top, causing the m_inst != uvm_top check to fail permanently.
  // Instead, record termination was requested but let the init code finish.
  if (inGlobalInit) {
    terminationRequested = true;
    if (terminateCallback && (!success || topModuleCount <= 1))
      terminateCallback(success, verbose);
    LLVM_DEBUG(llvm::dbgs()
               << "  sim.terminate during global init - not halting process "
               << procId << " (termination deferred to after init)\n");
    return mlir::success();
  }

  if (success && topModuleCount > 1 &&
      !scheduler.getEventScheduler().isComplete()) {
    LLVM_DEBUG(llvm::dbgs()
               << "  sim.terminate(success) - dual-top mode, scheduler has "
               << "pending events, setting terminationRequested but keeping "
               << "sim alive\n");
    terminationRequested = true;
    finalizeProcess(procId, /*killed=*/false);
    return mlir::success();
  }

  // Mark termination requested
  terminationRequested = true;

  // Call the terminate callback if set
  if (terminateCallback) {
    terminateCallback(success, verbose);
  }

  finalizeProcess(procId, /*killed=*/false);

  return mlir::success();
}

//===----------------------------------------------------------------------===//
// Fork/Join Operation Handlers
//===----------------------------------------------------------------------===//

LogicalResult LLHDProcessInterpreter::interpretSimFork(ProcessId procId,
                                                        sim::SimForkOp forkOp) {
  LLVM_DEBUG(llvm::dbgs() << "  Interpreting sim.fork with "
                          << forkOp.getBranches().size() << " branches, join_type="
                          << forkOp.getJoinType() << "\n");

  // Parse the join type
  ForkJoinType joinType = parseForkJoinType(forkOp.getJoinType());

  // When we detect the "master_phase_process" join_none fork, this confirms
  // that execute_phase is running for a TASK phase. Set the blocking phase
  // map so the NEXT join_any on this process (or its child) gets intercepted.
  bool isMasterPhaseProcessFork = false;
  uint64_t masterPhaseAddr = 0;
  if (joinType == ForkJoinType::JoinNone && currentExecutingPhaseAddr[procId] != 0) {
    auto nameAttr = forkOp->getAttrOfType<mlir::StringAttr>("name");
    if (nameAttr && nameAttr.getValue() == "master_phase_process") {
      isMasterPhaseProcessFork = true;
      masterPhaseAddr = currentExecutingPhaseAddr[procId];
      executePhaseBlockingPhaseMap[procId] = currentExecutingPhaseAddr[procId];
    }
  }

  // Intercept join_any inside execute_phase for task phases.
  // The MLIR creates a join_any with 3 branches (phase_done monitor,
  // objection poller, timeout). Due to interpreter timing, one branch
  // completes immediately, causing execute_phase to return prematurely.
  // Instead, we skip the fork entirely and poll the phase's objection
  // count until it drops to 0.
  {
    auto phaseMapIt = executePhaseBlockingPhaseMap.find(procId);
    if (joinType == ForkJoinType::JoinAny &&
        phaseMapIt != executePhaseBlockingPhaseMap.end()) {
      uint64_t phaseAddr = phaseMapIt->second;
      // Clear the mapping so nested forks aren't affected
      executePhaseBlockingPhaseMap.erase(phaseMapIt);

      // Set a dummy handle value so subsequent sim.disable_fork doesn't crash
      setValue(procId, forkOp.getHandle(), InterpretedValue(0ULL, 64));

      // Check objection count for this specific phase.
      auto objIt = phaseObjectionHandles.find(phaseAddr);
      MooreObjectionHandle handle = MOORE_OBJECTION_INVALID_HANDLE;
      if (objIt != phaseObjectionHandles.end())
        handle = objIt->second;

      int64_t count = 0;
      if (handle != MOORE_OBJECTION_INVALID_HANDLE)
        count = __moore_objection_get_count(handle);

      // Check if the master_phase_process child is still alive.
      // If it is, keep polling even if objection count is 0 (the child
      // hasn't had a chance to call raise_objection yet).
      bool masterChildAlive = false;
      auto childIt = masterPhaseProcessChild.find(phaseAddr);
      if (childIt != masterPhaseProcessChild.end()) {
        ProcessId childProcId = childIt->second;
        auto childStateIt = processStates.find(childProcId);
        if (childStateIt != processStates.end()) {
          // Child is alive if it's not halted
          masterChildAlive = !childStateIt->second.halted;
        }
      }

      auto &yieldCount = executePhaseYieldCounts[procId];
      // After objection count drops to 0, give a grace period (100 yields)
      // for any last-moment objections, then consider the phase done even if
      // the master child is still alive (it has forever loops in monitors).
      constexpr int kObjectionDropGrace = 100;
      bool shouldKeepPolling = (count > 0) ||
                               (count <= 0 && masterChildAlive &&
                                yieldCount < kObjectionDropGrace) ||
                               (count <= 0 && yieldCount < 10);
      if (shouldKeepPolling) {
        ++yieldCount;
        if (count > 0)
          yieldCount = 0; // Reset when objections are active
        auto &state = processStates[procId];
        state.waiting = true;

        SimTime currentTime = scheduler.getCurrentTime();
        SimTime targetTime;
        if (currentTime.deltaStep < 2000)
          targetTime = currentTime.nextDelta();
        else
          targetTime = currentTime.advanceTime(10000000); // 10 ns

        // Re-arm the mapping so next iteration detects the join_any again
        executePhaseBlockingPhaseMap[procId] = phaseAddr;

        // Re-execute this same fork op on the next delta
        auto forkIt = mlir::Block::iterator(forkOp.getOperation());
        scheduler.getEventScheduler().schedule(
            targetTime, SchedulingRegion::Active,
            Event([this, procId, forkIt]() {
              auto &st = processStates[procId];
              st.waiting = false;
              st.currentOp = forkIt;
              scheduler.scheduleProcess(procId, SchedulingRegion::Active);
            }));
        return success();
      }

      // Objections are at 0 and master child is done — phase is complete.
      // Kill all processes spawned during this phase (monitors with forever
      // loops, scoreboards waiting on events, etc.). Without this cleanup,
      // these tasks would run indefinitely and block subsequent phases.
      yieldCount = 0;
      auto childIt2 = masterPhaseProcessChild.find(phaseAddr);
      if (childIt2 != masterPhaseProcessChild.end()) {
        ProcessId masterChildId = childIt2->second;
        killProcessTree(masterChildId);
        masterPhaseProcessChild.erase(childIt2);
      }
      // Skip the fork entirely — continue to next op after the fork
      return success();
    }
  }

  // Create a fork group
  ForkId forkId = forkJoinManager.createFork(procId, joinType);

  // Store the fork ID as the handle result (used by join/disable_fork)
  setValue(procId, forkOp.getHandle(), InterpretedValue(forkId, 64));

  // Create a child process for each branch region
  for (auto [idx, branch] : llvm::enumerate(forkOp.getBranches())) {
    if (branch.empty())
      continue;

    // Generate a unique name for the child process
    std::string childName = "fork_" + std::to_string(forkId) + "_branch_" +
                            std::to_string(idx);

    // Register the child process with the scheduler
    ProcessId childId = scheduler.registerProcess(childName, []() {});

    // Create execution state for the child process
    ProcessExecutionState childState;
    childState.currentBlock = &branch.front();
    childState.currentOp = childState.currentBlock->begin();
    childState.isInitialBlock = false; // Fork branches are not initial blocks

    // Copy value mappings from parent to child for values defined outside the fork
    // This allows child processes to access parent's local variables
    auto &parentState = processStates[procId];
    childState.valueMap = parentState.valueMap;

    // Share parent-scope allocas via the parent pointer chain instead of
    // deep-copying.  Only allocas defined WITHIN the fork body region are
    // local to the child (automatic variable capture).  Parent-scope allocas
    // (e.g. loop counters, shared variables) are accessed through the parent
    // chain so that child writes are visible to the parent after join.
    //
    // Collect the set of alloca Values that are defined inside this branch.
    llvm::DenseSet<mlir::Value> forkBodyAllocas;
    branch.walk([&](LLVM::AllocaOp allocaOp) {
      forkBodyAllocas.insert(allocaOp.getResult());
    });

    // Deep-copy only fork-body-local allocas from the parent (they may have
    // been pre-populated during value map copy).  Everything else is shared.
    for (auto &[val, block] : parentState.memoryBlocks) {
      if (forkBodyAllocas.contains(val))
        childState.memoryBlocks[val] = block; // deep copy for fork-local
    }

    // Set parent pointer so that lookups fall through to the parent chain
    // for allocas not found locally.
    childState.parentProcessId = procId;

    // Copy processOrInitialOp from parent so that the child can look up functions
    // in the parent module (needed for virtual method dispatch via call_indirect)
    childState.processOrInitialOp = parentState.processOrInitialOp;

    // Derive the child's RNG seed from the parent's RNG (IEEE 1800-2017
    // §18.13-18.14: hierarchical seeding for forked threads).
    uint32_t childSeed =
        static_cast<uint32_t>(parentState.randomGenerator());

    // Store the child state with the derived seed
    registerProcessState(childId, std::move(childState), childSeed);

    // NOTE: We intentionally do NOT propagate executePhaseBlockingPhaseMap
    // from parent to child.  That map is only needed on the *same* process
    // that runs execute_phase — both the master_phase_process fork (join_none)
    // and the monitoring fork (join_any with phase_done/objection/timeout
    // branches) live inside execute_phase on the SAME process.  Propagating
    // the mapping to fork children causes user-code fork/join_any (e.g., the
    // slave driver's BFM channel forks) to be incorrectly intercepted and
    // skipped, which prevents BFM tasks from running and blocks time
    // advancement.

    // Propagate the currently executing phase address from parent to child.
    // Fork children within execute_phase need to know which phase they're
    // operating on behalf of, so raise/drop_objection intercepts use the
    // correct phase address.
    auto curPhaseIt = currentExecutingPhaseAddr.find(procId);
    if (curPhaseIt != currentExecutingPhaseAddr.end() && curPhaseIt->second != 0) {
      currentExecutingPhaseAddr[childId] = curPhaseIt->second;
    }

    // Record the master_phase_process child process ID so the join_any
    // polling can check if the traversal is still running.
    if (isMasterPhaseProcessFork && masterPhaseAddr != 0) {
      masterPhaseProcessChild[masterPhaseAddr] = childId;
    }

    // Set up the callback to execute the child process
    if (auto *proc = scheduler.getProcess(childId))
      proc->setCallback([this, childId]() { executeProcess(childId); });

    // Add the child to the fork group
    forkJoinManager.addChildToFork(forkId, childId);

    // Schedule the child process for execution
    scheduler.scheduleProcess(childId, SchedulingRegion::Active);

    LLVM_DEBUG(llvm::dbgs() << "    Created child process " << childId
                            << " for branch " << idx << "\n");
  }
  // Handle different join types
  switch (joinType) {
  case ForkJoinType::JoinNone:
    // Parent continues immediately - no waiting
    LLVM_DEBUG(llvm::dbgs() << "    join_none: parent continues immediately\n");
    return success();

  case ForkJoinType::Join:
  case ForkJoinType::JoinAny: {
    // Check if fork is already complete (e.g., no branches)
    if (forkJoinManager.join(forkId)) {
      LLVM_DEBUG(llvm::dbgs() << "    Fork already complete, continuing\n");
      return success();
    }

    // Suspend the parent process until fork completes
    auto &state = processStates[procId];
    state.waiting = true;

    // The ForkJoinManager will resume the parent when appropriate
    // (all children for join, any child for join_any)
    Process *parentProc = scheduler.getProcess(procId);
    if (parentProc)
      parentProc->setState(ProcessState::Waiting);

    LLVM_DEBUG(llvm::dbgs() << "    Parent suspended waiting for fork\n");
    return success();
  }
  }

  return success();
}

LogicalResult LLHDProcessInterpreter::interpretSimForkTerminator(
    ProcessId procId, sim::SimForkTerminatorOp termOp) {
  LLVM_DEBUG(llvm::dbgs() << "  Interpreting sim.fork.terminator\n");

  // Diagnostic: log fork child completion with step count
  {
    auto stIt = processStates.find(procId);
    if (stIt != processStates.end()) {
      auto &ps = stIt->second;
      // Only print for fork children spawned by driver proxy processes
      // (those with parentProcessId set)
      if (ps.parentProcessId != InvalidProcessId) {
        auto *proc = scheduler.getProcess(procId);
        std::string procName = proc ? proc->getName() : "??";
        static unsigned forkTermDiagCount = 0;
        // Only log fork children created after initial setup (proc > 100)
        // to focus on driver proxy forks
        if (forkTermDiagCount < 100 && procId > 100) {
          ++forkTermDiagCount;
          // Look up parent's function name for context
          std::string parentFunc;
          auto parentIt = processStates.find(ps.parentProcessId);
          if (parentIt != processStates.end())
            parentFunc = parentIt->second.currentFuncName;
          // Also look up the scheduler process name for the parent
          std::string parentName;
          if (auto *parentProc = scheduler.getProcess(ps.parentProcessId))
            parentName = parentProc->getName();
          llvm::errs() << "[FORK-TERM] proc=" << procId
                       << " name=" << procName
                       << " steps=" << ps.totalSteps
                       << " parent=" << ps.parentProcessId
                       << " parentName=" << parentName
                       << " parentFunc=" << parentFunc
                       << "\n";
        }
      }
    }
  }

  finalizeProcess(procId, /*killed=*/false);

  LLVM_DEBUG(llvm::dbgs() << "    Fork branch " << procId << " completed\n");

  return success();
}

LogicalResult LLHDProcessInterpreter::interpretSimJoin(ProcessId procId,
                                                        sim::SimJoinOp joinOp) {
  // Get the fork handle
  InterpretedValue handleVal = getValue(procId, joinOp.getHandle());
  ForkId forkId = static_cast<ForkId>(handleVal.getUInt64());

  LLVM_DEBUG(llvm::dbgs() << "  Interpreting sim.join for fork " << forkId << "\n");

  // Check if the fork is complete
  if (forkJoinManager.join(forkId)) {
    LLVM_DEBUG(llvm::dbgs() << "    Fork already complete\n");
    return success();
  }

  // Suspend the process until fork completes
  auto &state = processStates[procId];
  state.waiting = true;

  Process *proc = scheduler.getProcess(procId);
  if (proc)
    proc->setState(ProcessState::Waiting);

  LLVM_DEBUG(llvm::dbgs() << "    Process suspended waiting for fork to complete\n");
  return success();
}

LogicalResult LLHDProcessInterpreter::interpretSimJoinAny(
    ProcessId procId, sim::SimJoinAnyOp joinAnyOp) {
  // Get the fork handle
  InterpretedValue handleVal = getValue(procId, joinAnyOp.getHandle());
  ForkId forkId = static_cast<ForkId>(handleVal.getUInt64());

  LLVM_DEBUG(llvm::dbgs() << "  Interpreting sim.join_any for fork " << forkId << "\n");

  // Check if any child has completed
  if (forkJoinManager.joinAny(forkId)) {
    LLVM_DEBUG(llvm::dbgs() << "    At least one child already complete\n");
    // Diagnostic: log when join_any returns immediately for driver procs
    {
      static unsigned joinAnyImmDiagCount = 0;
      if (joinAnyImmDiagCount < 30 && procId > 100) {
        ++joinAnyImmDiagCount;
        auto *group = forkJoinManager.getForkGroup(forkId);
        unsigned childCount = group ? group->childProcesses.size() : 0;
        unsigned completedCount = group ? group->completedCount : 0;
        auto *proc = scheduler.getProcess(procId);
        std::string procName = proc ? proc->getName() : "??";
        llvm::errs() << "[JOIN-ANY-IMM] proc=" << procId
                     << " name=" << procName
                     << " forkId=" << forkId
                     << " children=" << childCount
                     << " completed=" << completedCount
                     << "\n";
        if (group) {
          for (ProcessId childId : group->childProcesses) {
            auto *childProc = scheduler.getProcess(childId);
            bool terminated = childProc &&
                              childProc->getState() == ProcessState::Terminated;
            auto childStateIt = processStates.find(childId);
            size_t childSteps =
                childStateIt != processStates.end()
                    ? childStateIt->second.totalSteps : 0;
            std::string childName = childProc ? childProc->getName() : "??";
            llvm::errs() << "  child=" << childId
                         << " name=" << childName
                         << " terminated=" << terminated
                         << " steps=" << childSteps << "\n";
          }
        }
      }
    }
    return success();
  }

  // Suspend the process until any child completes
  auto &state = processStates[procId];
  state.waiting = true;

  Process *proc = scheduler.getProcess(procId);
  if (proc)
    proc->setState(ProcessState::Waiting);

  LLVM_DEBUG(llvm::dbgs() << "    Process suspended waiting for any child to complete\n");
  return success();
}

LogicalResult LLHDProcessInterpreter::interpretSimWaitFork(
    ProcessId procId, sim::SimWaitForkOp waitForkOp) {
  LLVM_DEBUG(llvm::dbgs() << "  Interpreting sim.wait_fork\n");

  // Check if all child processes of this parent are complete
  if (forkJoinManager.waitFork(procId)) {
    LLVM_DEBUG(llvm::dbgs() << "    All child processes already complete\n");
    return success();
  }

  // Suspend the process until all children complete
  auto &state = processStates[procId];
  state.waiting = true;

  Process *proc = scheduler.getProcess(procId);
  if (proc)
    proc->setState(ProcessState::Waiting);

  LLVM_DEBUG(llvm::dbgs() << "    Process suspended waiting for all children\n");
  return success();
}

LogicalResult LLHDProcessInterpreter::interpretSimDisableFork(
    ProcessId procId, sim::SimDisableForkOp disableForkOp) {
  LLVM_DEBUG(llvm::dbgs() << "  Interpreting sim.disable_fork\n");

  auto forkIds = forkJoinManager.getForksForParent(procId);

  // Disable all fork groups created by this process
  for (ForkId forkId : forkIds) {
    if (auto *group = forkJoinManager.getForkGroup(forkId)) {
      for (ProcessId childId : group->childProcesses)
        finalizeProcess(childId, /*killed=*/true);
    }
  }

  LLVM_DEBUG(llvm::dbgs() << "    All child processes disabled\n");
  return success();
}

//===----------------------------------------------------------------------===//
// Seq Dialect Operation Handlers
//===----------------------------------------------------------------------===//

LogicalResult LLHDProcessInterpreter::interpretSeqYield(ProcessId procId,
                                                         seq::YieldOp yieldOp) {
  LLVM_DEBUG(llvm::dbgs() << "  Interpreting seq.yield - terminating initial block\n");

  // seq.yield terminates the initial block
  finalizeProcess(procId, /*killed=*/false);

  return success();
}

//===----------------------------------------------------------------------===//
// Moore Dialect Operation Handlers
//===----------------------------------------------------------------------===//

LogicalResult LLHDProcessInterpreter::interpretMooreWaitEvent(
    ProcessId procId, moore::WaitEventOp waitEventOp) {
  LLVM_DEBUG(llvm::dbgs() << "  Interpreting moore.wait_event\n");

  auto &state = processStates[procId];

  // Helper: getValue with parent-chain fallback for forked child processes.
  // When a fork child calls a BFM task with @(posedge clk), the VIF pointers
  // and GEP base addresses needed to resolve signals were computed in the
  // parent process's context.  getValue() returns X for these in the child.
  // Walk up the parent chain to find the value.
  auto getValueWithParentFallback = [&](ProcessId pid,
                                        Value value) -> InterpretedValue {
    InterpretedValue v = getValue(pid, value);
    if (!v.isX())
      return v;
    ProcessId cur = pid;
    for (int depth = 0; depth < 10; ++depth) {
      auto stIt = processStates.find(cur);
      if (stIt == processStates.end())
        break;
      ProcessId parentId = stIt->second.parentProcessId;
      if (parentId == InvalidProcessId)
        break;
      InterpretedValue pv = getValue(parentId, value);
      if (!pv.isX())
        return pv;
      cur = parentId;
    }
    return v; // Return original X if no parent had it
  };

  // The moore.wait_event operation contains a body region with moore.detect_event
  // operations that specify which signal edges to detect.
  //
  // To properly implement this, we need to:
  // 1. Extract the signals to observe from detect_event ops in the body
  // 2. Set up edge detection (posedge/negedge/anychange)
  // 3. Suspend the process until one of the events fires
  //
  // For now, we implement a simplified version:
  // - Walk the body to find detect_event ops
  // - Extract the input signals they observe
  // - Wait for any change on those signals

  // Check if the body is empty - if so, just halt (infinite wait)
  if (waitEventOp.getBody().front().empty()) {
    LLVM_DEBUG(llvm::dbgs() << "    Empty wait_event body - halting process\n");
    finalizeProcess(procId, /*killed=*/false);
    return success();
  }

  // Pre-execute the wait_event body operations to populate the value map.
  // This is necessary when the body contains operations like llvm.call
  // (e.g., @__moore_assoc_get_ref for UVM events stored in associative arrays)
  // whose results are needed to resolve memory addresses for event polling.
  // Without this, getValue() returns X for call results, and the memory event
  // watcher is never set up, causing wait_for_objection to return immediately.
  {
    Block &bodyBlock = waitEventOp.getBody().front();
    for (Operation &op : bodyBlock) {
      // Skip detect_event ops - they are handled below by the signal/memory
      // tracing walks and have no handler in interpretOperation.
      if (isa<moore::DetectEventOp>(op))
        continue;

      if (failed(interpretOperation(procId, &op))) {
        LLVM_DEBUG(llvm::dbgs()
                   << "    Warning: Failed to pre-execute wait_event body op: ");
        LLVM_DEBUG(op.print(llvm::dbgs(), OpPrintingFlags().printGenericOpForm()));
        LLVM_DEBUG(llvm::dbgs() << "\n");
        // Continue anyway - the signal/memory walks may still work via SSA tracing
      }
    }
  }

  // Collect signals to observe from detect_event ops
  SensitivityList waitList;

  waitEventOp.getBody().walk([&](moore::DetectEventOp detectOp) {
    Value input = detectOp.getInput();

    // Try to trace the input to a signal
    std::function<SignalId(Value, int)> traceToSignal = [&](Value value,
                                                             int depth) -> SignalId {
      if (depth > 10)
        return 0; // Prevent infinite recursion

      // Check if this value is a signal reference
      SignalId sigId = getSignalId(value);
      if (sigId != 0)
        return sigId;

      // Try to trace through the defining operation
      if (Operation *defOp = value.getDefiningOp()) {
        // For probe operations, get the signal being probed
        if (auto probeOp = dyn_cast<llhd::ProbeOp>(defOp)) {
          return getSignalId(probeOp.getSignal());
        }

        // For struct extract, trace the struct
        if (auto extractOp = dyn_cast<hw::StructExtractOp>(defOp)) {
          return traceToSignal(extractOp.getInput(), depth + 1);
        }

        // For LLVM GEP, trace the base
        if (auto gepOp = dyn_cast<LLVM::GEPOp>(defOp)) {
          return traceToSignal(gepOp.getBase(), depth + 1);
        }

        // For llhd.sig.struct_extract, trace to the signal
        if (auto sigExtractOp = dyn_cast<llhd::SigStructExtractOp>(defOp)) {
          return traceToSignal(sigExtractOp.getInput(), depth + 1);
        }

        // For unrealized_conversion_cast, trace through
        if (auto castOp = dyn_cast<UnrealizedConversionCastOp>(defOp)) {
          if (!castOp.getInputs().empty()) {
            return traceToSignal(castOp.getInputs()[0], depth + 1);
          }
        }

        // For other operations, try to trace their operands
        for (Value operand : defOp->getOperands()) {
          sigId = traceToSignal(operand, depth + 1);
          if (sigId != 0)
            return sigId;
        }
      }

      return 0;
    };

    SignalId sigId = traceToSignal(input, 0);

    LLVM_DEBUG({
      if (sigId == 0) {
        auto &diagState = processStates[procId];
        StringRef funcName = diagState.currentFuncName;
        if (funcName.contains("_bfm::") || funcName.contains("Bfm::")) {
          llvm::dbgs() << "[WAIT-DIAG] BFM proc=" << procId
                       << " func=" << funcName
                       << " traceToSignal=0"
                       << " interfaceFieldSignals.size="
                       << interfaceFieldSignals.size() << "\n";
        }
      }
    });

    // Runtime VIF fallback: when SSA tracing fails (e.g., VIF pointer stored
    // in a class field obtained via resource_db), try to resolve the VIF field
    // address at runtime using pre-executed values and interfaceFieldSignals.
    if (sigId == 0 && !interfaceFieldSignals.empty()) {
      // Walk backwards from detect_event input to find the llvm.load that
      // reads the VIF field value. The address of that load is the VIF field
      // address, which should be in interfaceFieldSignals.
      std::function<SignalId(Value, int)> traceViaRuntime =
          [&](Value value, int depth) -> SignalId {
        if (depth > 16)
          return 0;
        Operation *defOp = value.getDefiningOp();
        if (!defOp)
          return 0;


        // For llvm.load: get the runtime address of what we're loading from
        if (auto loadOp = dyn_cast<LLVM::LoadOp>(defOp)) {
          InterpretedValue addrVal = getValueWithParentFallback(procId, loadOp.getAddr());
          if (!addrVal.isX() && addrVal.getUInt64() != 0) {
            uint64_t addr = addrVal.getUInt64();
            auto fieldIt = interfaceFieldSignals.find(addr);
            LLVM_DEBUG({
              auto &diagState2 = processStates[procId];
              if (diagState2.currentFuncName.find("_bfm::") != std::string::npos ||
                  diagState2.currentFuncName.find("Bfm::") != std::string::npos) {
                llvm::dbgs() << "[WAIT-DIAG] BFM LoadOp addr=0x"
                             << llvm::format_hex(addr, 16)
                             << " found="
                             << (fieldIt != interfaceFieldSignals.end())
                             << " func=" << diagState2.currentFuncName << "\n";
              }
            });
            if (fieldIt != interfaceFieldSignals.end())
              return fieldIt->second;
          } else {
            LLVM_DEBUG(llvm::dbgs() << "[WAIT-DIAG] LoadOp addr isX="
                             << addrVal.isX()
                             << " val=0x" << (addrVal.isX() ? 0 : addrVal.getUInt64())
                             << "\n");
          }
          // Recurse into the address operand (e.g. GEP inside wait_event
          // body where the GEP hasn't been executed yet)
          return traceViaRuntime(loadOp.getAddr(), depth + 1);
        }

        // Trace through casts, struct_create, extractvalue, GEP
        if (auto castOp = dyn_cast<UnrealizedConversionCastOp>(defOp)) {
          if (!castOp.getInputs().empty())
            return traceViaRuntime(castOp.getInputs()[0], depth + 1);
        }
        if (auto structCreate = dyn_cast<hw::StructCreateOp>(defOp)) {
          for (Value operand : structCreate.getOperands()) {
            SignalId s = traceViaRuntime(operand, depth + 1);
            if (s != 0) return s;
          }
        }
        if (auto extractOp = dyn_cast<LLVM::ExtractValueOp>(defOp)) {
          return traceViaRuntime(extractOp.getContainer(), depth + 1);
        }
        if (auto gepOp = dyn_cast<LLVM::GEPOp>(defOp)) {
          // First try the pre-computed result from the valueMap
          InterpretedValue gepVal = getValueWithParentFallback(procId, gepOp.getResult());
          if (!gepVal.isX() && gepVal.getUInt64() != 0) {
            uint64_t addr = gepVal.getUInt64();
            auto fieldIt = interfaceFieldSignals.find(addr);
            if (fieldIt != interfaceFieldSignals.end())
              return fieldIt->second;
          }
          // If the GEP result isn't available (e.g. inside moore.wait_event
          // body where ops aren't executed), compute the address manually
          // from the base pointer + field offsets.
          InterpretedValue baseVal = getValueWithParentFallback(procId, gepOp.getBase());
          if (!baseVal.isX() && baseVal.getUInt64() != 0) {
            uint64_t baseAddr = baseVal.getUInt64();
            Type elemType = gepOp.getElemType();
            uint64_t offset = 0;
            bool ok = true;
            size_t idx = 0;
            Type currentType = elemType;
            for (auto indexValue : gepOp.getIndices()) {
              int64_t indexVal = 0;
              if (auto intAttr =
                      llvm::dyn_cast_if_present<IntegerAttr>(indexValue)) {
                indexVal = intAttr.getInt();
              } else if (auto dynamicIdx =
                             llvm::dyn_cast_if_present<Value>(indexValue)) {
                InterpretedValue dynVal = getValueWithParentFallback(procId, dynamicIdx);
                if (dynVal.isX()) { ok = false; break; }
                indexVal = static_cast<int64_t>(dynVal.getUInt64());
              }
              if (idx == 0) {
                offset += indexVal * getLLVMTypeSizeForGEP(elemType);
              } else if (auto structType =
                             dyn_cast<LLVM::LLVMStructType>(currentType)) {
                auto body = structType.getBody();
                for (int64_t i = 0;
                     i < indexVal && static_cast<size_t>(i) < body.size(); ++i)
                  offset += getLLVMTypeSizeForGEP(body[i]);
                if (static_cast<size_t>(indexVal) < body.size())
                  currentType = body[indexVal];
              } else if (auto arrayType =
                             dyn_cast<LLVM::LLVMArrayType>(currentType)) {
                offset +=
                    indexVal * getLLVMTypeSizeForGEP(arrayType.getElementType());
                currentType = arrayType.getElementType();
              } else {
                offset += indexVal * getLLVMTypeSizeForGEP(currentType);
              }
              ++idx;
            }
            if (ok) {
              uint64_t addr = baseAddr + offset;
              auto fieldIt = interfaceFieldSignals.find(addr);
              if (fieldIt != interfaceFieldSignals.end())
                return fieldIt->second;
            }
          }
          return traceViaRuntime(gepOp.getBase(), depth + 1);
        }
        return 0;
      };

      sigId = traceViaRuntime(input, 0);
      LLVM_DEBUG({
        auto &diagState3 = processStates[procId];
        if (diagState3.currentFuncName.find("_bfm::") != std::string::npos ||
            diagState3.currentFuncName.find("Bfm::") != std::string::npos) {
          llvm::dbgs() << "[WAIT-DIAG] BFM traceViaRuntime=" << sigId
                       << " func=" << diagState3.currentFuncName << "\n";
        }
      });
      LLVM_DEBUG({
        if (sigId != 0)
          llvm::dbgs() << "    Runtime VIF fallback found signal " << sigId
                       << "\n";
        else
          llvm::dbgs() << "    Runtime VIF fallback: no match\n";
      });
    }

    if (sigId != 0) {
      // Respect the edge type from the detect_event op so that
      // @(posedge clk) only wakes on posedges, not any change.
      switch (detectOp.getEdge()) {
      case moore::Edge::PosEdge:
        waitList.addPosedge(sigId);
        break;
      case moore::Edge::NegEdge:
        waitList.addNegedge(sigId);
        break;
      case moore::Edge::BothEdges:
        waitList.addEdge(sigId, EdgeType::AnyEdge);
        break;
      case moore::Edge::AnyChange:
      default:
        waitList.addLevel(sigId);
        break;
      }
    }
  });

  // If we found signals to wait on, suspend the process
  if (!waitList.empty()) {
    state.waiting = true;

    // The continuation point after the wait_event is the next operation
    // in the current block (which was already advanced by the main loop)
    // We don't need to set destBlock since we continue sequentially

    // Register the wait sensitivity with the scheduler
    scheduler.suspendProcessForEvents(procId, waitList);
    // [WAIT-DIAG] diagnostic removed
    LLVM_DEBUG(llvm::dbgs() << "  wait_event: suspended process " << procId
                            << " on " << waitList.size() << " signals\n");
  } else {
    // No signals found - try to set up memory-based event polling.
    // This is needed for UVM events stored as boolean fields in class instances.
    //
    // The pattern we're looking for:
    //   %ptr = llvm.getelementptr %uvm_obj[0, N] : (!llvm.ptr) -> !llvm.ptr
    //   %val = llvm.load %ptr : !llvm.ptr -> i1
    //   %evt = builtin.unrealized_conversion_cast %val : i1 to !moore.event
    //   moore.detect_event any %evt : event
    //
    // We trace backwards from detect_event input to find the memory pointer.
    bool foundMemoryEvent = false;

    // Track the detected input type to determine edge behavior
    bool isEventType = false;
    waitEventOp.getBody().walk([&](moore::DetectEventOp detectOp) {
      if (foundMemoryEvent)
        return; // Already found one

      Value input = detectOp.getInput();

      // Check if the input is an event type (!moore.event).
      // For event types, we need rising edge detection (0→1 trigger).
      Type inputType = input.getType();
      if (isa<moore::EventType>(inputType)) {
        isEventType = true;
      }

      // Trace through value chain to find the llvm.load that reads from
      // memory. This handles patterns like:
      //   %val = llvm.load %ptr             <- target
      //   %field = llvm.extractvalue %val[0]
      //   %struct = hw.struct_create(%field, ...)
      //   %cast = unrealized_conversion_cast %struct
      //   moore.detect_event posedge %cast
      std::function<Value(Value, int)> traceToMemoryPtr =
          [&](Value value, int depth) -> Value {
        if (depth > 16)
          return nullptr;

        if (Operation *defOp = value.getDefiningOp()) {
          // If this is a load, return its address operand
          if (auto loadOp = dyn_cast<LLVM::LoadOp>(defOp)) {
            return loadOp.getAddr();
          }

          // Trace through unrealized_conversion_cast
          if (auto castOp = dyn_cast<UnrealizedConversionCastOp>(defOp)) {
            if (!castOp.getInputs().empty()) {
              return traceToMemoryPtr(castOp.getInputs()[0], depth + 1);
            }
          }

          // Trace through hw.struct_create - check all operands
          if (auto structCreate = dyn_cast<hw::StructCreateOp>(defOp)) {
            for (Value operand : structCreate.getOperands()) {
              Value result = traceToMemoryPtr(operand, depth + 1);
              if (result)
                return result;
            }
          }

          // Trace through hw.struct_extract
          if (auto structExtract = dyn_cast<hw::StructExtractOp>(defOp)) {
            return traceToMemoryPtr(structExtract.getInput(), depth + 1);
          }

          // Trace through llvm.extractvalue
          if (auto extractValue = dyn_cast<LLVM::ExtractValueOp>(defOp)) {
            return traceToMemoryPtr(extractValue.getContainer(), depth + 1);
          }

          // Trace through llvm.insertvalue
          if (auto insertValue = dyn_cast<LLVM::InsertValueOp>(defOp)) {
            // Try the inserted value first, then the container
            Value result = traceToMemoryPtr(insertValue.getValue(), depth + 1);
            if (result)
              return result;
            return traceToMemoryPtr(insertValue.getContainer(), depth + 1);
          }
        }

        return nullptr;
      };

      Value memPtr = traceToMemoryPtr(input, 0);
      if (!memPtr) {
        return;
      }

      // Get the address value for this pointer (with parent fallback for forks)
      InterpretedValue ptrVal = getValueWithParentFallback(procId, memPtr);
      if (ptrVal.isX()) {
        return;
      }

      uint64_t addr = ptrVal.getUInt64();
      if (addr == 0) {
        return;
      }

      // Find the memory block and read current value
      MemoryBlock *block = nullptr;
      uint64_t offset = 0;

      // First try module-level allocas (accessible from all processes)
      // Check by value directly first
      auto moduleLevelIt = moduleLevelAllocas.find(memPtr);
      if (moduleLevelIt != moduleLevelAllocas.end()) {
        block = &moduleLevelIt->second;
        offset = 0;
      }

      // If not found by value, check by address
      if (!block) {
        for (auto &[val, memBlock] : moduleLevelAllocas) {
          auto addrIt = moduleInitValueMap.find(val);
          if (addrIt != moduleInitValueMap.end()) {
            uint64_t blockAddr = addrIt->second.getUInt64();
            if (addr >= blockAddr && addr < blockAddr + memBlock.size) {
              block = &memBlock;
              offset = addr - blockAddr;
              break;
            }
          }
        }
      }

      // Check global and malloc blocks via O(log n) range index
      if (!block) {
        uint64_t rangeOffset = 0;
        block = findBlockByAddress(addr, rangeOffset);
        if (block) offset = rangeOffset;
      }

      // Also check process-local memory blocks
      if (!block) {
        auto &procState = processStates[procId];
        for (auto &[val, memBlock] : procState.memoryBlocks) {
          auto addrIt = procState.valueMap.find(val);
          if (addrIt != procState.valueMap.end()) {
            uint64_t blockAddr = addrIt->second.getUInt64();
            if (addr >= blockAddr && addr < blockAddr + memBlock.size) {
              block = &memBlock;
              offset = addr - blockAddr;
              break;
            }
          }
        }
      }

      if (!block || !block->initialized) {
        return;
      }

      // Read the current value (assume 1 byte for boolean/event)
      unsigned valueSize = 1;
      if (offset + valueSize > block->size)
        return;

      uint64_t currentValue = 0;
      for (unsigned i = 0; i < valueSize; ++i) {
        currentValue |= static_cast<uint64_t>(block->data[offset + i]) << (i * 8);
      }

      // Set up the memory event waiter
      MemoryEventWaiter waiter;
      waiter.address = addr;
      waiter.lastValue = currentValue;
      waiter.valueSize = valueSize;
      // Determine edge detection mode:
      // - For event types (!moore.event), use rising edge (0→1)
      // - For posedge detect_event, use rising edge
      // - For negedge, use falling edge (via rising edge on inverted value)
      // - For any/both edges, use any change
      waiter.waitForRisingEdge = isEventType ||
          detectOp.getEdge() == moore::Edge::PosEdge;
      memoryEventWaiters[procId] = waiter;

      LLVM_DEBUG(llvm::dbgs() << "    Set up memory event waiter for address 0x"
                              << llvm::format_hex(addr, 16)
                              << " with initial value " << currentValue
                              << (isEventType ? " (rising edge mode for event type)" : "") << "\n");

      foundMemoryEvent = true;
    });

    if (foundMemoryEvent) {
      // Suspend the process - it will be woken when memory is written
      state.waiting = true;
      // Don't schedule - checkMemoryEventWaiters() will be called when
      // llvm.store writes to memory, and will wake this process if needed
    } else {
      // No signals and no memory events found - single delta cycle wait
      LLVM_DEBUG({
        StringRef funcName4 = state.currentFuncName;
        if (funcName4.contains("_bfm::") || funcName4.contains("Bfm::")) {
          llvm::dbgs() << "[WAIT-DIAG] BFM NO-OP wait_event! proc=" << procId
                       << " func=" << funcName4
                       << " (no signals, no memory events)\n";
        }
      });
      scheduler.scheduleProcess(procId, SchedulingRegion::Active);
    }
  }

  return success();
}

//===----------------------------------------------------------------------===//
// LLVM Dialect Operation Handlers
//===----------------------------------------------------------------------===//

unsigned LLHDProcessInterpreter::getLLVMTypeAlignment(Type type) {
  // Note: This function exists for future use. Currently the interpreter
  // uses unaligned struct layout to match MooreToCore's sizeof computation
  // (which sums field sizes without alignment padding).
  if (isa<LLVM::LLVMPointerType>(type))
    return 8;
  if (auto intType = dyn_cast<IntegerType>(type)) {
    unsigned bytes = (intType.getWidth() + 7) / 8;
    if (bytes <= 1) return 1;
    if (bytes <= 2) return 2;
    if (bytes <= 4) return 4;
    return 8;
  }
  if (auto structType = dyn_cast<LLVM::LLVMStructType>(type)) {
    unsigned maxAlign = 1;
    for (Type field : structType.getBody())
      maxAlign = std::max(maxAlign, getLLVMTypeAlignment(field));
    return maxAlign;
  }
  if (auto arrayType = dyn_cast<LLVM::LLVMArrayType>(type))
    return getLLVMTypeAlignment(arrayType.getElementType());
  return 1;
}

unsigned LLHDProcessInterpreter::getLLVMStructFieldOffset(
    LLVM::LLVMStructType structType, unsigned fieldIndex) {
  // Use GEP-aligned sizes: each sub-byte field occupies at least one byte,
  // matching LLVM's data layout for GEP offset computation.
  auto body = structType.getBody();
  unsigned offset = 0;
  for (unsigned i = 0; i < fieldIndex && i < body.size(); ++i)
    offset += getLLVMTypeSizeForGEP(body[i]);
  return offset;
}

unsigned LLHDProcessInterpreter::getLLVMTypeSize(Type type) {
  // For LLVM pointer types, use 64 bits (8 bytes)
  if (isa<LLVM::LLVMPointerType>(type))
    return 8;

  // For LLVM struct/array types, use packed aggregate width in bits and
  // round once to bytes. This matches the interpreter's aggregate bit-layout
  // model used by llvm.insertvalue/extractvalue and avoids over-sizing nested
  // sub-byte fields (e.g. struct<(i2, i2)> is 1 byte, not 2).
  if (auto structType = dyn_cast<LLVM::LLVMStructType>(type)) {
    unsigned bitWidth = 0;
    for (Type elemType : structType.getBody())
      bitWidth += getTypeWidth(elemType);
    return (bitWidth + 7) / 8;
  }

  if (auto arrayType = dyn_cast<LLVM::LLVMArrayType>(type)) {
    unsigned bitWidth =
        getTypeWidth(arrayType.getElementType()) * arrayType.getNumElements();
    return (bitWidth + 7) / 8;
  }

  // For integer types, round up to bytes
  if (auto intType = dyn_cast<IntegerType>(type))
    return (intType.getWidth() + 7) / 8;

  // Default: try to use getTypeWidth and convert to bytes
  unsigned bitWidth = getTypeWidth(type);
  return (bitWidth + 7) / 8;
}

unsigned LLHDProcessInterpreter::getLLVMTypeSizeForGEP(Type type) {
  // Returns the byte size of a type as seen by GEP offset computation.
  // For struct types, each field occupies at least one byte (matching LLVM's
  // data layout where sub-byte fields like i1, i3 each occupy 1 byte in
  // memory). This differs from getLLVMTypeSize which uses bit-packed sizes.
  // The distinction matters for structs with sub-byte fields: e.g.
  // struct<(i3, i3)> is 1 byte bit-packed but 2 bytes in GEP layout.
  if (isa<LLVM::LLVMPointerType>(type))
    return 8;

  if (auto structType = dyn_cast<LLVM::LLVMStructType>(type)) {
    unsigned totalBytes = 0;
    for (Type elemType : structType.getBody())
      totalBytes += getLLVMTypeSizeForGEP(elemType);
    return totalBytes;
  }

  if (auto arrayType = dyn_cast<LLVM::LLVMArrayType>(type)) {
    return getLLVMTypeSizeForGEP(arrayType.getElementType()) *
           arrayType.getNumElements();
  }

  // For non-aggregate types, same as getLLVMTypeSize
  return getLLVMTypeSize(type);
}

MemoryBlock *LLHDProcessInterpreter::findMemoryBlock(ProcessId procId,
                                                      Value ptr) {
  // Unwrap GEP / bitcast first so the base pointer is used for lookup.
  if (auto gepOp = ptr.getDefiningOp<LLVM::GEPOp>())
    return findMemoryBlock(procId, gepOp.getBase());
  if (auto bitcastOp = ptr.getDefiningOp<LLVM::BitcastOp>())
    return findMemoryBlock(procId, bitcastOp.getArg());

  // Walk the process -> parent chain looking for the memory block.
  ProcessId cur = procId;
  while (cur != InvalidProcessId) {
    auto stateIt = processStates.find(cur);
    if (stateIt == processStates.end())
      break;
    auto &st = stateIt->second;
    auto it = st.memoryBlocks.find(ptr);
    if (it != st.memoryBlocks.end())
      return &it->second;
    cur = st.parentProcessId;
  }

  // Check module-level allocas (accessible by all processes)
  auto moduleIt = moduleLevelAllocas.find(ptr);
  if (moduleIt != moduleLevelAllocas.end())
    return &moduleIt->second;

  // If ptr is a function entry block argument (i.e., a pointer passed through
  // a function call), the SSA Value differs from the original alloca result.
  // Fall back to address-based lookup for this specific case.
  if (auto blockArg = dyn_cast<BlockArgument>(ptr)) {
    if (blockArg.getOwner()->isEntryBlock()) {
      auto stateIt = processStates.find(procId);
      if (stateIt != processStates.end()) {
        auto valIt = stateIt->second.valueMap.find(ptr);
        if (valIt != stateIt->second.valueMap.end() &&
            !valIt->second.isX()) {
          uint64_t addr = valIt->second.getUInt64();
          return findMemoryBlockByAddress(addr, procId, nullptr);
        }
      }
    }
  }

  return nullptr;
}

MemoryBlock *LLHDProcessInterpreter::findMemoryBlockByAddress(uint64_t addr,
                                                              ProcessId procId,
                                                              uint64_t *outOffset) {
  // Walk the process -> parent chain looking for the memory block by address.
  if (procId != static_cast<ProcessId>(-1)) {
    ProcessId cur = procId;
    while (cur != InvalidProcessId) {
      auto stateIt = processStates.find(cur);
      if (stateIt == processStates.end())
        break;
      auto &state = stateIt->second;
      for (auto &[val, block] : state.memoryBlocks) {
        // Get the address assigned to this Value.
        // Check the original process's valueMap first (child copies parent
        // valueMap), then fall back to the block-owning process's valueMap.
        // NOTE: We must NOT compare iterators across different DenseMaps
        // (would trigger epoch assertion in debug builds when cur != procId).
        uint64_t blockAddr = 0;
        bool foundAddr = false;
        {
          auto &procVM = processStates[procId].valueMap;
          auto it = procVM.find(val);
          if (it != procVM.end() && !it->second.isX()) {
            blockAddr = it->second.getUInt64();
            foundAddr = true;
          }
        }
        if (!foundAddr) {
          auto it2 = state.valueMap.find(val);
          if (it2 != state.valueMap.end() && !it2->second.isX()) {
            blockAddr = it2->second.getUInt64();
            foundAddr = true;
          }
        }
        if (foundAddr && addr >= blockAddr && addr < blockAddr + block.size) {
          if (outOffset) *outOffset = addr - blockAddr;
          return &block;
        }
      }
      cur = state.parentProcessId;
    }
  }
  // Check module-level allocas
  for (auto &[val, block] : moduleLevelAllocas) {
    // Check in moduleInitValueMap for the address
    auto it = moduleInitValueMap.find(val);
    if (it != moduleInitValueMap.end()) {
      uint64_t blockAddr = it->second.getUInt64();
      if (addr >= blockAddr && addr < blockAddr + block.size) {
        if (outOffset) *outOffset = addr - blockAddr;
        return &block;
      }
    }
  }
  // Check global and malloc blocks via O(log n) range index
  {
    uint64_t rangeOffset = 0;
    MemoryBlock *rangeBlock = findBlockByAddress(addr, rangeOffset);
    if (rangeBlock) {
      if (outOffset) *outOffset = rangeOffset;
      return rangeBlock;
    }
  }
  if (outOffset) *outOffset = 0;
  return nullptr;
}

bool LLHDProcessInterpreter::findNativeMemoryBlockByAddress(
    uint64_t addr, uint64_t *outOffset, size_t *outSize) const {
  for (auto &entry : nativeMemoryBlocks) {
    uint64_t baseAddr = entry.first;
    size_t blockSize = entry.second;
    if (addr >= baseAddr && addr < baseAddr + static_cast<uint64_t>(blockSize)) {
      if (outOffset) *outOffset = addr - baseAddr;
      if (outSize) *outSize = blockSize;
      return true;
    }
  }
  if (outOffset) *outOffset = 0;
  if (outSize) *outSize = 0;
  return false;
}

bool LLHDProcessInterpreter::tryReadStringKey(ProcessId procId,
                                               uint64_t strPtrVal,
                                               int64_t strLen,
                                               std::string &out) {
  out.clear();
  if (strLen < 0)
    return false;
  if (strLen == 0)
    return true;
  constexpr int64_t kMaxStringKeyBytes = 1 << 20;
  if (strLen > kMaxStringKeyBytes)
    return false;

  // Check dynamicStrings registry first (for strings from __moore_packed_string_to_string)
  auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtrVal));
  if (dynIt != dynamicStrings.end() && dynIt->second.first && dynIt->second.second > 0) {
    size_t effectiveLen = std::min(static_cast<size_t>(strLen),
                                   static_cast<size_t>(dynIt->second.second));
    out.assign(dynIt->second.first, effectiveLen);
    return true;
  }

  uint64_t offset = 0;
  if (auto *block = findMemoryBlockByAddress(strPtrVal, procId, &offset)) {
    if (!block->initialized)
      return false;
    if (offset + static_cast<uint64_t>(strLen) > block->data.size())
      return false;
    out.assign(reinterpret_cast<const char *>(block->data.data() + offset),
               static_cast<size_t>(strLen));
    return true;
  }

  uint64_t nativeOffset = 0;
  size_t nativeSize = 0;

  if (findNativeMemoryBlockByAddress(strPtrVal, &nativeOffset, &nativeSize)) {
    if (nativeOffset + static_cast<size_t>(strLen) > nativeSize)
      return false;
    auto *nativePtr = reinterpret_cast<const char *>(strPtrVal);
    out.assign(nativePtr, static_cast<size_t>(strLen));
    return true;
  }

  return false;
}

LogicalResult LLHDProcessInterpreter::interpretLLVMAlloca(
    ProcessId procId, LLVM::AllocaOp allocaOp) {
  auto &state = processStates[procId];

  // Get the element type and array size
  Type elemType = allocaOp.getElemType();
  InterpretedValue arraySizeVal = getValue(procId, allocaOp.getArraySize());

  uint64_t arraySize = 1;
  if (!arraySizeVal.isX())
    arraySize = arraySizeVal.getUInt64();

  // Calculate total size in bytes
  unsigned elemSize = getLLVMTypeSize(elemType);
  size_t totalSize = elemSize * arraySize;

  // Create a memory block
  MemoryBlock block(totalSize, getTypeWidth(elemType));
  block.initialized = true;  // Alloca memory is zero-initialized and readable

  // Check if this alloca is at module level (not inside an llhd.process,
  // func.func, or llvm.func). Allocas inside functions should be process-local
  // even if the function is called from a global constructor, because they
  // need to be found via the process's valueMap when findMemoryBlockByAddress
  // is called.
  bool isModuleLevel = !allocaOp->getParentOfType<llhd::ProcessOp>() &&
                       !allocaOp->getParentOfType<mlir::func::FuncOp>() &&
                       !allocaOp->getParentOfType<LLVM::LLVMFuncOp>();

  if (isModuleLevel) {
    // Store in module-level allocas (accessible by all processes)
    moduleLevelAllocas[allocaOp.getResult()] = std::move(block);
  } else {
    // Store in process-local memory
    state.memoryBlocks[allocaOp.getResult()] = std::move(block);
  }

  // Assign a unique address to this pointer (for tracking purposes)
  // Use globalNextAddress to ensure no overlap between module-level
  // and process-level allocas.
  uint64_t addr = globalNextAddress;
  globalNextAddress += totalSize;

  // Store the pointer value (the address)
  setValue(procId, allocaOp.getResult(), InterpretedValue(addr, 64));

  LLVM_DEBUG(llvm::dbgs() << "  llvm.alloca: allocated " << totalSize
                          << " bytes at address 0x" << llvm::format_hex(addr, 16)
                          << (isModuleLevel ? " (module level)" : "") << "\n");

  return success();
}

LogicalResult LLHDProcessInterpreter::interpretLLVMLoad(ProcessId procId,
                                                         LLVM::LoadOp loadOp) {
  // If this is a load from an llhd.ref converted to an LLVM pointer,
  // treat it as a signal probe instead of a memory read.
  if (SignalId sigId = resolveSignalId(loadOp.getAddr())) {
    InterpretedValue signalVal;
    auto pendingIt = pendingEpsilonDrives.find(sigId);
    if (pendingIt != pendingEpsilonDrives.end()) {
      signalVal = pendingIt->second;
    } else {
      const SignalValue &sv = scheduler.getSignalValue(sigId);
      signalVal = InterpretedValue::fromSignalValue(sv);
    }

    Type signalType = getSignalValueType(sigId);
    if (!signalType) {
      if (auto castOp =
              loadOp.getAddr()
                  .getDefiningOp<mlir::UnrealizedConversionCastOp>()) {
        if (castOp.getInputs().size() == 1) {
          if (auto refType =
                  dyn_cast<llhd::RefType>(castOp.getInputs()[0].getType()))
            signalType = refType.getNestedType();
        }
      }
    }
    Type llvmType = loadOp.getType();
    if (!signalVal.isX() && signalType &&
        (isa<hw::StructType, hw::ArrayType>(signalType)) &&
        (isa<LLVM::LLVMStructType, LLVM::LLVMArrayType>(llvmType))) {
      APInt converted =
          convertHWToLLVMLayout(signalVal.getAPInt(), signalType, llvmType);
      signalVal = InterpretedValue(converted);
    }

    unsigned targetWidth = getTypeWidth(loadOp.getType());
    if (signalVal.isX()) {
      signalVal = InterpretedValue::makeX(targetWidth);
    } else if (signalVal.getWidth() != targetWidth) {
      APInt apVal = signalVal.getAPInt();
      if (apVal.getBitWidth() < targetWidth)
        apVal = apVal.zext(targetWidth);
      else if (apVal.getBitWidth() > targetWidth)
        apVal = apVal.trunc(targetWidth);
      signalVal = InterpretedValue(apVal);
    }

    setValue(procId, loadOp.getResult(), signalVal);
    LLVM_DEBUG(llvm::dbgs() << "  llvm.load: read signal " << sigId
                            << " (width=" << targetWidth << ")\n");
    return success();
  }

  // Diagnostic: detect loads from unrealized_conversion_cast of !llhd.ref
  // that failed resolveSignalId — this means signal values won't be read.
  if (auto castOp =
          loadOp.getAddr()
              .getDefiningOp<mlir::UnrealizedConversionCastOp>()) {
    (void)castOp; // checked above
  }

  // Get the pointer value
  InterpretedValue ptrVal = getValue(procId, loadOp.getAddr());
  Type resultType = loadOp.getType();
  unsigned bitWidth = getTypeWidth(resultType);
  unsigned loadSize = getLLVMTypeSize(resultType);

  // Check if this load targets an interface field that has a shadow signal.
  // BFM tasks read interface ports via llvm.load on the struct, but the
  // signal value is driven by the DUT and only exists in the signal domain.
  // Return the signal value directly so BFMs see live hardware values.
  if (!ptrVal.isX() && !interfaceFieldSignals.empty()) {
    uint64_t loadAddr = ptrVal.getUInt64();
    auto fieldIt = interfaceFieldSignals.find(loadAddr);
    if (fieldIt != interfaceFieldSignals.end()) {
      SignalId fieldSigId = fieldIt->second;
      const SignalValue &sv = scheduler.getSignalValue(fieldSigId);
      InterpretedValue signalVal = InterpretedValue::fromSignalValue(sv);

      // Check for pending epsilon drives (not yet committed to scheduler)
      auto pendingIt = pendingEpsilonDrives.find(fieldSigId);
      if (pendingIt != pendingEpsilonDrives.end())
        signalVal = pendingIt->second;

      // If this signal is a struct pointer with known field signals,
      // reconstruct the struct value from individual field signal values.
      auto ptrFieldsIt = interfacePtrToFieldSignals.find(fieldSigId);

      // If the signal is X and NOT in interfacePtrToFieldSignals, it's likely
      // a sub-struct field of a parent interface. Try to reconstruct its value
      // from child field signals via the interfaceFieldPropagation chain.
      if (signalVal.isX() &&
          ptrFieldsIt == interfacePtrToFieldSignals.end()) {
        for (auto &[parentIfaceSigId, parentFieldSigIds] :
             interfacePtrToFieldSignals) {
          int fieldIdx = -1;
          for (size_t i = 0; i < parentFieldSigIds.size(); ++i) {
            if (parentFieldSigIds[i] == fieldSigId) {
              fieldIdx = static_cast<int>(i);
              break;
            }
          }
          if (fieldIdx < 0)
            continue;

          // Reconstruct by reading child field signal values.
          APInt result = APInt::getZero(bitWidth);
          unsigned bitOffset = 0;
          bool anyNonX = false;
          for (size_t fi = static_cast<size_t>(fieldIdx);
               fi < parentFieldSigIds.size() && bitOffset < bitWidth; ++fi) {
            SignalId parentFieldSig = parentFieldSigIds[fi];
            auto propIt2 = interfaceFieldPropagation.find(parentFieldSig);
            const SignalValue *childSV = nullptr;
            if (propIt2 != interfaceFieldPropagation.end()) {
              for (SignalId childSig : propIt2->second) {
                const SignalValue &csv = scheduler.getSignalValue(childSig);
                if (!csv.isUnknown()) {
                  childSV = &csv;
                  break;
                }
              }
            }
            if (!childSV) {
              const SignalValue &psv =
                  scheduler.getSignalValue(parentFieldSig);
              if (!psv.isUnknown())
                childSV = &psv;
            }
            if (childSV) {
              unsigned fw = childSV->getWidth();
              APInt fieldBits = childSV->getAPInt();
              if (fieldBits.getBitWidth() > fw)
                fieldBits = fieldBits.trunc(fw);
              for (unsigned b = 0;
                   b < fw && bitOffset + b < bitWidth; ++b) {
                if (fieldBits[b])
                  result.setBit(bitOffset + b);
              }
              bitOffset += fw;
              anyNonX = true;
            } else {
              unsigned fw = scheduler.getSignalValue(parentFieldSig).getWidth();
              bitOffset += fw;
            }
          }
          if (anyNonX) {
            signalVal = InterpretedValue(result);
            setValue(procId, loadOp.getResult(), signalVal);
            return success();
          }
          break;  // Only check first matching parent
        }
        goto normal_memory_load;
      }
      if (ptrFieldsIt != interfacePtrToFieldSignals.end() &&
          !ptrFieldsIt->second.empty()) {
        APInt result = APInt::getZero(bitWidth);
        unsigned bitOffset = 0;
        for (SignalId fid : ptrFieldsIt->second) {
          const SignalValue &fsv = scheduler.getSignalValue(fid);
          unsigned fw = fsv.getWidth();
          if (!fsv.isUnknown() && bitOffset + fw <= bitWidth) {
            APInt fieldBits = fsv.getAPInt();
            if (fieldBits.getBitWidth() < fw)
              fieldBits = fieldBits.zext(fw);
            else if (fieldBits.getBitWidth() > fw)
              fieldBits = fieldBits.trunc(fw);
            for (unsigned b = 0; b < fw && bitOffset + b < bitWidth; ++b) {
              if (fieldBits[b])
                result.setBit(bitOffset + b);
            }
          }
          bitOffset += fw;
        }
        signalVal = InterpretedValue(result);
        setValue(procId, loadOp.getResult(), signalVal);
        return success();
      }

      // Resize to match expected load width
      if (signalVal.isX()) {
        signalVal = InterpretedValue::makeX(bitWidth);
      } else if (signalVal.getWidth() != bitWidth) {
        APInt apVal = signalVal.getAPInt();
        if (apVal.getBitWidth() < bitWidth)
          apVal = apVal.zext(bitWidth);
        else if (apVal.getBitWidth() > bitWidth)
          apVal = apVal.trunc(bitWidth);
        signalVal = InterpretedValue(apVal);
      }

      setValue(procId, loadOp.getResult(), signalVal);
      LLVM_DEBUG(llvm::dbgs()
                 << "  llvm.load: read interface field signal " << fieldSigId
                 << " at 0x" << llvm::format_hex(loadAddr, 16) << "\n");
      return success();
    }
  }

normal_memory_load:
  // First try to find a local memory block (from alloca)
  MemoryBlock *block = findMemoryBlock(procId, loadOp.getAddr());
  uint64_t offset = 0;
  bool useNative = false;
  uint64_t nativeOffset = 0;
  size_t nativeSize = 0;
  if (block) {
    // Local alloca memory
    // Calculate the offset within the memory block
    if (auto gepOp = loadOp.getAddr().getDefiningOp<LLVM::GEPOp>()) {
      InterpretedValue baseVal = getValue(procId, gepOp.getBase());
      if (!baseVal.isX() && !ptrVal.isX()) {
        offset = ptrVal.getUInt64() - baseVal.getUInt64();
      }
    }
  } else if (!ptrVal.isX()) {
    // Check if this is a global memory access
    uint64_t addr = ptrVal.getUInt64();

    // Find which global or malloc block this address belongs to.
    // Uses O(log n) binary search via the address range index instead of
    // O(n) linear scan through all 6000+ globals.
    block = findBlockByAddress(addr, offset);
    LLVM_DEBUG(if (block) llvm::dbgs()
               << "  llvm.load: found block at offset " << offset << "\n");
    if (!block) {
      if (findNativeMemoryBlockByAddress(addr, &nativeOffset, &nativeSize)) {
        useNative = true;
        offset = nativeOffset;
        LLVM_DEBUG(llvm::dbgs() << "  llvm.load: found native block at 0x"
                                << llvm::format_hex(addr - nativeOffset, 16)
                                << " offset " << nativeOffset << "\n");
      }
    }
  }

  // Fallback: use comprehensive address-based search (also checks
  // process-local allocas by address, which findMemoryBlock's SSA
  // tracing may miss when the pointer was loaded from memory).
  // Also try this when useNative is set but the native block is too small
  // for the requested load size (e.g., an 8-byte assoc array slot matched
  // but we need to load a 24-byte struct from a larger malloc'd block).
  if (!block && !ptrVal.isX()) {
    unsigned loadSizeCheck = getLLVMTypeSize(loadOp.getResult().getType());
    if (!useNative || (offset + loadSizeCheck > nativeSize)) {
      uint64_t fbOffset = 0;
      auto *fbBlock = findMemoryBlockByAddress(ptrVal.getUInt64(), procId, &fbOffset);
      if (fbBlock) {
        block = fbBlock;
        offset = fbOffset;
        useNative = false;
        LLVM_DEBUG(llvm::dbgs() << "  llvm.load: findMemoryBlockByAddress found "
                                   "block at offset " << offset << "\n");
      }
    }
  }

  // Native pointer access is only allowed for known blocks registered by the
  // runtime (e.g., associative array element refs). If a pointer is not in any
  // tracked block, return X (unknown value).

  if (!block && !useNative) {
    LLVM_DEBUG(llvm::dbgs() << "  llvm.load: no memory block found for pointer 0x"
                            << llvm::format_hex(ptrVal.isX() ? 0 : ptrVal.getUInt64(), 16) << "\n");
    setValue(procId, loadOp.getResult(),
             InterpretedValue::makeX(bitWidth));
    return success();
  }

  if (block) {
    if (offset + loadSize > block->size) {
      LLVM_DEBUG(llvm::dbgs() << "  llvm.load: out of bounds access (offset="
                              << offset << " size=" << loadSize
                              << " block_size=" << block->size << ")\n");
      setValue(procId, loadOp.getResult(),
               InterpretedValue::makeX(bitWidth));
      return success();
    }

    // Check if memory has been initialized
    if (!block->initialized) {
      LLVM_DEBUG(llvm::dbgs() << "  llvm.load: reading uninitialized memory\n");
      setValue(procId, loadOp.getResult(),
               InterpretedValue::makeX(bitWidth));
      return success();
    }
  } else {
    if (offset + loadSize > nativeSize) {
      // Expand the tracked size - same rationale as the store handler.
      uint64_t baseAddr = ptrVal.getUInt64() - offset;
      nativeMemoryBlocks[baseAddr] = offset + loadSize;
      nativeSize = offset + loadSize;
      LLVM_DEBUG(llvm::dbgs() << "  llvm.load: expanded native block at 0x"
                              << llvm::format_hex(baseAddr, 16) << " to "
                              << nativeSize << " bytes\n");
    }
  }

  auto readByte = [&](unsigned i) -> uint8_t {
    if (block)
      return block->data[offset + i];
    auto *nativePtr = reinterpret_cast<const uint8_t *>(ptrVal.getUInt64());
    return nativePtr[i];
  };

  // Read bytes from memory and construct the value (little-endian).
  // Clamp to the number of bytes needed for the value width to avoid
  // shifting past the APInt width when loadSize includes padding.
  unsigned bytesForValue = std::min(loadSize, (bitWidth + 7) / 8);
  uint64_t value = 0;
  for (unsigned i = 0; i < bytesForValue && i < 8; ++i) {
    value |= static_cast<uint64_t>(readByte(i)) << (i * 8);
  }

  // For values larger than 64 bits, use APInt directly
  if (bitWidth > 64) {
    APInt apValue(bitWidth, 0);
    for (unsigned i = 0; i < bytesForValue; ++i) {
      APInt byteVal(bitWidth, readByte(i));
      apValue |= byteVal.shl(i * 8);
    }
    setValue(procId, loadOp.getResult(), InterpretedValue(apValue));
    LLVM_DEBUG(llvm::dbgs() << "  llvm.load: loaded wide value ("
                            << loadSize << " bytes) from offset " << offset << "\n");
  } else {
    // Mask the loaded value to the exact bit width. Memory loads read
    // whole bytes, but sub-byte types (e.g., i1, i5) need only the
    // low bits. Without masking, a byte value like 0xFF for an i1 load
    // triggers an APInt assertion failure.
    if (bitWidth > 0 && bitWidth < 64)
      value &= (1ULL << bitWidth) - 1;
    setValue(procId, loadOp.getResult(), InterpretedValue(value, bitWidth));
    LLVM_DEBUG(llvm::dbgs() << "  llvm.load: loaded 0x"
                            << llvm::format_hex(value, 16) << " ("
                            << loadSize << " bytes) from offset " << offset << "\n");
  }

  return success();
}

LogicalResult LLHDProcessInterpreter::interpretLLVMStore(
    ProcessId procId, LLVM::StoreOp storeOp) {
  // If this is a store to an llhd.ref converted to an LLVM pointer,
  // treat it as a signal drive instead of a memory write.
  if (SignalId sigId = resolveSignalId(storeOp.getAddr())) {
    InterpretedValue storeVal = getValue(procId, storeOp.getValue());
    const SignalValue &current = scheduler.getSignalValue(sigId);
    unsigned targetWidth = current.getWidth();

    Type signalType = getSignalValueType(sigId);
    if (!signalType) {
      if (auto castOp =
              storeOp.getAddr()
                  .getDefiningOp<mlir::UnrealizedConversionCastOp>()) {
        if (castOp.getInputs().size() == 1) {
          if (auto refType =
                  dyn_cast<llhd::RefType>(castOp.getInputs()[0].getType()))
            signalType = refType.getNestedType();
        }
      }
    }
    Type llvmType = storeOp.getValue().getType();
    if (!storeVal.isX() && signalType &&
        (isa<hw::StructType, hw::ArrayType>(signalType)) &&
        (isa<LLVM::LLVMStructType, LLVM::LLVMArrayType>(llvmType))) {
      APInt converted =
          convertLLVMToHWLayout(storeVal.getAPInt(), llvmType, signalType);
      storeVal = InterpretedValue(converted);
    }

    if (storeVal.isX()) {
      storeVal = InterpretedValue::makeX(targetWidth);
    } else if (storeVal.getWidth() != targetWidth) {
      APInt apVal = storeVal.getAPInt();
      if (apVal.getBitWidth() < targetWidth)
        apVal = apVal.zext(targetWidth);
      else if (apVal.getBitWidth() > targetWidth)
        apVal = apVal.trunc(targetWidth);
      storeVal = InterpretedValue(apVal);
    }

    pendingEpsilonDrives[sigId] = storeVal;
    scheduler.updateSignal(sigId, storeVal.toSignalValue());
    LLVM_DEBUG(llvm::dbgs() << "  llvm.store: wrote signal " << sigId
                            << " (width=" << targetWidth << ")\n");
    return success();
  }

  // Signal not resolved - going to memory
  // Get the pointer value first
  InterpretedValue ptrVal = getValue(procId, storeOp.getAddr());

  // Find the memory block for this pointer
  MemoryBlock *block = findMemoryBlock(procId, storeOp.getAddr());
  uint64_t offset = 0;
  bool useNative = false;
  uint64_t nativeOffset = 0;
  size_t nativeSize = 0;

  if (block) {
    // Local alloca memory
    // Calculate the offset within the memory block
    if (auto gepOp = storeOp.getAddr().getDefiningOp<LLVM::GEPOp>()) {
      InterpretedValue baseVal = getValue(procId, gepOp.getBase());
      if (!baseVal.isX() && !ptrVal.isX()) {
        offset = ptrVal.getUInt64() - baseVal.getUInt64();
      }
    }
  } else if (!ptrVal.isX()) {
    // Check if this is a global memory access
    uint64_t addr = ptrVal.getUInt64();

    // Find which global or malloc block this address belongs to.
    // Uses O(log n) binary search via the address range index.
    block = findBlockByAddress(addr, offset);
    LLVM_DEBUG(if (block) llvm::dbgs()
               << "  llvm.store: found block at offset " << offset << "\n");

    // Check module-level allocas by address. This is needed when the store
    // address is computed via a GEP on a pointer loaded from memory (e.g.,
    // class member access through a heap-allocated class instance).
    if (!block) {
      for (auto &[val, memBlock] : moduleLevelAllocas) {
        auto addrIt = moduleInitValueMap.find(val);
        if (addrIt != moduleInitValueMap.end()) {
          uint64_t blockAddr = addrIt->second.getUInt64();
          if (addr >= blockAddr && addr < blockAddr + memBlock.size) {
            block = &memBlock;
            offset = addr - blockAddr;
            LLVM_DEBUG(llvm::dbgs() << "  llvm.store: found module-level alloca at 0x"
                                    << llvm::format_hex(blockAddr, 16)
                                    << " offset " << offset << "\n");
            break;
          }
        }
      }
    }

    if (!block) {
      if (findNativeMemoryBlockByAddress(addr, &nativeOffset, &nativeSize)) {
        useNative = true;
        offset = nativeOffset;
        LLVM_DEBUG(llvm::dbgs() << "  llvm.store: found native block at 0x"
                                << llvm::format_hex(addr - nativeOffset, 16)
                                << " offset " << nativeOffset << "\n");
      }
    }
  }

  // Get the value to store
  InterpretedValue storeVal = getValue(procId, storeOp.getValue());
  unsigned storeSize = getLLVMTypeSize(storeOp.getValue().getType());

  // Fallback: use comprehensive address-based search (also checks
  // process-local allocas by address, which findMemoryBlock's SSA
  // tracing may miss when the pointer was loaded from memory).
  // Also try this when useNative is set but the native block is too small
  // for the requested store size (e.g., an 8-byte assoc array slot matched
  // but we need to store a 24-byte struct into a larger malloc'd block).
  if (!block && !ptrVal.isX()) {
    if (!useNative || (offset + storeSize > nativeSize)) {
      uint64_t fbOffset = 0;
      auto *fbBlock = findMemoryBlockByAddress(ptrVal.getUInt64(), procId, &fbOffset);
      if (fbBlock) {
        block = fbBlock;
        offset = fbOffset;
        useNative = false;
        LLVM_DEBUG(llvm::dbgs() << "  llvm.store: findMemoryBlockByAddress found "
                                   "block at offset " << offset << "\n");
      }
    }
  }

  // Native pointer access is only allowed for known blocks registered by the
  // runtime. If pointer is not tracked, the store is silently skipped (stores
  // to X are no-ops anyway).

  if (!block && !useNative) {
    LLVM_DEBUG(llvm::dbgs() << "  llvm.store: no memory block found for pointer 0x"
                            << llvm::format_hex(ptrVal.isX() ? 0 : ptrVal.getUInt64(), 16) << "\n");
    return success(); // Don't fail, just skip the store
  }

  if (block) {
    if (offset + storeSize > block->size) {
      LLVM_DEBUG(llvm::dbgs() << "  llvm.store: out of bounds access\n");
      return success();
    }
  } else {
    if (offset + storeSize > nativeSize) {
      // The native block (from __moore_assoc_get_ref) was tracked with a
      // smaller size than needed. Expand the tracked size and proceed with the
      // store - the native memory was allocated by the runtime and is likely
      // large enough. MooreToCore may pass a smaller valueSize parameter than
      // the actual struct size stored into the slot.
      uint64_t baseAddr = ptrVal.getUInt64() - offset;
      nativeMemoryBlocks[baseAddr] = offset + storeSize;
      nativeSize = offset + storeSize;
      LLVM_DEBUG(llvm::dbgs() << "  llvm.store: expanded native block at 0x"
                              << llvm::format_hex(baseAddr, 16) << " to "
                              << nativeSize << " bytes\n");
    }
  }

  // Write bytes to memory (little-endian)
  if (!storeVal.isX()) {
    const APInt &apValue = storeVal.getAPInt();
    auto storeByte = [&](unsigned i, uint8_t value) {
      if (block)
        block->data[offset + i] = value;
      else
        reinterpret_cast<uint8_t *>(ptrVal.getUInt64())[i] = value;
    };
    if (apValue.getBitWidth() > 64) {
      // Handle wide values using APInt operations
      unsigned bitWidth = apValue.getBitWidth();
      for (unsigned i = 0; i < storeSize; ++i) {
        unsigned bitPos = i * 8;
        if (bitPos >= bitWidth) {
          // Beyond the value's bit width - store zero
          storeByte(i, 0);
        } else {
          // Extract available bits (up to 8), remaining bits are zero
          unsigned bitsAvailable = std::min(8u, bitWidth - bitPos);
          uint8_t byteVal = static_cast<uint8_t>(
              apValue.extractBits(bitsAvailable, bitPos).getZExtValue());
          storeByte(i, byteVal);
        }
      }
    } else {
      uint64_t value = storeVal.getUInt64();
      for (unsigned i = 0; i < storeSize && i < 8; ++i) {
        storeByte(i, static_cast<uint8_t>((value >> (i * 8)) & 0xFF));
      }
    }
    if (block)
      block->initialized = true;
  }

  LLVM_DEBUG(llvm::dbgs() << "  llvm.store: stored "
                          << (storeVal.isX() ? "X" : std::to_string(storeVal.getUInt64()))
                          << " (" << storeSize << " bytes) at offset " << offset << "\n");

  // UVM fix: when m_inst is stored during global init, also mirror to uvm_top.
  // This prevents the re-entrant m_uvm_get_root() call from seeing
  // m_inst != uvm_top and triggering an infinite fatal loop.
  if (inGlobalInit && !storeVal.isX() && storeVal.getUInt64() != 0) {
    if (auto addrOfOp = storeOp.getAddr().getDefiningOp<LLVM::AddressOfOp>()) {
      if (addrOfOp.getGlobalName().contains("uvm_root::m_inst")) {
        StringRef uvmTopName = "uvm_pkg::uvm_top";
        auto topBlockIt = globalMemoryBlocks.find(uvmTopName);
        if (topBlockIt != globalMemoryBlocks.end()) {
          auto &topBlock = topBlockIt->second;
          uint64_t value = storeVal.getUInt64();
          for (unsigned i = 0; i < storeSize && i < 8 && i < topBlock.size; ++i)
            topBlock.data[i] = static_cast<uint8_t>((value >> (i * 8)) & 0xFF);
          topBlock.initialized = true;
          LLVM_DEBUG(llvm::dbgs()
                     << "  UVM fix: mirrored m_inst store to uvm_top ("
                     << llvm::format_hex(value, 18) << ")\n");
        }
      }
    }
  }
  // Sync signal backing memory: when a store writes to a memory block that
  // backs an LLHD signal (allocated in unrealized_conversion_cast for signals
  // without llhd.drv users), also update pendingEpsilonDrives and the
  // scheduler so that llhd.prb sees the new value.
  if (block && !signalBackingMemory.empty()) {
    for (auto &[backingSigId, backingInfo] : signalBackingMemory) {
      auto &backingSt = processStates[backingInfo.first];
      auto backingBlkIt = backingSt.memoryBlocks.find(backingInfo.second);
      if (backingBlkIt != backingSt.memoryBlocks.end() &&
          &backingBlkIt->second == block) {
        // This store wrote to signal backing memory — read back and sync
        const SignalValue &current = scheduler.getSignalValue(backingSigId);
        unsigned sigWidth = current.getWidth();
        unsigned sigBytes = (sigWidth + 7) / 8;
        APInt newBits = APInt::getZero(sigWidth);
        for (unsigned i = 0; i < sigBytes && i * 8 < sigWidth; ++i) {
          unsigned bitsToInsert = std::min(8u, sigWidth - i * 8);
          APInt byteVal(bitsToInsert,
                        block->data[i] & ((1u << bitsToInsert) - 1));
          safeInsertBits(newBits, byteVal, i * 8);
        }
        // Convert LLVM layout to HW layout if the signal has struct type
        Type sigType = getSignalValueType(backingSigId);
        if (sigType && isa<hw::StructType, hw::ArrayType>(sigType)) {
          Type llvmType = storeOp.getValue().getType();
          if (isa<LLVM::LLVMStructType, LLVM::LLVMArrayType>(llvmType))
            newBits = convertLLVMToHWLayout(newBits, llvmType, sigType);
        }
        InterpretedValue syncVal(newBits);
        pendingEpsilonDrives[backingSigId] = syncVal;
        scheduler.updateSignal(backingSigId, syncVal.toSignalValue());
        break;
      }
    }
  }

  // Drive interface field shadow signals. When a store targets an address
  // within a known interface struct, also drive the corresponding shadow
  // signal so that processes sensitive to the interface field wake up.
  if (!ptrVal.isX() && !interfaceFieldSignals.empty()) {
    uint64_t storeAddr = ptrVal.getUInt64();
    auto fieldIt = interfaceFieldSignals.find(storeAddr);
    if (fieldIt != interfaceFieldSignals.end()) {
      SignalId fieldSigId = fieldIt->second;
      // Debug: track stores to 64-bit interface fields (PWDATA, PADDR, etc.)
      LLVM_DEBUG({
        const SignalValue &dbgCur = scheduler.getSignalValue(fieldSigId);
        if (dbgCur.getWidth() == 64 && !storeVal.isX() &&
            storeVal.getUInt64() != 0) {
          llvm::dbgs() << "[IFACE-STORE] sig=" << fieldSigId
                       << " addr=0x" << llvm::format_hex(storeAddr, 10)
                       << " val=" << storeVal.getUInt64();
          auto revIt = childToParentFieldAddr.find(storeAddr);
          if (revIt != childToParentFieldAddr.end())
            llvm::dbgs() << " (reverse→parent@0x"
                         << llvm::format_hex(revIt->second, 10) << ")";
          auto propIt = interfaceFieldPropagation.find(fieldSigId);
          if (propIt != interfaceFieldPropagation.end())
            llvm::dbgs() << " (fwd→" << propIt->second.size() << " children)";
          llvm::dbgs() << "\n";
        }
      });
      const SignalValue &current = scheduler.getSignalValue(fieldSigId);
      unsigned targetWidth = current.getWidth();

      InterpretedValue driveVal = storeVal;
      if (driveVal.isX()) {
        driveVal = InterpretedValue::makeX(targetWidth);
      } else if (driveVal.getWidth() != targetWidth) {
        APInt apVal = driveVal.getAPInt();
        if (apVal.getBitWidth() < targetWidth)
          apVal = apVal.zext(targetWidth);
        else if (apVal.getBitWidth() > targetWidth)
          apVal = apVal.trunc(targetWidth);
        driveVal = InterpretedValue(apVal);
      }

      // Only drive if the value actually changed — prevents zero-delta loops
      // in always_comb processes that copy interface fields bidirectionally.
      SignalValue newSigVal = driveVal.toSignalValue();
      if (current == newSigVal) {
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.store: shadow signal " << fieldSigId
                   << " unchanged, skipping drive\n");
      } else {
        pendingEpsilonDrives[fieldSigId] = driveVal;
        scheduler.updateSignal(fieldSigId, newSigVal);
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.store: drove interface shadow signal "
                   << fieldSigId << " at 0x"
                   << llvm::format_hex(storeAddr, 16) << "\n");

        // Propagate to linked child BFM interface field signals.
        // Also update backing memory so that loads from the struct see
        // the new value (not just signals).
        auto propagateToSignal = [&](SignalId targetSigId) {
          const SignalValue &targetCurrent =
              scheduler.getSignalValue(targetSigId);
          unsigned targetW = targetCurrent.getWidth();
          InterpretedValue targetDriveVal = storeVal;
          if (targetDriveVal.isX()) {
            targetDriveVal = InterpretedValue::makeX(targetW);
          } else if (targetDriveVal.getWidth() != targetW) {
            APInt apVal = targetDriveVal.getAPInt();
            if (apVal.getBitWidth() < targetW)
              apVal = apVal.zext(targetW);
            else if (apVal.getBitWidth() > targetW)
              apVal = apVal.trunc(targetW);
            targetDriveVal = InterpretedValue(apVal);
          }
          SignalValue targetNewVal = targetDriveVal.toSignalValue();
          pendingEpsilonDrives[targetSigId] = targetDriveVal;

          // Synchronous update: immediately set the signal value and trigger
          // any processes that have already set up their event waits.
          scheduler.updateSignal(targetSigId, targetNewVal);

          // Write to backing memory (synchronous — needed for llvm.load).
          auto tgtAddrIt = fieldSignalToAddr.find(targetSigId);
          if (tgtAddrIt != fieldSignalToAddr.end()) {
            uint64_t tgtAddr = tgtAddrIt->second;
            uint64_t tgtOff = 0;
            MemoryBlock *tgtBlock = findBlockByAddress(tgtAddr, tgtOff);
            unsigned tgtStoreSize = (targetW + 7) / 8;
            if (tgtBlock && tgtOff + tgtStoreSize <= tgtBlock->size) {
              if (!targetDriveVal.isX()) {
                APInt bits = targetDriveVal.getAPInt();
                if (bits.getBitWidth() < tgtStoreSize * 8)
                  bits = bits.zext(tgtStoreSize * 8);
                for (unsigned i = 0; i < tgtStoreSize; ++i)
                  tgtBlock->data[tgtOff + i] =
                      bits.extractBitsAsZExtValue(8, i * 8);
              }
            }
          }
        };

        // Forward propagation only (no cross-sibling fan-out).
        // Cross-sibling propagation was removed because auto-linked
        // entries in interfaceFieldPropagation can contain cross-field
        // links (e.g. PWRITE → PADDR), causing field contamination.
        auto propIt = interfaceFieldPropagation.find(fieldSigId);
        if (propIt != interfaceFieldPropagation.end()) {
          for (SignalId childSigId : propIt->second)
            propagateToSignal(childSigId);
          // Cascade one level for intra-interface linked signals only.
          // Only signals that received intra-interface links need cascading.
          // Normal BFM fields already get sibling propagation via the
          // reverse propagation handler below, so cascading them here
          // would cause double-propagation and corrupt edge detection.
          for (SignalId childSigId : propIt->second) {
            if (!intraLinkedSignals.count(childSigId))
              continue;
            auto childPropIt = interfaceFieldPropagation.find(childSigId);
            if (childPropIt != interfaceFieldPropagation.end()) {
              for (SignalId grandchildId : childPropIt->second) {
                if (grandchildId != fieldSigId)
                  propagateToSignal(grandchildId);
              }
            }
          }
        }

        // Reverse propagation: when a CHILD interface field is written,
        // propagate UP to the parent field, then forward from the parent
        // to all OTHER children. This ensures sibling BFMs (e.g., monitor
        // and driver on the same bus) see each other's writes.
        // The value-changed check in propagateToSignal prevents loops.
        auto childAddrIt = fieldSignalToAddr.find(fieldSigId);
        if (childAddrIt != fieldSignalToAddr.end()) {
          auto parentAddrIt =
              childToParentFieldAddr.find(childAddrIt->second);
          if (parentAddrIt != childToParentFieldAddr.end()) {
            auto parentFieldIt =
                interfaceFieldSignals.find(parentAddrIt->second);
            if (parentFieldIt != interfaceFieldSignals.end()) {
              SignalId parentFieldSigId = parentFieldIt->second;
              // Update parent shadow signal (skips if unchanged).
              const SignalValue &parentCurrent =
                  scheduler.getSignalValue(parentFieldSigId);
              if (!(parentCurrent == newSigVal)) {
                propagateToSignal(parentFieldSigId);
                // Forward-propagate from parent to all children
                // (the originating child will be skipped by the
                // value-changed check since it already has the value).
                auto parentPropIt =
                    interfaceFieldPropagation.find(parentFieldSigId);
                if (parentPropIt != interfaceFieldPropagation.end()) {
                  for (SignalId siblingId : parentPropIt->second) {
                    if (siblingId != fieldSigId)
                      propagateToSignal(siblingId);
                  }
                  // Cascade: if any sibling that was just propagated has its
                  // own forward children (from intra-interface links), also
                  // propagate to those. This handles the bridge from internal
                  // output fields (e.g., txSclkOutput) through public fields
                  // (e.g., sclk) to child BFM fields (e.g., MonitorBFM.sclk).
                  for (SignalId siblingId : parentPropIt->second) {
                    if (siblingId == fieldSigId)
                      continue;
                    auto sibPropIt =
                        interfaceFieldPropagation.find(siblingId);
                    if (sibPropIt != interfaceFieldPropagation.end()) {
                      for (SignalId grandchildId : sibPropIt->second) {
                        if (grandchildId != fieldSigId &&
                            grandchildId != parentFieldSigId)
                          propagateToSignal(grandchildId);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }

  // Check if any processes are waiting on memory events at this location.
  // If the stored value changed, wake those processes.
  checkMemoryEventWaiters();

  return success();
}

LogicalResult LLHDProcessInterpreter::interpretLLVMGEP(ProcessId procId,
                                                        LLVM::GEPOp gepOp) {
  // Get the base pointer value
  InterpretedValue baseVal = getValue(procId, gepOp.getBase());
  if (baseVal.isX()) {
    setValue(procId, gepOp.getResult(), InterpretedValue::makeX(64));
    return success();
  }

  uint64_t baseAddr = baseVal.getUInt64();

  // Detect null pointer dereference: GEP on NULL (address 0) or near-null
  // addresses (< 0x1000) indicates a null object handle dereference.
  if (baseAddr < 0x1000 && baseAddr != 0) {
    // Non-zero but very small address - likely result of GEP on null
    LLVM_DEBUG(llvm::dbgs() << "  llvm.getelementptr: near-null base address 0x"
                            << llvm::format_hex(baseAddr, 16) << " -> X\n");
    setValue(procId, gepOp.getResult(), InterpretedValue::makeX(64));
    return success();
  }
  uint64_t offset = 0;

  // Get the element type
  Type elemType = gepOp.getElemType();

  // Process indices using the GEPIndicesAdaptor
  auto indices = gepOp.getIndices();
  Type currentType = elemType;

  size_t idx = 0;
  for (auto indexValue : indices) {
    int64_t indexVal = 0;

    // Check if this is a constant index (IntegerAttr) or dynamic (Value)
    if (auto intAttr = llvm::dyn_cast_if_present<IntegerAttr>(indexValue)) {
      indexVal = intAttr.getInt();
    } else if (auto dynamicIdx = llvm::dyn_cast_if_present<Value>(indexValue)) {
      InterpretedValue dynVal = getValue(procId, dynamicIdx);
      if (dynVal.isX()) {
        setValue(procId, gepOp.getResult(), InterpretedValue::makeX(64));
        return success();
      }
      indexVal = static_cast<int64_t>(dynVal.getUInt64());
    }

    if (idx == 0) {
      // First index: scales by the size of the pointed-to type
      offset += indexVal * getLLVMTypeSizeForGEP(elemType);
    } else if (auto structType = dyn_cast<LLVM::LLVMStructType>(currentType)) {
      // Struct indexing: accumulate offsets of previous fields.
      // Use GEP-aligned sizes so sub-byte struct fields (e.g. struct<(i3,i3)>)
      // occupy their correct byte span, keeping subsequent field offsets right.
      auto body = structType.getBody();
      for (int64_t i = 0; i < indexVal && static_cast<size_t>(i) < body.size(); ++i) {
        offset += getLLVMTypeSizeForGEP(body[i]);
      }
      if (static_cast<size_t>(indexVal) < body.size()) {
        currentType = body[indexVal];
      }
    } else if (auto arrayType = dyn_cast<LLVM::LLVMArrayType>(currentType)) {
      // Array indexing: multiply by element size
      offset += indexVal * getLLVMTypeSizeForGEP(arrayType.getElementType());
      currentType = arrayType.getElementType();
    } else {
      // For other types, treat as array of the current type
      offset += indexVal * getLLVMTypeSizeForGEP(currentType);
    }
    ++idx;
  }

  uint64_t resultAddr = baseAddr + offset;
  setValue(procId, gepOp.getResult(), InterpretedValue(resultAddr, 64));

  LLVM_DEBUG(llvm::dbgs() << "  llvm.getelementptr: base=0x"
                          << llvm::format_hex(baseAddr, 16) << " offset="
                          << offset << " result=0x"
                          << llvm::format_hex(resultAddr, 16) << "\n");

  return success();
}

LogicalResult LLHDProcessInterpreter::interpretLLVMCall(ProcessId procId,
                                                         LLVM::CallOp callOp) {
  // Get the callee name
  auto callee = callOp.getCallee();
  std::string resolvedCalleeName;

  if (!callee) {
    // Indirect call - try to resolve through vtable
    // The callee operand should be a function pointer loaded from a vtable
    // For indirect calls, the first callee operand is the function pointer
    auto calleeOperands = callOp.getCalleeOperands();
    if (!calleeOperands.empty()) {
      Value calleeOperand = calleeOperands.front();
      InterpretedValue funcPtrVal = getValue(procId, calleeOperand);
      if (!funcPtrVal.isX()) {
        uint64_t funcAddr = funcPtrVal.getUInt64();
        auto it = addressToFunction.find(funcAddr);
        if (it != addressToFunction.end()) {
          resolvedCalleeName = it->second;
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: resolved indirect call 0x"
                                  << llvm::format_hex(funcAddr, 16)
                                  << " -> " << resolvedCalleeName << "\n");
        } else {
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: indirect call to 0x"
                                  << llvm::format_hex(funcAddr, 16)
                                  << " not in vtable map\n");
        }
      }
    }

    if (resolvedCalleeName.empty()) {
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: indirect call could not be resolved\n");
      for (Value result : callOp.getResults()) {
        setValue(procId, result,
                 InterpretedValue::makeX(getTypeWidth(result.getType())));
      }
      return success();
    }
  } else {
    resolvedCalleeName = callee->str();
  }

  StringRef calleeName = resolvedCalleeName;

  // Debug: track current LLVM callee for crash diagnostics
  g_lastLLVMCallCallee = calleeName.data();

  // Intercept uvm_port_base::connect() (llvm.call path) and record native
  // port→provider connections before UVM phase checks can reject them.
  if (calleeName.contains("uvm_port_base") &&
      calleeName.contains("::connect") &&
      !calleeName.contains("connect_phase")) {
    SmallVector<InterpretedValue, 4> connectArgs;
    for (Value operand : callOp.getOperands())
      connectArgs.push_back(getValue(procId, operand));
    if (connectArgs.size() >= 2 && !connectArgs[0].isX() &&
        !connectArgs[1].isX()) {
      uint64_t selfAddr = connectArgs[0].getUInt64();
      uint64_t providerAddr = connectArgs[1].getUInt64();
      if (selfAddr != 0 && providerAddr != 0) {
        auto &conns = analysisPortConnections[selfAddr];
        if (std::find(conns.begin(), conns.end(), providerAddr) == conns.end()) {
          conns.push_back(providerAddr);
          invalidateUvmSequencerQueueCache(selfAddr);
        }
      }
    }
    return success();
  }

  // Intercept uvm_port_base::size() in LLVM::CallOp path and report count
  // from native analysisPortConnections.
  if (calleeName.contains("uvm_port_base") &&
      calleeName.ends_with("::size") && callOp.getNumResults() >= 1) {
    SmallVector<InterpretedValue, 2> sizeArgs;
    for (Value operand : callOp.getOperands())
      sizeArgs.push_back(getValue(procId, operand));
    uint64_t selfAddr =
        (!sizeArgs.empty() && !sizeArgs[0].isX()) ? sizeArgs[0].getUInt64() : 0;
    int32_t count = getNativeUvmPortSize(analysisPortConnections, selfAddr);
    Value result = callOp.getResult();
    unsigned width = getTypeWidth(result.getType());
    setValue(procId, result,
             InterpretedValue(
                 llvm::APInt(width, static_cast<uint64_t>(count), false)));
    LLVM_DEBUG(llvm::dbgs() << "  llvm.call: uvm_port_base::size self=0x"
                            << llvm::format_hex(selfAddr, 16) << " -> "
                            << count << "\n");
    return success();
  }

  // Intercept uvm_port_base::resolve_bindings() (LLVM::CallOp path) — skip
  // resolution since we handle connections natively via analysisPortConnections.
  // Without this, resolve_bindings tries to set up m_if/m_imp_list which hangs
  // because our connect() interceptor doesn't populate UVM's internal state.
  if (calleeName.contains("uvm_port_base") &&
      calleeName.contains("::resolve_bindings")) {
    LLVM_DEBUG(llvm::dbgs()
               << "  llvm.call: resolve_bindings intercepted (no-op)\n");
    return success();
  }

  // Track UVM root construction for re-entrancy handling
  // When m_uvm_get_root is called, we need to mark root construction as started
  // so that re-entrant calls (via uvm_component::new -> get_root) can skip
  // the m_inst != uvm_top comparison that fails during construction.
  bool isGetRoot = calleeName == "m_uvm_get_root";
  if (isGetRoot) {
    ++uvmGetRootDepth;
    if (uvmGetRootDepth == 1) {
      // First call - mark root construction as starting
      __moore_uvm_root_constructing_start();
      LLVM_DEBUG(llvm::dbgs() << "  UVM: m_uvm_get_root entry (depth=1), "
                              << "marking root construction started\n");
    } else {
      LLVM_DEBUG(llvm::dbgs() << "  UVM: m_uvm_get_root re-entry (depth="
                              << uvmGetRootDepth << ")\n");
    }
  }

  // Use RAII to ensure depth is decremented even on early returns
  auto decrementDepthOnExit = llvm::make_scope_exit([&]() {
    if (isGetRoot) {
      --uvmGetRootDepth;
      if (uvmGetRootDepth == 0) {
        // Last call completed - mark root construction as finished
        __moore_uvm_root_constructing_end();
        LLVM_DEBUG(llvm::dbgs() << "  UVM: m_uvm_get_root exit (depth=0), "
                                << "marking root construction ended\n");
      }
    }
  });

  // Look up the function - use cached active process state to avoid
  // redundant std::map lookups (activeProcessState is set by executeProcess).
  ProcessExecutionState *statePtr;
  if (procId == activeProcessId && activeProcessState) {
    statePtr = activeProcessState;
  } else {
    auto stateIt = processStates.find(procId);
    if (stateIt == processStates.end()) {
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: process state not found for "
                              << "procId=" << procId << ", using rootModule\n");
      processStates[procId] = ProcessExecutionState();
      stateIt = processStates.find(procId);
    }
    statePtr = &stateIt->second;
  }
  auto &state = *statePtr;

  // Use function lookup cache to avoid repeated moduleOp.lookupSymbol calls.
  // This turns O(n) symbol table lookups into O(1) hash map lookups for
  // repeated calls to the same function (which dominate UVM testbenches).
  auto cacheIt = funcLookupCache.find(calleeName);
  if (cacheIt != funcLookupCache.end()) {
    auto &cached = cacheIt->second;
    if (cached.kind == 1) {
      // Cached as func::FuncOp
      auto mlirFuncOp = cast<func::FuncOp>(cached.op);
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: resolved '" << calleeName
                              << "' as func.func (cached)\n");

      // DPI function interception: if the func has no body, try to intercept
      // it as a known DPI function (uvm_re_*, uvm_hdl_*, uvm_dpi_*).
      if (mlirFuncOp.getBody().empty()) {
        if (succeeded(interceptDPIFunc(procId, calleeName, callOp)))
          return success();
        // Not a known DPI function - return X for all results
        for (Value result : callOp.getResults())
          setValue(procId, result,
                   InterpretedValue::makeX(getTypeWidth(result.getType())));
        return success();
      }

      SmallVector<InterpretedValue, 4> args;
      SmallVector<Value, 4> callOperands;
      for (Value arg : callOp.getOperands()) {
        args.push_back(getValue(procId, arg));
        callOperands.push_back(arg);
      }

      constexpr size_t maxCallDepth = 200;
      if (state.callDepth >= maxCallDepth) {
        for (Value result : callOp.getResults()) {
          setValue(procId, result,
                   InterpretedValue::makeX(getTypeWidth(result.getType())));
        }
        return success();
      }

      ++state.callDepth;
      SmallVector<InterpretedValue, 2> results;
      LogicalResult funcResult =
          interpretFuncBody(procId, mlirFuncOp, args, results,
                            callOp.getOperation());
      --state.callDepth;

      if (failed(funcResult))
        return failure();

      if (state.waiting)
        return success();

      for (auto [result, retVal] : llvm::zip(callOp.getResults(), results)) {
        setValue(procId, result, retVal);
      }
      return success();
    }
    if (cached.kind == 2) {
      // Cached as not found
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: function '" << calleeName
                              << "' not found (cached)\n");
      for (Value result : callOp.getResults()) {
        setValue(procId, result,
                 InterpretedValue::makeX(getTypeWidth(result.getType())));
      }
      return success();
    }
    // kind == 0: cached as LLVM::LLVMFuncOp, fall through to handle below
  }

  // Cache miss or LLVM func - do the full lookup
  Operation *parent = state.processOrInitialOp;
  while (parent && !isa<ModuleOp>(parent))
    parent = parent->getParentOp();

  if (!parent && rootModule)
    parent = rootModule.getOperation();

  if (!parent) {
    LLVM_DEBUG(llvm::dbgs() << "  llvm.call: could not find module\n");
    for (Value result : callOp.getResults()) {
      setValue(procId, result,
               InterpretedValue::makeX(getTypeWidth(result.getType())));
    }
    return success();
  }

  auto moduleOp = cast<ModuleOp>(parent);
  LLVM::LLVMFuncOp funcOp;

  // Check cache for LLVM func
  if (cacheIt != funcLookupCache.end() && cacheIt->second.kind == 0) {
    funcOp = cast<LLVM::LLVMFuncOp>(cacheIt->second.op);
  } else {
    funcOp = moduleOp.lookupSymbol<LLVM::LLVMFuncOp>(calleeName);
  }

  if (!funcOp) {
    // Fallback: try looking up as func::FuncOp
    auto mlirFuncOp = moduleOp.lookupSymbol<func::FuncOp>(calleeName);
    if (mlirFuncOp) {
      // Cache the result
      funcLookupCache[calleeName] = {mlirFuncOp.getOperation(), 1};

      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: resolved '" << calleeName
                              << "' as func.func (cross-dialect call)\n");

      // DPI function interception: if the func has no body, try to intercept
      // it as a known DPI function (uvm_re_*, uvm_hdl_*, uvm_dpi_*).
      if (mlirFuncOp.getBody().empty()) {
        if (succeeded(interceptDPIFunc(procId, calleeName, callOp)))
          return success();
        // Not a known DPI function - return X for all results
        for (Value result : callOp.getResults())
          setValue(procId, result,
                   InterpretedValue::makeX(getTypeWidth(result.getType())));
        return success();
      }

      SmallVector<InterpretedValue, 4> args;
      SmallVector<Value, 4> callOperands;
      for (Value arg : callOp.getOperands()) {
        args.push_back(getValue(procId, arg));
        callOperands.push_back(arg);
      }

      constexpr size_t maxCallDepth = 200;
      if (state.callDepth >= maxCallDepth) {
        for (Value result : callOp.getResults()) {
          setValue(procId, result,
                   InterpretedValue::makeX(getTypeWidth(result.getType())));
        }
        return success();
      }

      ++state.callDepth;
      SmallVector<InterpretedValue, 2> results;
      LogicalResult funcResult =
          interpretFuncBody(procId, mlirFuncOp, args, results,
                            callOp.getOperation());
      --state.callDepth;

      if (failed(funcResult))
        return failure();

      if (state.waiting)
        return success();

      for (auto [result, retVal] : llvm::zip(callOp.getResults(), results)) {
        setValue(procId, result, retVal);
      }
      return success();
    }

    // Cache negative result
    funcLookupCache[calleeName] = {nullptr, 2};

    LLVM_DEBUG(llvm::dbgs() << "  llvm.call: function '" << calleeName
                            << "' not found as llvm.func or func.func\n");
    for (Value result : callOp.getResults()) {
      setValue(procId, result,
               InterpretedValue::makeX(getTypeWidth(result.getType())));
    }
    return success();
  }

  // Cache the LLVM func lookup
  if (cacheIt == funcLookupCache.end()) {
    funcLookupCache[calleeName] = {funcOp.getOperation(), 0};
  }

  // Check if function has a body
  if (funcOp.isExternal()) {
    // Fast-path: skip the 128-entry interceptor chain for external functions
    // that we've already determined have no matching handler.
    if (nonInterceptedExternals.contains(funcOp.getOperation())) {
      for (Value result : callOp.getResults())
        setValue(procId, result,
                 InterpretedValue::makeX(getTypeWidth(result.getType())));
      return success();
    }

    // Most frequently called interceptor first: __moore_delay is called once
    // per delta cycle (~4M times in a typical simulation).
    if (calleeName == "__moore_delay") {
      if (callOp.getNumOperands() >= 1) {
        InterpretedValue delayArg = getValue(procId, callOp.getOperand(0));
        int64_t delayFs =
            delayArg.isX() ? 0 : static_cast<int64_t>(delayArg.getUInt64());

        if (delayFs > 0) {
          auto &delayState = processStates[procId];
          delayState.pendingDelayFs += delayFs;

          LLVM_DEBUG(llvm::dbgs()
                     << "  llvm.call: __moore_delay(" << delayFs
                     << " fs) accumulated, total pending = "
                     << delayState.pendingDelayFs << " fs\n");

          delayState.waiting = true;
        } else {
          LLVM_DEBUG(llvm::dbgs()
                     << "  llvm.call: __moore_delay(0) - no delay\n");
        }
      }
      return success();
    }

    // Handle known runtime library functions
    if (calleeName == "__moore_packed_string_to_string") {
      // Get the integer argument (packed string value)
      if (callOp.getNumOperands() >= 1) {
        InterpretedValue arg = getValue(procId, callOp.getOperand(0));
        int64_t value = static_cast<int64_t>(arg.getUInt64());

        // Call the actual runtime function
        MooreString result = __moore_packed_string_to_string(value);

        // Store the result as a struct {ptr, len}
        // For the interpreter, we need to track this specially
        // The result type is !llvm.struct<(ptr, i64)>
        // We'll store the string content directly and return a special marker
        if (callOp.getNumResults() >= 1) {
          // Create a unique ID for this dynamic string
          // We use the pointer value as the ID
          auto ptrVal = reinterpret_cast<int64_t>(result.data);
          auto lenVal = result.len;

          // Store in the dynamic string registry for later retrieval
          dynamicStrings[ptrVal] = {result.data, result.len};

          // For struct result, we pack ptr (lower 64 bits) and len (upper 64)
          // But since struct interpretation is complex, we use a simpler approach:
          // Store the packed value and handle it specially in FormatDynStringOp
          APInt packedResult(128, 0);
          safeInsertBits(packedResult,APInt(64, ptrVal), 0);
          safeInsertBits(packedResult,APInt(64, lenVal), 64);
          setValue(procId, callOp.getResult(),
                   InterpretedValue(packedResult));

          LLVM_DEBUG(llvm::dbgs()
                     << "  llvm.call: __moore_packed_string_to_string("
                     << value << ") = \"";
                     if (result.data && result.len > 0)
                       llvm::dbgs().write(result.data, result.len);
                     llvm::dbgs() << "\"\n");
        }
      }
      return success();
    }

    // Handle string comparison - crucial for UVM factory registration
    if (calleeName == "__moore_string_cmp") {
      // Signature: __moore_string_cmp(ptr to struct{ptr,i64}, ptr to struct{ptr,i64}) -> i32
      // The arguments are pointers to MooreString structs in memory
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        InterpretedValue lhsPtrVal = getValue(procId, callOp.getOperand(0));
        InterpretedValue rhsPtrVal = getValue(procId, callOp.getOperand(1));

        // Helper to extract string data from a pointer to {ptr, i64} struct
        auto extractString = [&](uint64_t structAddr) -> std::pair<const char*, int64_t> {
          // Load the struct from memory - it's 16 bytes: {ptr (8 bytes), len (8 bytes)}
          uint64_t blockOffset = 0;
          MemoryBlock *block = findMemoryBlockByAddress(structAddr, procId, &blockOffset);

          if (block && block->size >= blockOffset + 16) {
            // Extract ptr (first 8 bytes) and len (next 8 bytes)
            uint64_t dataPtr = 0;
            int64_t len = 0;
            for (int i = 0; i < 8; i++) {
              dataPtr |= (static_cast<uint64_t>(block->data[blockOffset + i]) << (i * 8));
              len |= (static_cast<int64_t>(block->data[blockOffset + 8 + i]) << (i * 8));
            }

            // Empty string case (ptr=0, len=0)
            if (dataPtr == 0 || len <= 0) {
              return {nullptr, 0};
            }

            // Look up the actual string data from dynamicStrings registry
            auto dynIt = dynamicStrings.find(static_cast<int64_t>(dataPtr));
            if (dynIt != dynamicStrings.end()) {
              return {dynIt->second.first, std::min(len, static_cast<int64_t>(dynIt->second.second))};
            }

            // Try to find in global memory (for string literals)
            uint64_t strOffset = 0;
            MemoryBlock *strBlock = findMemoryBlockByAddress(dataPtr, procId, &strOffset);
            if (strBlock && strBlock->size >= strOffset + len) {
              return {reinterpret_cast<const char*>(strBlock->data.data() + strOffset), len};
            }
          }
          return {nullptr, -1};  // Error case
        };

        // Handle X (uninitialized) pointer values - don't crash on garbage addresses
        if (lhsPtrVal.isX() || rhsPtrVal.isX()) {
          // Result is indeterminate (X) if either input is X, but we return 0 for safety
          setValue(procId, callOp.getResult(), InterpretedValue(APInt(32, 0, true)));
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_cmp() - X input, returning 0\n");
          return success();
        }

        auto [lhsData, lhsLen] = extractString(lhsPtrVal.getUInt64());
        auto [rhsData, rhsLen] = extractString(rhsPtrVal.getUInt64());

        // Perform comparison
        int32_t result = 0;
        bool lhsEmpty = (lhsData == nullptr || lhsLen <= 0);
        bool rhsEmpty = (rhsData == nullptr || rhsLen <= 0);

        if (lhsEmpty && rhsEmpty) {
          result = 0;  // Both empty, equal
        } else if (lhsEmpty) {
          result = -1;  // LHS empty, RHS not
        } else if (rhsEmpty) {
          result = 1;  // LHS not empty, RHS empty
        } else {
          // Both have data, compare lexicographically
          size_t minLen = std::min(static_cast<size_t>(lhsLen), static_cast<size_t>(rhsLen));
          result = std::memcmp(lhsData, rhsData, minLen);
          if (result == 0 && lhsLen != rhsLen) {
            result = (lhsLen < rhsLen) ? -1 : 1;
          }
        }

        setValue(procId, callOp.getResult(), InterpretedValue(APInt(32, result, true)));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_cmp(\"";
                   if (lhsData && lhsLen > 0) llvm::dbgs().write(lhsData, lhsLen);
                   llvm::dbgs() << "\", \"";
                   if (rhsData && rhsLen > 0) llvm::dbgs().write(rhsData, rhsLen);
                   llvm::dbgs() << "\") = " << result << "\n");
      }
      return success();
    }

    // Handle string length
    if (calleeName == "__moore_string_len") {
      // Signature: __moore_string_len(ptr to struct{ptr,i64}) -> i32
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        InterpretedValue ptrVal = getValue(procId, callOp.getOperand(0));

        // Handle X (uninitialized) pointer values
        if (ptrVal.isX()) {
          setValue(procId, callOp.getResult(), InterpretedValue(APInt(32, 0, true)));
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_len() - X input, returning 0\n");
          return success();
        }

        uint64_t structAddr = ptrVal.getUInt64();

        // Load the struct from memory
        uint64_t blockOffset = 0;
        MemoryBlock *block = findMemoryBlockByAddress(structAddr, procId, &blockOffset);
        int32_t len = 0;

        if (block && block->size >= blockOffset + 16) {
          // Extract len (bytes 8-15)
          int64_t rawLen = 0;
          for (int i = 0; i < 8; i++) {
            rawLen |= (static_cast<int64_t>(block->data[blockOffset + 8 + i]) << (i * 8));
          }
          len = static_cast<int32_t>(rawLen);
        }

        setValue(procId, callOp.getResult(), InterpretedValue(APInt(32, len, true)));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_len() = " << len << "\n");
      }
      return success();
    }

    // Handle malloc - dynamic memory allocation for class instances
    if (calleeName == "malloc") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        InterpretedValue sizeArg = getValue(procId, callOp.getOperand(0));
        uint64_t size = sizeArg.isX() ? 256 : sizeArg.getUInt64();  // Default size if X

        // Use global address counter to avoid overlap between processes.
        // Each process has its own nextMemoryAddress for allocas, but malloc
        // blocks are stored globally in mallocBlocks, so we need a global counter.
        uint64_t addr = globalNextAddress;
        globalNextAddress += size;

        // Create a memory block for this allocation
        MemoryBlock block(size, 64);
        block.initialized = true;  // Mark as initialized with zeros
        std::fill(block.data.begin(), block.data.end(), 0);

        // Store the block - use the address as a key
        // We need to track malloc'd blocks separately so findMemoryBlock can find them
        mallocBlocks[addr] = std::move(block);
        addrRangeIndexDirty = true;

        setValue(procId, callOp.getResult(), InterpretedValue(addr, 64));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: malloc(" << size
                                << ") = 0x" << llvm::format_hex(addr, 16) << "\n");
      }
      return success();
    }

    // Helper lambda to resolve a pointer address to string data from global memory.
    // Returns a StringRef to the string content, or empty StringRef if not found.
    auto resolvePointerToString = [&](uint64_t addr, int64_t len) -> std::string {
      if (addr == 0 || len <= 0)
        return "";

      // First check dynamicStrings registry - these are actual C pointers from runtime
      auto dynIt = dynamicStrings.find(static_cast<int64_t>(addr));
      if (dynIt != dynamicStrings.end() && dynIt->second.first && dynIt->second.second > 0) {
        size_t effectiveLen = std::min(static_cast<size_t>(len), static_cast<size_t>(dynIt->second.second));
        return std::string(dynIt->second.first, effectiveLen);
      }
      // Search via O(log n) range index (globals + malloc blocks)
      {
        uint64_t offset = 0;
        MemoryBlock *blk = findBlockByAddress(addr, offset);
        if (blk) {
          size_t availableLen = std::min(static_cast<size_t>(len),
                                         blk->data.size() - static_cast<size_t>(offset));
          if (availableLen > 0) {
            return std::string(reinterpret_cast<const char*>(blk->data.data() + offset),
                               availableLen);
          }
        }
      }

      return "";
    };

    // Handle UVM report functions - intercept both runtime calls (__moore_uvm_report_*)
    // and unconverted UVM package calls (uvm_pkg::uvm_report_*)
    if (calleeName == "__moore_uvm_report_info" ||
        calleeName == "__moore_uvm_report_warning" ||
        calleeName == "__moore_uvm_report_error" ||
        calleeName == "__moore_uvm_report_fatal") {
      // Signature: (id, idLen, message, messageLen, verbosity, filename, filenameLen, line, context, contextLen)
      if (callOp.getNumOperands() >= 10) {
        // Extract arguments
        uint64_t idPtr = getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t idLen = static_cast<int64_t>(getValue(procId, callOp.getOperand(1)).getUInt64());
        uint64_t msgPtr = getValue(procId, callOp.getOperand(2)).getUInt64();
        int64_t msgLen = static_cast<int64_t>(getValue(procId, callOp.getOperand(3)).getUInt64());
        int32_t verbosity = static_cast<int32_t>(getValue(procId, callOp.getOperand(4)).getUInt64());
        uint64_t filePtr = getValue(procId, callOp.getOperand(5)).getUInt64();
        int64_t fileLen = static_cast<int64_t>(getValue(procId, callOp.getOperand(6)).getUInt64());
        int32_t line = static_cast<int32_t>(getValue(procId, callOp.getOperand(7)).getUInt64());
        uint64_t ctxPtr = getValue(procId, callOp.getOperand(8)).getUInt64();
        int64_t ctxLen = static_cast<int64_t>(getValue(procId, callOp.getOperand(9)).getUInt64());

        // Resolve strings from memory
        std::string idStr = resolvePointerToString(idPtr, idLen);
        std::string msgStr = resolvePointerToString(msgPtr, msgLen);
        std::string fileStr = resolvePointerToString(filePtr, fileLen);
        std::string ctxStr = resolvePointerToString(ctxPtr, ctxLen);

        // UVM emits very high-volume component-name warnings during hierarchy
        // traversal. Keep this specific warning ID silent to avoid spending
        // most simulation wall time in report formatting/printing at time 0.
        bool suppressCompNameWarning =
            (calleeName == "__moore_uvm_report_warning" &&
             idStr == "UVM/COMP/NAME");
        if (suppressCompNameWarning) {
          LLVM_DEBUG(llvm::dbgs()
                     << "  llvm.call: suppressed UVM/COMP/NAME warning\n");
          return success();
        }

        // Call the appropriate runtime function
        if (calleeName == "__moore_uvm_report_info") {
          __moore_uvm_report_info(idStr.c_str(), idStr.size(),
                                  msgStr.c_str(), msgStr.size(),
                                  verbosity, fileStr.c_str(), fileStr.size(),
                                  line, ctxStr.c_str(), ctxStr.size());
        } else if (calleeName == "__moore_uvm_report_warning") {
          __moore_uvm_report_warning(idStr.c_str(), idStr.size(),
                                     msgStr.c_str(), msgStr.size(),
                                     verbosity, fileStr.c_str(), fileStr.size(),
                                     line, ctxStr.c_str(), ctxStr.size());
        } else if (calleeName == "__moore_uvm_report_error") {
          __moore_uvm_report_error(idStr.c_str(), idStr.size(),
                                   msgStr.c_str(), msgStr.size(),
                                   verbosity, fileStr.c_str(), fileStr.size(),
                                   line, ctxStr.c_str(), ctxStr.size());
        } else if (calleeName == "__moore_uvm_report_fatal") {
          __moore_uvm_report_fatal(idStr.c_str(), idStr.size(),
                                   msgStr.c_str(), msgStr.size(),
                                   verbosity, fileStr.c_str(), fileStr.size(),
                                   line, ctxStr.c_str(), ctxStr.size());
        }

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: " << calleeName
                                << "(id=\"" << idStr << "\", msg=\"" << msgStr << "\")\n");
      }
      return success();
    }

    // Handle unconverted UVM report calls with LLVM struct string arguments
    // Signature: (id_struct, msg_struct, verbosity, filename_struct, line, context_struct, report_enabled_checked)
    // where *_struct is {ptr, i64}
    // Note: The struct values are tracked internally by the interpreter during llvm.call handling.
    // When we encounter uvm_report calls, we look up the struct values in our value map
    // and extract the ptr/len fields that were stored there.
    if (calleeName == "uvm_pkg::uvm_report_info" ||
        calleeName == "uvm_pkg::uvm_report_warning" ||
        calleeName == "uvm_pkg::uvm_report_error" ||
        calleeName == "uvm_pkg::uvm_report_fatal") {
      if (callOp.getNumOperands() >= 7) {
        // For now, print a placeholder message to indicate we intercepted the call
        // Full struct field extraction requires tracking aggregate values in the interpreter
        llvm::outs() << "UVM_INFO <intercepted> @ "
                     << scheduler.getCurrentTime().realTime << " fs: "
                     << "[" << calleeName << " call intercepted - struct args not yet extracted]\n";

        LLVM_DEBUG(llvm::dbgs() << "  func.call: " << calleeName
                                << " intercepted (7 args, struct extraction pending)\n");
      }
      return success();
    }

    // Handle __moore_uvm_report_enabled
    if (calleeName == "__moore_uvm_report_enabled") {
      // Signature: (verbosity, severity, id, idLen) -> int32_t
      if (callOp.getNumOperands() >= 4) {
        int32_t verbosity = static_cast<int32_t>(getValue(procId, callOp.getOperand(0)).getUInt64());
        int32_t severity = static_cast<int32_t>(getValue(procId, callOp.getOperand(1)).getUInt64());
        uint64_t idPtr = getValue(procId, callOp.getOperand(2)).getUInt64();
        int64_t idLen = static_cast<int64_t>(getValue(procId, callOp.getOperand(3)).getUInt64());

        std::string idStr = resolvePointerToString(idPtr, idLen);
        int32_t result = __moore_uvm_report_enabled(verbosity, severity,
                                                     idStr.c_str(), idStr.size());

        if (callOp.getNumResults() >= 1) {
          setValue(procId, callOp.getResult(), InterpretedValue(result, 32));
        }

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_uvm_report_enabled("
                                << verbosity << ", " << severity << ", \"" << idStr
                                << "\") = " << result << "\n");
      }
      return success();
    }

    // Handle __moore_uvm_report_summarize
    if (calleeName == "__moore_uvm_report_summarize") {
      __moore_uvm_report_summarize();
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_uvm_report_summarize()\n");
      return success();
    }

    // Handle UVM root re-entrancy runtime functions
    if (calleeName == "__moore_uvm_root_constructing_start") {
      __moore_uvm_root_constructing_start();
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_uvm_root_constructing_start()\n");
      return success();
    }

    if (calleeName == "__moore_uvm_root_constructing_end") {
      __moore_uvm_root_constructing_end();
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_uvm_root_constructing_end()\n");
      return success();
    }

    if (calleeName == "__moore_uvm_is_root_constructing") {
      bool result = __moore_uvm_is_root_constructing();
      if (callOp.getNumResults() >= 1) {
        setValue(procId, callOp.getResult(), InterpretedValue(result ? 1ULL : 0ULL, 1));
      }
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_uvm_is_root_constructing() = "
                              << (result ? "true" : "false") << "\n");
      return success();
    }

    if (calleeName == "__moore_uvm_set_root_inst") {
      if (callOp.getNumOperands() >= 1) {
        uint64_t inst = getValue(procId, callOp.getOperand(0)).getUInt64();
        __moore_uvm_set_root_inst(reinterpret_cast<void *>(inst));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_uvm_set_root_inst(0x"
                                << llvm::format_hex(inst, 16) << ")\n");
      }
      return success();
    }

    if (calleeName == "__moore_uvm_get_root_inst") {
      void *inst = __moore_uvm_get_root_inst();
      if (callOp.getNumResults() >= 1) {
        setValue(procId, callOp.getResult(),
                 InterpretedValue(reinterpret_cast<uint64_t>(inst), 64));
      }
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_uvm_get_root_inst() = 0x"
                              << llvm::format_hex(reinterpret_cast<uint64_t>(inst), 16) << "\n");
      return success();
    }

    // Coverage collection - delegates to MooreRuntime library functions.
    // Helper: read a C-string (null-terminated) from a pointer value.
    auto readCStringFromPtr = [&](Value operand) -> const char * {
      InterpretedValue ptrArg = getValue(procId, operand);
      if (ptrArg.isX())
        return "";
      uint64_t ptrVal = ptrArg.getUInt64();
      if (ptrVal == 0)
        return "";
      // Try global string constant lookup
      auto globalIt = addressToGlobal.find(ptrVal);
      if (globalIt != addressToGlobal.end()) {
        auto blockIt = globalMemoryBlocks.find(globalIt->second);
        if (blockIt != globalMemoryBlocks.end() && blockIt->second.initialized)
          return reinterpret_cast<const char *>(blockIt->second.data.data());
      }
      // Try interpreter memory
      uint64_t off = 0;
      MemoryBlock *block = findBlockByAddress(ptrVal, off);
      if (block && block->initialized)
        return reinterpret_cast<const char *>(block->data.data() + off);
      return "";
    };

    if (calleeName == "__moore_covergroup_create") {
      const char *name = readCStringFromPtr(callOp.getOperand(0));
      int32_t numCp = static_cast<int32_t>(
          getValue(procId, callOp.getOperand(1)).getUInt64());
      void *cg = __moore_covergroup_create(name, numCp);
      if (callOp.getNumResults() >= 1) {
        setValue(procId, callOp.getResult(),
                InterpretedValue(reinterpret_cast<uint64_t>(cg), 64));
      }
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_covergroup_create(\""
                               << name << "\", " << numCp << ") -> "
                               << cg << "\n");
      return success();
    }

    if (calleeName == "__moore_covergroup_get_coverage") {
      uint64_t cgAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
      void *cg = reinterpret_cast<void *>(cgAddr);
      double coverage = __moore_covergroup_get_coverage(cg);
      if (callOp.getNumResults() >= 1) {
        uint64_t bits;
        std::memcpy(&bits, &coverage, sizeof(bits));
        setValue(procId, callOp.getResult(), InterpretedValue(bits, 64));
      }
      LLVM_DEBUG(llvm::dbgs()
                 << "  llvm.call: __moore_covergroup_get_coverage("
                 << cg << ") -> " << coverage << "%\n");
      return success();
    }

    if (calleeName == "__moore_coverpoint_init") {
      uint64_t cgAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
      void *cg = reinterpret_cast<void *>(cgAddr);
      int32_t cpIdx = static_cast<int32_t>(
          getValue(procId, callOp.getOperand(1)).getUInt64());
      const char *name = readCStringFromPtr(callOp.getOperand(2));
      __moore_coverpoint_init(cg, cpIdx, name);
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_coverpoint_init("
                               << cg << ", " << cpIdx << ", \""
                               << name << "\")\n");
      return success();
    }

    if (calleeName == "__moore_coverpoint_sample") {
      uint64_t cgAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
      void *cg = reinterpret_cast<void *>(cgAddr);
      int32_t cpIdx = static_cast<int32_t>(
          getValue(procId, callOp.getOperand(1)).getUInt64());
      int64_t value = static_cast<int64_t>(
          getValue(procId, callOp.getOperand(2)).getUInt64());
      __moore_coverpoint_sample(cg, cpIdx, value);
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_coverpoint_sample("
                               << cg << ", " << cpIdx << ", "
                               << value << ")\n");
      return success();
    }

    if (calleeName == "__moore_coverpoint_add_ignore_bin") {
      uint64_t cgAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
      void *cg = reinterpret_cast<void *>(cgAddr);
      int32_t cpIdx = static_cast<int32_t>(
          getValue(procId, callOp.getOperand(1)).getUInt64());
      const char *name = readCStringFromPtr(callOp.getOperand(2));
      int64_t lo = static_cast<int64_t>(
          getValue(procId, callOp.getOperand(3)).getUInt64());
      int64_t hi = static_cast<int64_t>(
          getValue(procId, callOp.getOperand(4)).getUInt64());
      __moore_coverpoint_add_ignore_bin(cg, cpIdx, name, lo, hi);
      LLVM_DEBUG(llvm::dbgs()
                 << "  llvm.call: __moore_coverpoint_add_ignore_bin("
                 << cg << ", " << cpIdx << ", \"" << name << "\", "
                 << lo << ", " << hi << ")\n");
      return success();
    }

    if (calleeName == "__moore_coverpoint_add_illegal_bin") {
      uint64_t cgAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
      void *cg = reinterpret_cast<void *>(cgAddr);
      int32_t cpIdx = static_cast<int32_t>(
          getValue(procId, callOp.getOperand(1)).getUInt64());
      const char *name = readCStringFromPtr(callOp.getOperand(2));
      int64_t lo = static_cast<int64_t>(
          getValue(procId, callOp.getOperand(3)).getUInt64());
      int64_t hi = static_cast<int64_t>(
          getValue(procId, callOp.getOperand(4)).getUInt64());
      __moore_coverpoint_add_illegal_bin(cg, cpIdx, name, lo, hi);
      LLVM_DEBUG(llvm::dbgs()
                 << "  llvm.call: __moore_coverpoint_add_illegal_bin("
                 << cg << ", " << cpIdx << ", \"" << name << "\", "
                 << lo << ", " << hi << ")\n");
      return success();
    }

    if (calleeName == "__moore_coverage_set_test_name") {
      const char *name = readCStringFromPtr(callOp.getOperand(0));
      __moore_coverage_set_test_name(name);
      LLVM_DEBUG(llvm::dbgs()
                 << "  llvm.call: __moore_coverage_set_test_name(\""
                 << name << "\")\n");
      return success();
    }

    if (calleeName == "__moore_coverage_load_db") {
      // Return null handle (DB features not yet needed for basic coverage).
      if (callOp.getNumResults() >= 1)
        setValue(procId, callOp.getResult(), InterpretedValue(0ULL, 64));
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_coverage_load_db() -> 0 (stub)\n");
      return success();
    }

    if (calleeName == "__moore_coverage_merge_db") {
      if (callOp.getNumResults() >= 1)
        setValue(procId, callOp.getResult(), InterpretedValue(0ULL, 32));
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_coverage_merge_db() -> 0 (stub)\n");
      return success();
    }

    if (calleeName == "__moore_coverage_save_db") {
      if (callOp.getNumResults() >= 1)
        setValue(procId, callOp.getResult(), InterpretedValue(0ULL, 32));
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_coverage_save_db() -> 0 (stub)\n");
      return success();
    }

    if (calleeName == "__moore_coverage_load") {
      if (callOp.getNumResults() >= 1)
        setValue(procId, callOp.getResult(), InterpretedValue(0ULL, 64));
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_coverage_load() -> 0 (stub)\n");
      return success();
    }

    if (calleeName == "__moore_coverage_merge") {
      if (callOp.getNumResults() >= 1)
        setValue(procId, callOp.getResult(), InterpretedValue(0ULL, 32));
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_coverage_merge() -> 0 (stub)\n");
      return success();
    }

    // Handle __moore_process_self - get current process handle.
    // Implements the SystemVerilog `process::self()` static method.
    // IEEE 1800-2017 Section 9.7 "Process control"
    // Returns a non-null handle when called from within a process context
    // (llhd.process, initial block, always block, fork branch), or null
    // when called from outside a process context.
    if (calleeName == "__moore_process_self") {
      // We're being called from within the interpreter's process execution,
      // which means we're definitely inside a process context.
      // Return a non-null pointer - we use the process state address as
      // a unique identifier for the process handle.
      auto &state = processStates[procId];
      void *processHandle = &state;

      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_process_self() = 0x"
                              << llvm::format_hex(reinterpret_cast<uint64_t>(processHandle), 16)
                              << " (inside process context)\n");

      // Set the result to the process handle pointer value
      if (callOp.getNumResults() >= 1) {
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(64, reinterpret_cast<uint64_t>(processHandle))));
      }
      return success();
    }

    // Handle __moore_process_status - query process state.
    // Implements SystemVerilog process::status().
    if (calleeName == "__moore_process_status") {
      uint32_t status = 0; // FINISHED
      if (callOp.getNumOperands() >= 1) {
        InterpretedValue handleVal = getValue(procId, callOp.getOperand(0));
        if (!handleVal.isX()) {
          ProcessId targetId = resolveProcessHandle(handleVal.getUInt64());
          if (targetId != InvalidProcessId) {
            bool killed = false;
            auto stateIt = processStates.find(targetId);
            if (stateIt != processStates.end())
              killed = stateIt->second.killed;

            if (killed) {
              status = 4; // KILLED
            } else if (auto *proc = scheduler.getProcess(targetId)) {
              switch (proc->getState()) {
              case ProcessState::Waiting:
                status = 2; // WAITING
                break;
              case ProcessState::Suspended:
                status = 3; // SUSPENDED
                break;
              case ProcessState::Terminated:
                status = 0; // FINISHED
                break;
              default:
                status = 1; // RUNNING (Ready/Running/Uninitialized)
                break;
              }
            } else {
              status = 0;
            }
          }
        }
      }

      if (callOp.getNumResults() >= 1) {
        Value result = callOp.getResult();
        unsigned width = getTypeWidth(result.getType());
        setValue(procId, result, InterpretedValue(APInt(width, status)));
      }
      return success();
    }

    // Handle __moore_process_get_randstate - serialize process RNG state.
    // Implements SystemVerilog process::get_randstate().
    if (calleeName == "__moore_process_get_randstate") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        InterpretedValue handleVal = getValue(procId, callOp.getOperand(0));
        std::string stateStr;

        if (!handleVal.isX()) {
          ProcessId targetId = resolveProcessHandle(handleVal.getUInt64());
          if (targetId != InvalidProcessId) {
            auto it = processStates.find(targetId);
            if (it != processStates.end()) {
              std::ostringstream oss;
              oss << it->second.randomGenerator;
              stateStr = oss.str();
            }
          }
        }

        int64_t ptrVal = 0;
        int64_t lenVal = 0;
        if (!stateStr.empty()) {
          interpreterStrings.push_back(std::move(stateStr));
          const std::string &stored = interpreterStrings.back();
          ptrVal = reinterpret_cast<int64_t>(stored.data());
          lenVal = static_cast<int64_t>(stored.size());
          dynamicStrings[ptrVal] = {stored.data(), lenVal};
        }

        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, static_cast<uint64_t>(ptrVal)), 0);
        safeInsertBits(packedResult,APInt(64, static_cast<uint64_t>(lenVal)), 64);
        setValue(procId, callOp.getResult(), InterpretedValue(packedResult));

        LLVM_DEBUG({
          llvm::dbgs() << "  llvm.call: __moore_process_get_randstate(";
          if (handleVal.isX())
            llvm::dbgs() << "X";
          else
            llvm::dbgs() << llvm::format_hex(handleVal.getUInt64(), 16);
          llvm::dbgs() << ") len=" << lenVal << "\n";
        });
      }
      return success();
    }

    // Handle __moore_process_set_randstate - restore process RNG state.
    // Implements SystemVerilog process::set_randstate().
    if (calleeName == "__moore_process_set_randstate") {
      if (callOp.getNumOperands() >= 2) {
        InterpretedValue handleVal = getValue(procId, callOp.getOperand(0));
        InterpretedValue stateVal = getValue(procId, callOp.getOperand(1));

        if (!handleVal.isX() && !stateVal.isX()) {
          ProcessId targetId = resolveProcessHandle(handleVal.getUInt64());
          if (targetId != InvalidProcessId) {
            auto it = processStates.find(targetId);
            if (it != processStates.end()) {
              APInt bits = stateVal.getAPInt();
              uint64_t ptrVal =
                  bits.extractBits(64, 0).getZExtValue();
              uint64_t lenVal =
                  bits.extractBits(64, 64).getZExtValue();

              std::string stateStr =
                  resolvePointerToString(ptrVal, static_cast<int64_t>(lenVal));

              if (!stateStr.empty()) {
                std::istringstream iss(stateStr);
                iss >> it->second.randomGenerator;
              }
            }
          }
        }
      }
      return success();
    }

    // Handle __moore_process_srandom - seed the process RNG.
    // Implements SystemVerilog process::srandom().
    if (calleeName == "__moore_process_srandom") {
      if (callOp.getNumOperands() >= 2) {
        InterpretedValue handleVal = getValue(procId, callOp.getOperand(0));
        InterpretedValue seedVal = getValue(procId, callOp.getOperand(1));

        if (!handleVal.isX() && !seedVal.isX()) {
          ProcessId targetId = resolveProcessHandle(handleVal.getUInt64());
          if (targetId != InvalidProcessId) {
            auto it = processStates.find(targetId);
            if (it != processStates.end()) {
              it->second.randomGenerator.seed(
                  static_cast<uint32_t>(seedVal.getUInt64()));
            }
          }
        }
      }
      return success();
    }

    // Handle __moore_class_srandom - seed the per-object RNG.
    // Implements SystemVerilog obj.srandom(seed) (IEEE 1800-2017 §18.13.3).
    // Signature: (objPtr: ptr, seed: i32) -> void
    if (calleeName == "__moore_class_srandom") {
      if (callOp.getNumOperands() >= 2) {
        uint64_t objAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        uint32_t seed = static_cast<uint32_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        // Create or reseed the per-object RNG
        perObjectRng[objAddr] = std::mt19937(seed);
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_class_srandom(0x"
                   << llvm::format_hex(objAddr, 16)
                   << ", seed=" << seed << ")\n");
      }
      return success();
    }

    // Handle __moore_class_get_randstate - serialize per-object RNG state.
    // Implements SystemVerilog obj.get_randstate() (IEEE 1800-2017 §18.13).
    // Signature: (objPtr: ptr) -> !llvm.struct<(ptr, i64)>
    if (calleeName == "__moore_class_get_randstate") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        uint64_t objAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();

        std::string stateStr;
        auto &rng = getObjectRng(objAddr);
        std::ostringstream oss;
        oss << rng;
        stateStr = oss.str();

        int64_t ptrVal = 0;
        int64_t lenVal = 0;
        if (!stateStr.empty()) {
          interpreterStrings.push_back(std::move(stateStr));
          const std::string &stored = interpreterStrings.back();
          ptrVal = reinterpret_cast<int64_t>(stored.data());
          lenVal = static_cast<int64_t>(stored.size());
          dynamicStrings[ptrVal] = {stored.data(), lenVal};
        }

        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, static_cast<uint64_t>(ptrVal)), 0);
        safeInsertBits(packedResult,APInt(64, static_cast<uint64_t>(lenVal)), 64);
        setValue(procId, callOp.getResult(), InterpretedValue(packedResult));

        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_class_get_randstate(0x"
                   << llvm::format_hex(objAddr, 16)
                   << ") len=" << lenVal << "\n");
      }
      return success();
    }

    // Handle __moore_class_set_randstate - restore per-object RNG state.
    // Implements SystemVerilog obj.set_randstate(state) (IEEE 1800-2017 §18.13).
    // Signature: (objPtr: ptr, stateStruct: !llvm.struct<(ptr, i64)>) -> void
    if (calleeName == "__moore_class_set_randstate") {
      if (callOp.getNumOperands() >= 2) {
        uint64_t objAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        InterpretedValue stateVal = getValue(procId, callOp.getOperand(1));

        if (!stateVal.isX()) {
          APInt bits = stateVal.getAPInt();
          uint64_t ptrVal = bits.extractBits(64, 0).getZExtValue();
          uint64_t lenVal = bits.extractBits(64, 64).getZExtValue();

          std::string stateStr =
              resolvePointerToString(ptrVal, static_cast<int64_t>(lenVal));

          if (!stateStr.empty()) {
            std::istringstream iss(stateStr);
            auto &rng = getObjectRng(objAddr);
            iss >> rng;
          }
        }

        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_class_set_randstate(0x"
                   << llvm::format_hex(objAddr, 16) << ")\n");
      }
      return success();
    }

    // Handle __moore_process_kill - terminate a process.
    // Implements SystemVerilog process::kill().
    if (calleeName == "__moore_process_kill") {
      if (callOp.getNumOperands() >= 1) {
        InterpretedValue handleVal = getValue(procId, callOp.getOperand(0));
        if (!handleVal.isX()) {
          ProcessId targetId = resolveProcessHandle(handleVal.getUInt64());
          if (targetId != InvalidProcessId) {
            finalizeProcess(targetId, /*killed=*/true);
          }
        }
      }
      return success();
    }

    // Handle __moore_process_await - wait for a process to finish or be killed.
    // Implements SystemVerilog process::await().
    if (calleeName == "__moore_process_await") {
      if (callOp.getNumOperands() >= 1) {
        InterpretedValue handleVal = getValue(procId, callOp.getOperand(0));
        if (!handleVal.isX()) {
          ProcessId targetId = resolveProcessHandle(handleVal.getUInt64());
          if (targetId != InvalidProcessId) {
            bool targetKilled = false;
            auto targetStateIt = processStates.find(targetId);
            if (targetStateIt != processStates.end())
              targetKilled = targetStateIt->second.killed;

            bool targetDone = targetKilled;
            if (!targetDone) {
              if (auto *proc = scheduler.getProcess(targetId))
                targetDone = (proc->getState() == ProcessState::Terminated);
              else
                targetDone = true;
            }

            if (!targetDone) {
              processAwaiters[targetId].push_back(procId);
              auto &state = processStates[procId];
              state.waiting = true;
              if (auto *proc = scheduler.getProcess(procId))
                proc->setState(ProcessState::Waiting);
            }
          }
        }
      }
      return success();
    }

    // Handle __moore_process_suspend - suspend a running process.
    // Implements SystemVerilog process::suspend().
    if (calleeName == "__moore_process_suspend") {
      if (callOp.getNumOperands() >= 1) {
        InterpretedValue handleVal = getValue(procId, callOp.getOperand(0));
        if (!handleVal.isX()) {
          ProcessId targetId = resolveProcessHandle(handleVal.getUInt64());
          if (targetId != InvalidProcessId) {
            if (auto *proc = scheduler.getProcess(targetId)) {
              auto curState = proc->getState();
              if (curState != ProcessState::Terminated) {
                proc->setState(ProcessState::Suspended);
                auto &state = processStates[targetId];
                state.waiting = true;
                // If suspending self, the caller will stop executing
                // after this call returns success().
              }
            }
          }
        }
      }
      return success();
    }

    // Handle __moore_process_resume - resume a suspended process.
    // Implements SystemVerilog process::resume().
    if (calleeName == "__moore_process_resume") {
      if (callOp.getNumOperands() >= 1) {
        InterpretedValue handleVal = getValue(procId, callOp.getOperand(0));
        if (!handleVal.isX()) {
          ProcessId targetId = resolveProcessHandle(handleVal.getUInt64());
          if (targetId != InvalidProcessId) {
            if (auto *proc = scheduler.getProcess(targetId)) {
              if (proc->getState() == ProcessState::Suspended) {
                resumeProcess(targetId);
              }
            }
          }
        }
      }
      return success();
    }

    // Handle __moore_wait_condition - wait until condition becomes true.
    // Implements the SystemVerilog `wait(condition)` statement.
    // Signature: __moore_wait_condition(i32 condition)
    // If condition is true (non-zero), return immediately.
    // If condition is false (zero), suspend the process and wait for signal
    // changes, then re-evaluate by restarting from the beginning of the
    // current block.
    if (calleeName == "__moore_wait_condition") {
      if (callOp.getNumOperands() >= 1) {
        InterpretedValue condArg = getValue(procId, callOp.getOperand(0));
        bool conditionTrue = !condArg.isX() && condArg.getUInt64() != 0;

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_wait_condition("
                                << (condArg.isX() ? "X" : std::to_string(condArg.getUInt64()))
                                << ") -> condition is "
                                << (conditionTrue ? "true" : "false") << "\n");

        if (conditionTrue) {
          // Condition is already true, continue immediately.
          // Clear the restart block and delta poll counter since we're done.
          auto &state = processStates[procId];
          state.waitConditionRestartBlock = nullptr;
          return success();
        }

        // Condition is false - suspend the process and set up sensitivity
        // to all probed signals so we wake up when something changes.
        auto &state = processStates[procId];

        state.waiting = true;

        // Find the operations that compute the condition value by walking
        // backwards from the condition argument. We need to invalidate these
        // cached values so they get recomputed when we re-check the condition.
        //
        // CRITICAL: We trace through operations that need re-execution:
        // - llvm.load: reads memory that may have changed
        // - llhd.prb: probes a signal that may have changed
        // - Arithmetic/comparison ops that depend on loads/probes
        //
        // We do NOT trace into:
        // - llvm.getelementptr: pointer arithmetic (doesn't read memory)
        // - Constant operations
        //
        // This avoids re-executing side-effecting operations like sim.fork.
        state.waitConditionValuesToInvalidate.clear();
        // Use the call operation's parent block as the restart block.
        // This is critical when wait_condition is called inside a function
        // (e.g., uvm_phase_hopper::get called via vtable dispatch).
        // state.currentBlock is the PROCESS body's block, but we need
        // the FUNCTION body's block where the condition is computed.
        Block *condBlock = callOp->getBlock();
        state.waitConditionRestartBlock = condBlock;

        // Find the earliest load/probe in the condition computation chain
        Value condValue = callOp.getOperand(0);
        llvm::SmallVector<Value, 16> worklist;
        llvm::SmallPtrSet<Value, 16> visited;
        worklist.push_back(condValue);

        Operation *earliestLoadOp = nullptr;

        while (!worklist.empty()) {
          Value v = worklist.pop_back_val();
          if (!visited.insert(v).second)
            continue;

          // If the value has a defining operation in this block, process it
          if (Operation *defOp = v.getDefiningOp()) {
            if (defOp->getBlock() == condBlock) {
              // Check if this is a load or probe operation - these read values that may change
              if (isa<LLVM::LoadOp, llhd::ProbeOp, LLVM::CallOp>(defOp)) {
                state.waitConditionValuesToInvalidate.push_back(v);
                // Track the earliest load/probe/call operation
                if (!earliestLoadOp || defOp->isBeforeInBlock(earliestLoadOp))
                  earliestLoadOp = defOp;
              }

              // Add operands to worklist - trace through comparison, arithmetic,
              // extraction, and load/probe ops but stop at getelementptr
              // (doesn't read memory)
              bool shouldTrace = isa<comb::ICmpOp, LLVM::ZExtOp, LLVM::SExtOp>(defOp) ||
                                 isa<LLVM::ICmpOp, LLVM::TruncOp, LLVM::BitcastOp>(defOp) ||
                                 isa<comb::AddOp, comb::SubOp, comb::AndOp>(defOp) ||
                                 isa<comb::OrOp, comb::XorOp>(defOp) ||
                                 isa<comb::ExtractOp, LLVM::ExtractValueOp>(defOp) ||
                                 isa<arith::TruncIOp, arith::ExtSIOp, arith::ExtUIOp>(defOp) ||
                                 isa<arith::CmpIOp, arith::AddIOp, arith::SubIOp>(defOp) ||
                                 isa<LLVM::LoadOp>(defOp) ||
                                 isa<llhd::ProbeOp>(defOp) ||
                                 isa<LLVM::CallOp>(defOp);
              if (shouldTrace) {
                state.waitConditionValuesToInvalidate.push_back(v);
                for (Value operand : defOp->getOperands()) {
                  if (!isa<BlockArgument>(operand) &&
                      operand.getDefiningOp() &&
                      operand.getDefiningOp()->getBlock() == condBlock) {
                    worklist.push_back(operand);
                  }
                }
              }
            }
          }
        }

        // Save the restart point - the earliest load/probe operation (or the call itself)
        if (earliestLoadOp) {
          state.waitConditionRestartOp = mlir::Block::iterator(earliestLoadOp);
        } else {
          // No loads/probes found - restart from the call itself
          state.waitConditionRestartOp = mlir::Block::iterator(&*callOp);
        }

        LLVM_DEBUG(llvm::dbgs() << "    Setting restart point for wait_condition "
                                << "re-evaluation (" << state.waitConditionValuesToInvalidate.size()
                                << " values to invalidate)\n");

        // For wait(condition), use polling to re-evaluate.
        // The condition may depend on class member variables in heap memory
        // that aren't tracked via LLHD signals.
        // Use delta steps first to keep $time == 0 during UVM initialization,
        // but fall back to real time after many delta steps to avoid infinite loops.
        SimTime currentTime = scheduler.getCurrentTime();
        constexpr uint32_t kMaxDeltaPolls = 1000;
        constexpr int64_t kFallbackPollDelayFs = 10000000; // 10 ps
        SimTime targetTime;
        if (currentTime.deltaStep < kMaxDeltaPolls) {
          targetTime = currentTime.nextDelta();
        } else {
          targetTime = currentTime.advanceTime(kFallbackPollDelayFs);
        }

        LLVM_DEBUG(llvm::dbgs() << "    Scheduling wait_condition poll (time="
                                << targetTime.realTime << " fs, delta="
                                << targetTime.deltaStep << ")\n");

        // Schedule the process to resume after the delay
        scheduler.getEventScheduler().schedule(
            targetTime, SchedulingRegion::Active,
            Event([this, procId]() {
              auto &st = processStates[procId];
              st.waiting = false;
              scheduler.scheduleProcess(procId, SchedulingRegion::Active);
            }));
      }
      return success();
    }

    // Handle __moore_event_trigger - trigger an event.
    // Implements the SystemVerilog `->event` syntax.
    // Signature: __moore_event_trigger(ptr event)
    // Sets the event flag to true and wakes up processes waiting on it.
    if (calleeName == "__moore_event_trigger") {
      if (callOp.getNumOperands() >= 1) {
        InterpretedValue eventPtrVal = getValue(procId, callOp.getOperand(0));
        if (!eventPtrVal.isX()) {
          uint64_t eventAddr = eventPtrVal.getUInt64();

          // Record the time slot when this event was triggered.
          // Per IEEE 1800-2017 §15.5.3, .triggered is only valid within the
          // same time slot. This map is the authoritative source.
          eventTriggerTime[eventAddr] = scheduler.getCurrentTime().realTime;
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_event_trigger() - "
                                  << "event 0x"
                                  << llvm::format_hex(eventAddr, 16)
                                  << " triggered at time "
                                  << scheduler.getCurrentTime().realTime
                                  << " fs\n");

          // Also set the memory byte if this is a memory-backed event.
          uint64_t offset = 0;
          MemoryBlock *block =
              findMemoryBlockByAddress(eventAddr, procId, &offset);
          if (block && block->size >= offset + 1) {
            block->data[offset] = 1;
            block->initialized = true;
            // Check if any processes are waiting on this memory location.
            checkMemoryEventWaiters();
          }
        } else {
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_event_trigger() - "
                                  << "event pointer is X\n");
        }
      }
      return success();
    }

    // Handle __moore_event_triggered - check if an event was triggered.
    // Implements the SystemVerilog `.triggered` property on events.
    // Signature: __moore_event_triggered(ptr event) -> i1
    // Returns true if the event flag is set.
    if (calleeName == "__moore_event_triggered") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        InterpretedValue eventPtrVal = getValue(procId, callOp.getOperand(0));
        bool triggered = false;

        if (!eventPtrVal.isX()) {
          uint64_t eventAddr = eventPtrVal.getUInt64();
          uint64_t currentRealTime = scheduler.getCurrentTime().realTime;

          // Per IEEE 1800-2017 §15.5.3, .triggered returns true only within
          // the same time slot where the event was triggered.
          // The eventTriggerTime map is the authoritative source - it records
          // when __moore_event_trigger was called for this event ID.
          auto it = eventTriggerTime.find(eventAddr);
          if (it != eventTriggerTime.end() &&
              it->second == currentRealTime) {
            triggered = true;
          }
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_event_triggered() - "
                                  << "event at address 0x"
                                  << llvm::format_hex(eventAddr, 16)
                                  << " is " << (triggered ? "triggered" : "not triggered")
                                  << " at time " << currentRealTime << " fs\n");
        } else {
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_event_triggered() - "
                                  << "event pointer is X, returning false\n");
        }

        setValue(procId, callOp.getResult(), InterpretedValue(APInt(1, triggered ? 1 : 0)));
      }
      return success();
    }

    // Handle __moore_wait_event - wait for an event in func.func context.
    // This is used when moore.wait_event appears in forked code or class methods
    // where llhd.wait cannot be used (requires llhd.process parent).
    // Signature: __moore_wait_event(i32 edgeKind, ptr valuePtr)
    // edgeKind: 0=AnyChange, 1=PosEdge, 2=NegEdge, 3=BothEdges
    // valuePtr: pointer to the memory location to watch (or null for any change)
    if (calleeName == "__moore_wait_event") {
      if (callOp.getNumOperands() >= 2) {
        InterpretedValue edgeKindVal = getValue(procId, callOp.getOperand(0));
        InterpretedValue valuePtrVal = getValue(procId, callOp.getOperand(1));

        int32_t edgeKind = edgeKindVal.isX() ? 0 : static_cast<int32_t>(edgeKindVal.getUInt64());
        uint64_t valueAddr = valuePtrVal.isX() ? 0 : valuePtrVal.getUInt64();

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_wait_event(edgeKind="
                                << edgeKind << ", valuePtr=0x"
                                << llvm::format_hex(valueAddr, 16) << ")\n");

        auto &state = processStates[procId];
        state.waiting = true;

        if (valueAddr != 0) {
          // Set up a memory event waiter for the specified address.
          uint64_t offset = 0;
          MemoryBlock *block = findMemoryBlockByAddress(valueAddr, procId, &offset);

          // Read current value for edge detection.
          uint64_t currentValue = 0;
          unsigned valueSize = 1;
          if (block && block->size >= offset + 1 && block->initialized) {
            currentValue = block->data[offset];
            // For larger values, read more bytes (up to 8).
            valueSize = std::min(block->size - offset, static_cast<size_t>(8));
            if (valueSize > 1) {
              currentValue = 0;
              for (unsigned i = 0; i < valueSize; ++i)
                currentValue |= static_cast<uint64_t>(block->data[offset + i]) << (i * 8);
            }
          }

          MemoryEventWaiter waiter;
          waiter.address = valueAddr;
          waiter.lastValue = currentValue;
          waiter.valueSize = valueSize;
          // Use rising edge detection for PosEdge, otherwise any change.
          waiter.waitForRisingEdge = (edgeKind == 1); // PosEdge
          memoryEventWaiters[procId] = waiter;

          LLVM_DEBUG(llvm::dbgs() << "    Set up memory event waiter for address 0x"
                                  << llvm::format_hex(valueAddr, 16)
                                  << " with initial value " << currentValue
                                  << " (edgeKind=" << edgeKind << ")\n");
        } else {
          // No specific address to watch. This happens when:
          // 1. The conversion couldn't trace back to a specific memory location
          // 2. We're waiting on a signal passed as a function argument
          //
          // For proper blocking, we need to wait for ANY signal change.
          // Set up the process to be woken on any signal change by using
          // the signal-based sensitivity mechanism.
          //
          // First, check if this process has any signals in its sensitivity list.
          // If so, wait for any of them to change.
          bool hasSignalSensitivity = !state.lastSensitivityEntries.empty();

          if (hasSignalSensitivity) {
            // The process already has sensitivity entries from previous waits.
            // Keep them and wait for any signal change.
            // The process will be woken by triggerSensitiveProcesses when
            // any of those signals change.
            LLVM_DEBUG(llvm::dbgs() << "    No specific address, waiting on "
                                    << state.lastSensitivityEntries.size()
                                    << " signal sensitivities\n");
            // state.waiting is already true, just don't schedule
          } else {
            // No signal sensitivities found. This can happen if we're in a
            // func.func context called from llhd.process but no signals are
            // being watched yet. Use delta steps first to keep $time == 0
            // during UVM initialization, then fall back to real time to
            // avoid infinite delta loops.
            SimTime currentTime = scheduler.getCurrentTime();
            constexpr uint32_t kMaxDeltaPolls = 1000;
            constexpr int64_t kFallbackPollDelayFs = 10000000; // 10 ps
            SimTime targetTime;
            if (currentTime.deltaStep < kMaxDeltaPolls) {
              targetTime = currentTime.nextDelta();
            } else {
              targetTime = currentTime.advanceTime(kFallbackPollDelayFs);
            }

            LLVM_DEBUG(llvm::dbgs() << "    No signals or address to watch, "
                                    << "polling (time="
                                    << targetTime.realTime << " fs, delta="
                                    << targetTime.deltaStep << ")\n");

            scheduler.getEventScheduler().schedule(
                targetTime, SchedulingRegion::Active,
                Event([this, procId]() {
                  auto &st = processStates[procId];
                  st.waiting = false;
                  scheduler.scheduleProcess(procId, SchedulingRegion::Active);
                }));
          }
        }
      }
      return success();
    }

    // Handle __moore_queue_push_back - append element to queue
    // Signature: (queue_ptr, element_ptr, element_size)
    if (calleeName == "__moore_queue_push_back") {
      if (callOp.getNumOperands() >= 3) {
        uint64_t queueAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        uint64_t elemAddr = getValue(procId, callOp.getOperand(1)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(getValue(procId, callOp.getOperand(2)).getUInt64());

        if (queueAddr != 0 && elemSize > 0) {
          uint64_t queueOffset = 0;
          auto *queueBlock = findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized &&
              queueOffset + 16 <= queueBlock->data.size()) {
            uint64_t dataPtr = 0;
            int64_t queueLen = 0;
            // Read from the correct offset within the block
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(queueBlock->data[queueOffset + i]) << (i * 8);
            for (int i = 0; i < 8; ++i)
              queueLen |= static_cast<int64_t>(queueBlock->data[queueOffset + 8 + i]) << (i * 8);

            // Sanity check queue length
            if (queueLen < 0 || queueLen > 100000) {
              LLVM_DEBUG(llvm::dbgs()
                         << "  llvm.call: __moore_queue_push_back: bad queueLen="
                         << queueLen << " at 0x"
                         << llvm::format_hex(queueAddr, 16) << "\n");
              return success();
            }

            // Allocate new storage with space for one more element.
            // Use global address counter to avoid overlap with other processes.
            int64_t newLen = queueLen + 1;
            uint64_t newDataAddr = globalNextAddress;
            globalNextAddress += newLen * elemSize;

            MemoryBlock newBlock(newLen * elemSize, 64);
            newBlock.initialized = true;

            // Copy existing elements
            if (dataPtr != 0 && queueLen > 0) {
              auto *oldBlock = findMemoryBlockByAddress(dataPtr, procId);
              if (oldBlock && oldBlock->initialized) {
                size_t copySize = std::min(static_cast<size_t>(queueLen * elemSize),
                                           std::min(oldBlock->data.size(), newBlock.data.size()));
                std::memcpy(newBlock.data.data(), oldBlock->data.data(), copySize);
              }
            }

            // Copy new element to the end
            uint64_t elemOffset = 0;
            auto *elemBlock = findMemoryBlockByAddress(elemAddr, procId, &elemOffset);
            if (elemBlock && elemBlock->initialized) {
              size_t availableBytes = (elemOffset < elemBlock->data.size())
                  ? elemBlock->data.size() - elemOffset : 0;
              size_t copySize = std::min(static_cast<size_t>(elemSize), availableBytes);
              if (copySize > 0)
                std::memcpy(newBlock.data.data() + queueLen * elemSize,
                            elemBlock->data.data() + elemOffset, copySize);
            }

            mallocBlocks[newDataAddr] = std::move(newBlock);
            addrRangeIndexDirty = true;

            // Re-find the queue block after mallocBlocks mutation
            uint64_t queueOffset2 = 0;
            auto *queueBlock2 = findMemoryBlockByAddress(queueAddr, procId, &queueOffset2);
            if (queueBlock2 && queueBlock2->initialized &&
                queueOffset2 + 16 <= queueBlock2->data.size()) {
              for (int i = 0; i < 8; ++i)
                queueBlock2->data[queueOffset2 + i] = static_cast<uint8_t>((newDataAddr >> (i * 8)) & 0xFF);
              for (int i = 0; i < 8; ++i)
                queueBlock2->data[queueOffset2 + 8 + i] = static_cast<uint8_t>((newLen >> (i * 8)) & 0xFF);
            }

            LLVM_DEBUG(llvm::dbgs() << "  __moore_queue_push_back: queueAddr=0x"
                                    << llvm::format_hex(queueAddr, 16)
                                    << " queueOffset=" << queueOffset
                                    << " newDataAddr=0x" << llvm::format_hex(newDataAddr, 16)
                                    << " elemSize=" << elemSize
                                    << " newLen=" << newLen << "\n");

            // Queue content changed - check if any process is waiting on memory events
            checkMemoryEventWaiters();
          }
        }
      }
      return success();
    }

    // Handle __moore_queue_size - return queue length
    // Signature: (queue_ptr) -> i64
    if (calleeName == "__moore_queue_size") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        uint64_t queueAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t queueLen = 0;

        if (queueAddr != 0) {
          uint64_t queueOffset = 0;
          auto *queueBlock = findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized) {
            for (int i = 0; i < 8; ++i)
              queueLen |= static_cast<int64_t>(queueBlock->data[queueOffset + 8 + i]) << (i * 8);
          }
        }

        setValue(procId, callOp.getResult(),
                 InterpretedValue(static_cast<uint64_t>(queueLen), 64));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_queue_size("
                                << "queue=0x" << llvm::format_hex(queueAddr, 16)
                                << ") = " << queueLen << "\n");
      }
      return success();
    }

    // Handle __moore_queue_clear - clear all elements
    // Signature: (queue_ptr)
    if (calleeName == "__moore_queue_clear") {
      if (callOp.getNumOperands() >= 1) {
        uint64_t queueAddr = getValue(procId, callOp.getOperand(0)).getUInt64();

        if (queueAddr != 0) {
          uint64_t queueOffset = 0;
          auto *queueBlock = findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized) {
            // Set data ptr to 0 and len to 0 (at the correct offset)
            std::memset(queueBlock->data.data() + queueOffset, 0, 16);
            LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_queue_clear("
                                    << "queue=0x" << llvm::format_hex(queueAddr, 16)
                                    << ")\n");
          }
        }
      }
      return success();
    }

    // Handle __moore_queue_pop_back - remove and return last element
    // Signature: (queue_ptr, element_size) -> element_value
    if (calleeName == "__moore_queue_pop_back") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t queueAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(getValue(procId, callOp.getOperand(1)).getUInt64());
        uint64_t result = 0;

        if (queueAddr != 0 && elemSize > 0) {
          uint64_t queueOffset = 0;
          auto *queueBlock = findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized &&
              queueOffset + 16 <= queueBlock->data.size()) {
            uint64_t dataPtr = 0;
            int64_t queueLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(queueBlock->data[queueOffset + i]) << (i * 8);
            for (int i = 0; i < 8; ++i)
              queueLen |= static_cast<int64_t>(queueBlock->data[queueOffset + 8 + i]) << (i * 8);

            if (queueLen > 0 && queueLen <= 100000 && dataPtr != 0) {
              // Read the last element
              auto *dataBlock = findMemoryBlockByAddress(dataPtr, procId);
              if (dataBlock && dataBlock->initialized) {
                size_t offset = (queueLen - 1) * elemSize;
                if (static_cast<int64_t>(offset + std::min(elemSize, int64_t(8))) <= static_cast<int64_t>(dataBlock->data.size()))
                  for (int64_t i = 0; i < std::min(elemSize, int64_t(8)); ++i)
                    result |= static_cast<uint64_t>(dataBlock->data[offset + i]) << (i * 8);
              }

              // Decrement length
              int64_t newLen = queueLen - 1;
              for (int i = 0; i < 8; ++i)
                queueBlock->data[queueOffset + 8 + i] = static_cast<uint8_t>((newLen >> (i * 8)) & 0xFF);
            }
          }
        }

        setValue(procId, callOp.getResult(), InterpretedValue(result, 64));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_queue_pop_back("
                                << "queue=0x" << llvm::format_hex(queueAddr, 16)
                                << ") = " << result << "\n");

        // Queue content changed - check if any process is waiting on memory events
        checkMemoryEventWaiters();
      }
      return success();
    }

    // Handle __moore_queue_pop_front - remove and return first element
    // Signature: (queue_ptr, element_size) -> element_value
    if (calleeName == "__moore_queue_pop_front") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t queueAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(getValue(procId, callOp.getOperand(1)).getUInt64());
        uint64_t result = 0;

        if (queueAddr != 0 && elemSize > 0) {
          uint64_t queueOffset = 0;
          auto *queueBlock = findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized &&
              queueOffset + 16 <= queueBlock->data.size()) {
            uint64_t dataPtr = 0;
            int64_t queueLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(queueBlock->data[queueOffset + i]) << (i * 8);
            for (int i = 0; i < 8; ++i)
              queueLen |= static_cast<int64_t>(queueBlock->data[queueOffset + 8 + i]) << (i * 8);

            if (queueLen > 0 && queueLen <= 100000 && dataPtr != 0) {
              auto *dataBlock = findMemoryBlockByAddress(dataPtr, procId);
              if (dataBlock && dataBlock->initialized) {
                // Read the first element
                size_t readSize = std::min(elemSize, int64_t(8));
                if (readSize <= dataBlock->data.size())
                  for (int64_t i = 0; i < static_cast<int64_t>(readSize); ++i)
                    result |= static_cast<uint64_t>(dataBlock->data[i]) << (i * 8);

                // Shift remaining elements forward
                if (queueLen > 1 &&
                    static_cast<size_t>(queueLen * elemSize) <= dataBlock->data.size()) {
                  std::memmove(dataBlock->data.data(),
                               dataBlock->data.data() + elemSize,
                               (queueLen - 1) * elemSize);
                }
              }

              // Decrement length
              int64_t newLen = queueLen - 1;
              for (int i = 0; i < 8; ++i)
                queueBlock->data[queueOffset + 8 + i] = static_cast<uint8_t>((newLen >> (i * 8)) & 0xFF);
            }
          }
        }

        setValue(procId, callOp.getResult(), InterpretedValue(result, 64));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_queue_pop_front("
                                << "queue=0x" << llvm::format_hex(queueAddr, 16)
                                << ") = " << result << "\n");

        // Queue content changed - check if any process is waiting on memory events
        checkMemoryEventWaiters();
      }
      return success();
    }

    // Handle __moore_queue_push_front - prepend element to queue
    // Signature: (queue_ptr, element_ptr, element_size)
    if (calleeName == "__moore_queue_push_front") {
      if (callOp.getNumOperands() >= 3) {
        uint64_t queueAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        uint64_t elemAddr = getValue(procId, callOp.getOperand(1)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(getValue(procId, callOp.getOperand(2)).getUInt64());

        if (queueAddr != 0 && elemSize > 0) {
          uint64_t queueOffset = 0;
          auto *queueBlock = findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized &&
              queueOffset + 16 <= queueBlock->data.size()) {
            uint64_t dataPtr = 0;
            int64_t queueLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(queueBlock->data[queueOffset + i]) << (i * 8);
            for (int i = 0; i < 8; ++i)
              queueLen |= static_cast<int64_t>(queueBlock->data[queueOffset + 8 + i]) << (i * 8);

            // Sanity check queue length
            if (queueLen < 0 || queueLen > 100000)
              return success();

            // Use global address counter to avoid overlap with other processes.
            int64_t newLen = queueLen + 1;
            uint64_t newDataAddr = globalNextAddress;
            globalNextAddress += newLen * elemSize;

            MemoryBlock newBlock(newLen * elemSize, 64);
            newBlock.initialized = true;

            // Copy new element to the front
            uint64_t elemOffset = 0;
            auto *elemBlock = findMemoryBlockByAddress(elemAddr, procId, &elemOffset);
            if (elemBlock && elemBlock->initialized) {
              size_t availableBytes = (elemOffset < elemBlock->data.size())
                  ? elemBlock->data.size() - elemOffset : 0;
              size_t copySize = std::min(static_cast<size_t>(elemSize), availableBytes);
              if (copySize > 0)
                std::memcpy(newBlock.data.data(),
                            elemBlock->data.data() + elemOffset, copySize);
            }

            // Copy existing elements after the new one
            if (dataPtr != 0 && queueLen > 0) {
              auto *oldBlock = findMemoryBlockByAddress(dataPtr, procId);
              if (oldBlock && oldBlock->initialized) {
                size_t copySize = std::min(static_cast<size_t>(queueLen * elemSize),
                                           oldBlock->data.size());
                if (static_cast<size_t>(elemSize) + copySize <= newBlock.data.size())
                  std::memcpy(newBlock.data.data() + elemSize,
                              oldBlock->data.data(), copySize);
              }
            }

            mallocBlocks[newDataAddr] = std::move(newBlock);
            addrRangeIndexDirty = true;

            // Re-find the queue block after mallocBlocks mutation to avoid
            // any pointer invalidation issues.
            uint64_t queueOffset2 = 0;
            auto *queueBlock2 = findMemoryBlockByAddress(queueAddr, procId, &queueOffset2);
            if (queueBlock2 && queueBlock2->initialized &&
                queueOffset2 + 16 <= queueBlock2->data.size()) {
              // Update queue struct (at the correct offset)
              for (int i = 0; i < 8; ++i)
                queueBlock2->data[queueOffset2 + i] = static_cast<uint8_t>((newDataAddr >> (i * 8)) & 0xFF);
              for (int i = 0; i < 8; ++i)
                queueBlock2->data[queueOffset2 + 8 + i] = static_cast<uint8_t>((newLen >> (i * 8)) & 0xFF);
            }

            LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_queue_push_front("
                                    << "queue=0x" << llvm::format_hex(queueAddr, 16)
                                    << ") -> len=" << newLen << "\n");
          }
        }
      }
      return success();
    }

    // Handle __moore_assoc_create - create an associative array
    // Signature: (key_size: i32, value_size: i32) -> ptr
    if (calleeName == "__moore_assoc_create") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        int32_t keySize = static_cast<int32_t>(getValue(procId, callOp.getOperand(0)).getUInt64());
        int32_t valueSize = static_cast<int32_t>(getValue(procId, callOp.getOperand(1)).getUInt64());

        void *arrayPtr = __moore_assoc_create(keySize, valueSize);
        uint64_t ptrVal = reinterpret_cast<uint64_t>(arrayPtr);

        // Track this as a valid associative array address
        validAssocArrayAddresses.insert(ptrVal);

        setValue(procId, callOp.getResult(), InterpretedValue(ptrVal, 64));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_create("
                                << keySize << ", " << valueSize << ") = 0x"
                                << llvm::format_hex(ptrVal, 16) << "\n");
      }
      return success();
    }

    // Handle __moore_assoc_get_ref - get reference to element in associative array
    // Signature: (array: ptr, key: ptr, value_size: i32) -> ptr
    // The runtime determines string vs integer keys from the array header.
    if (calleeName == "__moore_assoc_get_ref") {
      if (callOp.getNumOperands() >= 3 && callOp.getNumResults() >= 1) {
        InterpretedValue arrayVal = getValue(procId, callOp.getOperand(0));
        InterpretedValue keyVal = getValue(procId, callOp.getOperand(1));
        InterpretedValue valueSizeVal = getValue(procId, callOp.getOperand(2));

        // Handle X (uninitialized) values - return null pointer
        if (arrayVal.isX() || keyVal.isX() || valueSizeVal.isX()) {
          setValue(procId, callOp.getResult(), InterpretedValue(0ULL, 64));
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_get_ref - X input, returning null\n");
          return success();
        }

        uint64_t arrayAddr = arrayVal.getUInt64();
        uint64_t keyAddr = keyVal.getUInt64();
        int32_t valueSize = static_cast<int32_t>(valueSizeVal.getUInt64());

        // Check if arrayAddr is null or not a valid associative array address.
        bool isInValidSet = validAssocArrayAddresses.contains(arrayAddr);
        if (arrayAddr == 0 || !isInValidSet) {
          // Auto-create the associative array on first access (SystemVerilog semantics).
          int32_t keySize = 8; // default: 8-byte integer key
          if (auto allocaOp = callOp.getOperand(1).getDefiningOp<LLVM::AllocaOp>()) {
            Type elemType = allocaOp.getElemType();
            if (isa<LLVM::LLVMStructType>(elemType)) {
              keySize = 0; // string-keyed
            } else {
              unsigned bits = getTypeWidth(elemType);
              keySize = std::max(1u, (bits + 7) / 8);
            }
          }
          void *newArray = __moore_assoc_create(keySize, valueSize);
          uint64_t newAddr = reinterpret_cast<uint64_t>(newArray);
          validAssocArrayAddresses.insert(newAddr);
          arrayAddr = newAddr;
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_get_ref - auto-created array at 0x"
                                  << llvm::format_hex(newAddr, 16) << "\n");
          // Store the new array pointer back to the source memory location.
          if (auto loadOp = callOp.getOperand(0).getDefiningOp<LLVM::LoadOp>()) {
            InterpretedValue srcAddr = getValue(procId, loadOp.getAddr());
            if (!srcAddr.isX()) {
              uint64_t storeAddr = srcAddr.getUInt64();
              uint64_t blockOffset = 0;
              MemoryBlock *block = findMemoryBlockByAddress(storeAddr, procId, &blockOffset);
              if (block && block->initialized && blockOffset + 8 <= block->data.size()) {
                std::memcpy(block->data.data() + blockOffset, &newAddr, 8);
              } else {
                auto nmIt = nativeMemoryBlocks.find(storeAddr);
                if (nmIt != nativeMemoryBlocks.end())
                  std::memcpy(reinterpret_cast<void *>(storeAddr), &newAddr, 8);
              }
            }
          }
        }

        void *arrayPtr = reinterpret_cast<void *>(arrayAddr);

        // Read key from interpreter memory into a local buffer
        uint64_t keyOffset = 0;
        auto *keyBlock = findMemoryBlockByAddress(keyAddr, procId, &keyOffset);

        // We need to read the key data and pass a pointer to it.
        // For string keys: {ptr, i64} (16 bytes)
        // For integer keys: i8/i16/i32/i64 (1-8 bytes)
        // The runtime uses keySize stored in array header to know which.
        uint8_t keyBuffer[16] = {0};
        void *keyPtr = keyBuffer;
        MooreString keyString = {nullptr, 0};
        std::string keyStorage;

        if (keyBlock && keyBlock->initialized) {
          // Copy up to 16 bytes of key data
          // Safety check: make sure we don't underflow
          if (keyOffset > keyBlock->data.size()) {
            setValue(procId, callOp.getResult(), InterpretedValue(0ULL, 64));
            return success();
          }
          size_t maxCopy = std::min<size_t>(16, keyBlock->data.size() - keyOffset);
          std::memcpy(keyBuffer, keyBlock->data.data() + keyOffset, maxCopy);

          // Check if this looks like a string key ({ptr, len} struct)
          // by reading the header and checking keySize
          if (arrayPtr) {
            auto *header = static_cast<AssocArrayHeader *>(arrayPtr);
            if (header->type == AssocArrayType_StringKey) {
              // For string keys, interpret as MooreString
              uint64_t strPtrVal = 0;
              int64_t strLen = 0;
              for (int i = 0; i < 8; ++i) {
                strPtrVal |= static_cast<uint64_t>(keyBuffer[i]) << (i * 8);
                strLen |= static_cast<int64_t>(keyBuffer[8 + i]) << (i * 8);
              }
              if (!tryReadStringKey(procId, strPtrVal, strLen, keyStorage)) {
                LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_get_ref "
                                           "string key not readable\n");
                setValue(procId, callOp.getResult(), InterpretedValue(0ULL, 64));
                return success();
              }
              keyString.data = keyStorage.data();
              keyString.len = keyStorage.size();
              keyPtr = &keyString;

              LLVM_DEBUG({
                llvm::dbgs() << "  llvm.call: __moore_assoc_get_ref string key: ptr=0x"
                            << llvm::format_hex(strPtrVal, 16) << " len=" << strLen;
                if (keyString.data && keyString.len > 0) {
                  llvm::dbgs() << " = \"";
                  llvm::dbgs().write(keyString.data, std::min<int64_t>(keyString.len, 100));
                  llvm::dbgs() << "\"";
                }
                llvm::dbgs() << "\n";
              });
            } else {
              // Integer key - keyBuffer already contains the value
              LLVM_DEBUG({
                int64_t intKey = 0;
                std::memcpy(&intKey, keyBuffer, std::min<size_t>(8, maxCopy));
                llvm::dbgs() << "  llvm.call: __moore_assoc_get_ref int key: " << intKey << "\n";
              });
            }
          }
        }

        // MooreToCore sometimes uses valueSize=4 for pointer-valued arrays
        // (e.g., m_domains maps string -> uvm_domain handle). The actual stores
        // are 8 bytes (pointer-sized), so we need at least 8 bytes to avoid
        // the native store handler silently dropping the store due to bounds
        // checking.
        int32_t effectiveSize = std::max(valueSize, static_cast<int32_t>(8));
        LLVM_DEBUG(if (effectiveSize != valueSize) {
          llvm::dbgs() << "  assoc_get_ref: expanded valueSize from "
                       << valueSize << " to " << effectiveSize << " for array 0x"
                       << llvm::format_hex(arrayAddr, 16) << "\n";
        });
        void *resultPtr = __moore_assoc_get_ref(arrayPtr, keyPtr, effectiveSize);
        uint64_t resultVal = reinterpret_cast<uint64_t>(resultPtr);

        if (resultPtr && effectiveSize > 0) {
          size_t size = static_cast<size_t>(effectiveSize);
          auto it = nativeMemoryBlocks.find(resultVal);
          if (it == nativeMemoryBlocks.end() || it->second < size)
            nativeMemoryBlocks[resultVal] = size;
        }

        setValue(procId, callOp.getResult(), InterpretedValue(resultVal, 64));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_get_ref(0x"
                                << llvm::format_hex(arrayAddr, 16) << ", 0x"
                                << llvm::format_hex(keyAddr, 16) << ", "
                                << valueSize << ") = 0x"
                                << llvm::format_hex(resultVal, 16) << "\n");
      }
      return success();
    }

    // Handle __moore_assoc_exists - check if key exists in associative array
    // Signature: (array: ptr, key: ptr) -> i32
    if (calleeName == "__moore_assoc_exists") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        uint64_t keyAddr = getValue(procId, callOp.getOperand(1)).getUInt64();

        // Validate that the array address is a properly initialized associative array.
        if (arrayAddr == 0 || !validAssocArrayAddresses.contains(arrayAddr)) {
          setValue(procId, callOp.getResult(), InterpretedValue(0ULL, 32));
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_exists - uninitialized array at 0x"
                                  << llvm::format_hex(arrayAddr, 16) << ", returning false\n");
          return success();
        }

        void *arrayPtr = reinterpret_cast<void *>(arrayAddr);

        // Read key from interpreter memory
        uint64_t keyOffset = 0;
        auto *keyBlock = findMemoryBlockByAddress(keyAddr, procId, &keyOffset);

        uint8_t keyBuffer[16] = {0};
        void *keyPtr = keyBuffer;
        MooreString keyString = {nullptr, 0};
        std::string keyStorage;

        if (keyBlock && keyBlock->initialized) {
          size_t maxCopy = std::min<size_t>(16, keyBlock->data.size() - keyOffset);
          std::memcpy(keyBuffer, keyBlock->data.data() + keyOffset, maxCopy);

          if (arrayPtr) {
            auto *header = static_cast<AssocArrayHeader *>(arrayPtr);
            if (header->type == AssocArrayType_StringKey) {
              uint64_t strPtrVal = 0;
              int64_t strLen = 0;
              for (int i = 0; i < 8; ++i) {
                strPtrVal |= static_cast<uint64_t>(keyBuffer[i]) << (i * 8);
                strLen |= static_cast<int64_t>(keyBuffer[8 + i]) << (i * 8);
              }
              if (!tryReadStringKey(procId, strPtrVal, strLen, keyStorage)) {
                LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_exists "
                                           "string key not readable\n");
                setValue(procId, callOp.getResult(), InterpretedValue(0ULL, 32));
                return success();
              }
              keyString.data = keyStorage.data();
              keyString.len = keyStorage.size();
              keyPtr = &keyString;
            }
          }
        }

        int32_t result = __moore_assoc_exists(arrayPtr, keyPtr);

        // Debug: trace assoc_exists calls with string keys to diagnose NOCHILD
        setValue(procId, callOp.getResult(), InterpretedValue(static_cast<uint64_t>(result), 32));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_exists(0x"
                                << llvm::format_hex(arrayAddr, 16) << ", key) = "
                                << result << "\n");
      }
      return success();
    }

    // Handle __moore_assoc_first - get first key in associative array
    // Signature: (array: ptr, key_out: ptr) -> i1
    if (calleeName == "__moore_assoc_first") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        uint64_t keyOutAddr = getValue(procId, callOp.getOperand(1)).getUInt64();

        // Validate that the array address is a properly initialized associative array.
        if (arrayAddr == 0 || !validAssocArrayAddresses.contains(arrayAddr)) {
          setValue(procId, callOp.getResult(), InterpretedValue(0ULL, 1));
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_first - uninitialized array at 0x"
                                  << llvm::format_hex(arrayAddr, 16) << ", returning false\n");
          return success();
        }

        void *arrayPtr = reinterpret_cast<void *>(arrayAddr);

        // Find key output memory block
        uint64_t keyOutOffset = 0;
        auto *keyOutBlock = findMemoryBlockByAddress(keyOutAddr, procId, &keyOutOffset);

        // Determine key type from array header
        bool isStringKey = false;
        auto *header = static_cast<AssocArrayHeader *>(arrayPtr);
        isStringKey = (header->type == AssocArrayType_StringKey);

        bool result = false;
        if (isStringKey) {
          MooreString keyOut = {nullptr, 0};
          result = __moore_assoc_first(arrayPtr, &keyOut);

          if (result && keyOutBlock && keyOutOffset + 16 <= keyOutBlock->data.size()) {
            uint64_t ptrVal = reinterpret_cast<uint64_t>(keyOut.data);
            int64_t lenVal = keyOut.len;
            for (int i = 0; i < 8; ++i) {
              keyOutBlock->data[keyOutOffset + i] = static_cast<uint8_t>((ptrVal >> (i * 8)) & 0xFF);
              keyOutBlock->data[keyOutOffset + 8 + i] = static_cast<uint8_t>((lenVal >> (i * 8)) & 0xFF);
            }
            keyOutBlock->initialized = true;
            // Register the malloc'd string in dynamicStrings so
            // tryReadStringKey can find it in subsequent operations.
            if (keyOut.data && keyOut.len > 0)
              dynamicStrings[ptrVal] = {keyOut.data, keyOut.len};
          }
        } else {
          // Integer key - pass pointer to memory block directly
          // The key size can be 1, 2, 4, or 8 bytes depending on the index type.
          uint8_t keyBuffer[8] = {0};
          result = __moore_assoc_first(arrayPtr, keyBuffer);

          if (result && keyOutBlock) {
            size_t availableBytes = keyOutBlock->data.size() - keyOutOffset;
            size_t copySize = std::min<size_t>(8, availableBytes);
            std::memcpy(keyOutBlock->data.data() + keyOutOffset, keyBuffer, copySize);
            keyOutBlock->initialized = true;
          }
        }

        setValue(procId, callOp.getResult(), InterpretedValue(result ? 1ULL : 0ULL, 1));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_first(0x"
                                << llvm::format_hex(arrayAddr, 16) << ") = "
                                << result << "\n");
      }
      return success();
    }

    // Handle __moore_assoc_next - get next key in associative array
    // Signature: (array: ptr, key_ref: ptr) -> i1
    if (calleeName == "__moore_assoc_next") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        uint64_t keyRefAddr = getValue(procId, callOp.getOperand(1)).getUInt64();

        // Validate that the array address is a properly initialized associative array.
        if (arrayAddr == 0 || !validAssocArrayAddresses.contains(arrayAddr)) {
          setValue(procId, callOp.getResult(), InterpretedValue(0ULL, 1));
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_next - uninitialized array at 0x"
                                  << llvm::format_hex(arrayAddr, 16) << ", returning false\n");
          return success();
        }

        void *arrayPtr = reinterpret_cast<void *>(arrayAddr);

        // Find key memory block
        uint64_t keyRefOffset = 0;
        auto *keyRefBlock = findMemoryBlockByAddress(keyRefAddr, procId, &keyRefOffset);

        // Determine key type from array header
        auto *header = static_cast<AssocArrayHeader *>(arrayPtr);
        bool isStringKey = (header->type == AssocArrayType_StringKey);

        bool result = false;
        if (isStringKey) {
          MooreString keyRef = {nullptr, 0};
          if (keyRefBlock && keyRefBlock->initialized && keyRefOffset + 16 <= keyRefBlock->data.size()) {
            uint64_t strPtrVal = 0;
            int64_t strLen = 0;
            for (int i = 0; i < 8; ++i) {
              strPtrVal |= static_cast<uint64_t>(keyRefBlock->data[keyRefOffset + i]) << (i * 8);
              strLen |= static_cast<int64_t>(keyRefBlock->data[keyRefOffset + 8 + i]) << (i * 8);
            }
            keyRef.data = reinterpret_cast<char *>(strPtrVal);
            keyRef.len = strLen;
          }

          result = __moore_assoc_next(arrayPtr, &keyRef);

          if (result && keyRefBlock && keyRefOffset + 16 <= keyRefBlock->data.size()) {
            uint64_t ptrVal = reinterpret_cast<uint64_t>(keyRef.data);
            int64_t lenVal = keyRef.len;
            for (int i = 0; i < 8; ++i) {
              keyRefBlock->data[keyRefOffset + i] = static_cast<uint8_t>((ptrVal >> (i * 8)) & 0xFF);
              keyRefBlock->data[keyRefOffset + 8 + i] = static_cast<uint8_t>((lenVal >> (i * 8)) & 0xFF);
            }
            // Register the malloc'd string in dynamicStrings so
            // tryReadStringKey can find it in subsequent operations.
            if (keyRef.data && keyRef.len > 0)
              dynamicStrings[ptrVal] = {keyRef.data, keyRef.len};
          }
        } else {
          // Integer key - the key size can be 1, 2, 4, or 8 bytes.
          uint8_t keyBuffer[8] = {0};
          if (keyRefBlock && keyRefBlock->initialized) {
            size_t availableBytes = keyRefBlock->data.size() - keyRefOffset;
            size_t readSize = std::min<size_t>(8, availableBytes);
            std::memcpy(keyBuffer, keyRefBlock->data.data() + keyRefOffset, readSize);
          }

          int64_t keyBefore = 0;
          std::memcpy(&keyBefore, keyBuffer, 8);

          result = __moore_assoc_next(arrayPtr, keyBuffer);

          if (result && keyRefBlock) {
            size_t availableBytes = keyRefBlock->data.size() - keyRefOffset;
            size_t copySize = std::min<size_t>(8, availableBytes);
            std::memcpy(keyRefBlock->data.data() + keyRefOffset, keyBuffer, copySize);
          }
        }

        setValue(procId, callOp.getResult(), InterpretedValue(result ? 1ULL : 0ULL, 1));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_next(0x"
                                << llvm::format_hex(arrayAddr, 16) << ") = "
                                << result << "\n");
      }
      return success();
    }

    // Handle __moore_assoc_size - get size of associative array
    // Signature: (array: ptr) -> i64
    if (calleeName == "__moore_assoc_size") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr = getValue(procId, callOp.getOperand(0)).getUInt64();

        // Validate that the array address is a properly initialized associative array.
        if (arrayAddr == 0 || !validAssocArrayAddresses.contains(arrayAddr)) {
          setValue(procId, callOp.getResult(), InterpretedValue(0ULL, 64));
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_size - uninitialized array at 0x"
                                  << llvm::format_hex(arrayAddr, 16) << ", returning 0\n");
          return success();
        }

        void *arrayPtr = reinterpret_cast<void *>(arrayAddr);

        int64_t result = __moore_assoc_size(arrayPtr);

        setValue(procId, callOp.getResult(), InterpretedValue(static_cast<uint64_t>(result), 64));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_size(0x"
                                << llvm::format_hex(arrayAddr, 16) << ") = "
                                << result << "\n");
      }
      return success();
    }

    //===------------------------------------------------------------------===//
    // Mailbox DPI Hooks (Phase 1 - Non-blocking operations)
    //===------------------------------------------------------------------===//

    // Handle __moore_mailbox_create - create a new mailbox
    // Signature: (bound: i32) -> i64
    if (calleeName == "__moore_mailbox_create") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        int32_t bound = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(0)).getUInt64());

        MailboxId mboxId = syncPrimitivesManager.createMailbox(bound);

        setValue(procId, callOp.getResult(),
                 InterpretedValue(static_cast<uint64_t>(mboxId), 64));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_mailbox_create("
                                << bound << ") = " << mboxId << "\n");
      }
      return success();
    }

    auto wakePeekWaiters = [&](Mailbox *mbox, MailboxId mboxId) {
      if (!mbox || mbox->isEmpty())
        return;
      llvm::SmallVector<ProcessId, 4> peekWaiters;
      mbox->takePeekWaiters(peekWaiters);
      if (peekWaiters.empty())
        return;

      uint64_t peekMsg = 0;
      if (!mbox->tryPeek(peekMsg))
        return;

      for (ProcessId waiterId : peekWaiters) {
        auto waiterIt = processStates.find(waiterId);
        if (waiterIt == processStates.end())
          continue;
        auto &waiterState = waiterIt->second;
        if (waiterState.pendingMailboxPeekResultAddr != 0) {
          uint64_t outOffset = 0;
          auto *outBlock = findMemoryBlockByAddress(
              waiterState.pendingMailboxPeekResultAddr, waiterId, &outOffset);
          if (outBlock) { outBlock->initialized = true;
            for (int i = 0; i < 8; ++i)
              outBlock->data[outOffset + i] =
                  static_cast<uint8_t>((peekMsg >> (i * 8)) & 0xFF);
          }
        }
        waiterState.pendingMailboxPeekResultAddr = 0;
        waiterState.pendingMailboxPeekId = 0;
        waiterState.waiting = false;
        scheduler.scheduleProcess(waiterId, SchedulingRegion::Active);
        LLVM_DEBUG(llvm::dbgs() << "    Woke peek waiter process "
                                << waiterId << " on mailbox " << mboxId
                                << " with message " << peekMsg << "\n");
      }
    };

    // Handle __moore_mailbox_tryput - non-blocking put
    // Signature: (mbox_id: i64, msg: i64) -> i1
    if (calleeName == "__moore_mailbox_tryput") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        MailboxId mboxId = static_cast<MailboxId>(
            getValue(procId, callOp.getOperand(0)).getUInt64());
        uint64_t msg = getValue(procId, callOp.getOperand(1)).getUInt64();

        bool putSuccess = syncPrimitivesManager.mailboxTryPut(mboxId, msg);

        setValue(procId, callOp.getResult(),
                 InterpretedValue(putSuccess ? 1ULL : 0ULL, 1));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_mailbox_tryput("
                                << mboxId << ", " << msg << ") = "
                                << (putSuccess ? "true" : "false") << "\n");

        // If put succeeded, try to wake a waiting get process
        if (putSuccess) {
          Mailbox *mbox = syncPrimitivesManager.getMailbox(mboxId);
          if (mbox) {
            uint64_t waiterMsg = 0;
            ProcessId waiterId = mbox->trySatisfyGetWaiter(waiterMsg);
            if (waiterId != InvalidProcessId) {
              // Found a waiter - write the message to their output address
              auto waiterIt = processStates.find(waiterId);
              if (waiterIt != processStates.end()) {
                auto &waiterState = waiterIt->second;
                if (waiterState.pendingMailboxGetResultAddr != 0) {
                  uint64_t outOffset = 0;
                  auto *outBlock = findMemoryBlockByAddress(
                      waiterState.pendingMailboxGetResultAddr, waiterId, &outOffset);
                  if (outBlock) { outBlock->initialized = true;
                    for (int i = 0; i < 8; ++i)
                      outBlock->data[outOffset + i] =
                          static_cast<uint8_t>((waiterMsg >> (i * 8)) & 0xFF);
                  }
                }
                waiterState.pendingMailboxGetResultAddr = 0;
                waiterState.pendingMailboxGetId = 0;
                waiterState.waiting = false;
                scheduler.scheduleProcess(waiterId, SchedulingRegion::Active);
                LLVM_DEBUG(llvm::dbgs() << "    Woke get waiter process "
                                        << waiterId << " with message "
                                        << waiterMsg << "\n");
              }
            }
            wakePeekWaiters(mbox, mboxId);
          }
        }
      }
      return success();
    }

    // Handle __moore_mailbox_tryget - non-blocking get
    // Signature: (mbox_id: i64, msg_out: ptr) -> i1
    if (calleeName == "__moore_mailbox_tryget") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        MailboxId mboxId = static_cast<MailboxId>(
            getValue(procId, callOp.getOperand(0)).getUInt64());
        uint64_t msgOutAddr = getValue(procId, callOp.getOperand(1)).getUInt64();

        uint64_t msg = 0;
        bool getSuccess = syncPrimitivesManager.mailboxTryGet(mboxId, msg);

        // Write the message to the output pointer if successful
        if (getSuccess && msgOutAddr != 0) {
          uint64_t outOffset = 0;
          auto *outBlock = findMemoryBlockByAddress(msgOutAddr, procId, &outOffset);
          if (outBlock) { outBlock->initialized = true;
            // Write 64-bit message value
            for (int i = 0; i < 8; ++i)
              outBlock->data[outOffset + i] =
                  static_cast<uint8_t>((msg >> (i * 8)) & 0xFF);
          }
        }

        setValue(procId, callOp.getResult(),
                 InterpretedValue(getSuccess ? 1ULL : 0ULL, 1));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_mailbox_tryget("
                                << mboxId << ", 0x"
                                << llvm::format_hex(msgOutAddr, 16) << ") = "
                                << (getSuccess ? "true" : "false");
                   if (getSuccess) llvm::dbgs() << ", msg=" << msg;
                   llvm::dbgs() << "\n");

        // If get succeeded, try to wake a waiting put process (for bounded mailboxes)
        if (getSuccess) {
          Mailbox *mbox = syncPrimitivesManager.getMailbox(mboxId);
          if (mbox) {
            ProcessId waiterId = mbox->trySatisfyPutWaiter();
            if (waiterId != InvalidProcessId) {
              // Found a put waiter - their message was already added by trySatisfyPutWaiter
              auto waiterIt = processStates.find(waiterId);
              if (waiterIt != processStates.end()) {
                waiterIt->second.waiting = false;
                scheduler.scheduleProcess(waiterId, SchedulingRegion::Active);
                LLVM_DEBUG(llvm::dbgs() << "    Woke put waiter process "
                                        << waiterId << "\n");
              }
            }
            wakePeekWaiters(mbox, mboxId);
          }
        }
      }
      return success();
    }

    // Handle __moore_mailbox_trypeek - non-blocking peek (no removal)
    // Signature: (mbox_id: i64, msg_out: ptr) -> i1
    if (calleeName == "__moore_mailbox_trypeek") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        MailboxId mboxId = static_cast<MailboxId>(
            getValue(procId, callOp.getOperand(0)).getUInt64());
        uint64_t msgOutAddr = getValue(procId, callOp.getOperand(1)).getUInt64();

        uint64_t msg = 0;
        bool peekSuccess = syncPrimitivesManager.mailboxPeek(mboxId, msg);

        // Write the message to the output pointer if successful
        if (peekSuccess && msgOutAddr != 0) {
          uint64_t outOffset = 0;
          auto *outBlock = findMemoryBlockByAddress(msgOutAddr, procId, &outOffset);
          if (outBlock) { outBlock->initialized = true;
            // Write 64-bit message value
            for (int i = 0; i < 8; ++i)
              outBlock->data[outOffset + i] =
                  static_cast<uint8_t>((msg >> (i * 8)) & 0xFF);
          }
        }

        setValue(procId, callOp.getResult(),
                 InterpretedValue(peekSuccess ? 1ULL : 0ULL, 1));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_mailbox_trypeek("
                                << mboxId << ", 0x"
                                << llvm::format_hex(msgOutAddr, 16) << ") = "
                                << (peekSuccess ? "true" : "false");
                   if (peekSuccess) llvm::dbgs() << ", msg=" << msg;
                   llvm::dbgs() << "\n");
      }
      return success();
    }

    // Handle __moore_mailbox_num - get message count
    // Signature: (mbox_id: i64) -> i64
    if (calleeName == "__moore_mailbox_num") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        MailboxId mboxId = static_cast<MailboxId>(
            getValue(procId, callOp.getOperand(0)).getUInt64());

        size_t count = syncPrimitivesManager.mailboxNum(mboxId);

        setValue(procId, callOp.getResult(),
                 InterpretedValue(static_cast<uint64_t>(count), 64));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_mailbox_num("
                                << mboxId << ") = " << count << "\n");
      }
      return success();
    }

    // Handle __moore_mailbox_put - blocking put
    // Signature: (mbox_id: i64, msg: i64) -> void
    // Blocks if the mailbox is full (bounded mailbox)
    if (calleeName == "__moore_mailbox_put") {
      if (callOp.getNumOperands() >= 2) {
        MailboxId mboxId = static_cast<MailboxId>(
            getValue(procId, callOp.getOperand(0)).getUInt64());
        uint64_t msg = getValue(procId, callOp.getOperand(1)).getUInt64();

        // Try non-blocking put first
        if (syncPrimitivesManager.mailboxTryPut(mboxId, msg)) {
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_mailbox_put("
                                  << mboxId << ", " << msg
                                  << ") - message sent immediately\n");

          // Try to wake a waiting get process
          Mailbox *mbox = syncPrimitivesManager.getMailbox(mboxId);
          if (mbox) {
            uint64_t waiterMsg = 0;
            ProcessId waiterId = mbox->trySatisfyGetWaiter(waiterMsg);
            if (waiterId != InvalidProcessId) {
              // Found a waiter - write the message to their output address
              auto waiterIt = processStates.find(waiterId);
              if (waiterIt != processStates.end()) {
                auto &waiterState = waiterIt->second;
                if (waiterState.pendingMailboxGetResultAddr != 0) {
                  uint64_t outOffset = 0;
                  auto *outBlock = findMemoryBlockByAddress(
                      waiterState.pendingMailboxGetResultAddr, waiterId, &outOffset);
                  if (outBlock) { outBlock->initialized = true;
                    for (int i = 0; i < 8; ++i)
                      outBlock->data[outOffset + i] =
                          static_cast<uint8_t>((waiterMsg >> (i * 8)) & 0xFF);
                  }
                }
                waiterState.pendingMailboxGetResultAddr = 0;
                waiterState.pendingMailboxGetId = 0;
                waiterState.waiting = false;
                scheduler.scheduleProcess(waiterId, SchedulingRegion::Active);
                LLVM_DEBUG(llvm::dbgs() << "    Woke get waiter process "
                                        << waiterId << " with message "
                                        << waiterMsg << "\n");
              }
            }
            wakePeekWaiters(mbox, mboxId);
          }
        } else {
          // Mailbox is full - block until space is available
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_mailbox_put("
                                  << mboxId << ", " << msg
                                  << ") - blocking (mailbox full)\n");

          // Add this process to the put wait queue
          syncPrimitivesManager.mailboxPut(mboxId, procId, msg);

          // Suspend the process
          auto &state = processStates[procId];
          state.waiting = true;

          // Set up to resume at the next operation after the call
          state.destBlock = callOp->getBlock();
          state.currentOp = std::next(Block::iterator(callOp));
          state.resumeAtCurrentOp = true;

          Process *proc = scheduler.getProcess(procId);
          if (proc)
            proc->setState(ProcessState::Waiting);
        }
      }
      return success();
    }

    // Handle __moore_mailbox_get - blocking get
    // Signature: (mbox_id: i64, msg_out: ptr) -> void
    // Blocks if the mailbox is empty
    if (calleeName == "__moore_mailbox_get") {
      if (callOp.getNumOperands() >= 2) {
        MailboxId mboxId = static_cast<MailboxId>(
            getValue(procId, callOp.getOperand(0)).getUInt64());
        uint64_t msgOutAddr = getValue(procId, callOp.getOperand(1)).getUInt64();

        // Try non-blocking get first
        uint64_t msg = 0;
        if (syncPrimitivesManager.mailboxTryGet(mboxId, msg)) {
          // Got a message - write it to the output pointer
          if (msgOutAddr != 0) {
            uint64_t outOffset = 0;
            auto *outBlock = findMemoryBlockByAddress(msgOutAddr, procId, &outOffset);
            if (outBlock) { outBlock->initialized = true;
              // Write 64-bit message value
              for (int i = 0; i < 8; ++i)
                outBlock->data[outOffset + i] =
                    static_cast<uint8_t>((msg >> (i * 8)) & 0xFF);
            }
          }

          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_mailbox_get("
                                  << mboxId << ", 0x"
                                  << llvm::format_hex(msgOutAddr, 16)
                                  << ") - got message " << msg << "\n");

          // Try to wake a waiting put process (for bounded mailboxes)
          Mailbox *mbox = syncPrimitivesManager.getMailbox(mboxId);
          if (mbox) {
            ProcessId waiterId = mbox->trySatisfyPutWaiter();
            if (waiterId != InvalidProcessId) {
              // Found a put waiter - their message was already added
              auto waiterIt = processStates.find(waiterId);
              if (waiterIt != processStates.end()) {
                waiterIt->second.waiting = false;
                scheduler.scheduleProcess(waiterId, SchedulingRegion::Active);
                LLVM_DEBUG(llvm::dbgs() << "    Woke put waiter process "
                                        << waiterId << "\n");
              }
            }
            wakePeekWaiters(mbox, mboxId);
          }
        } else {
          // Mailbox is empty - block until a message is available
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_mailbox_get("
                                  << mboxId << ", 0x"
                                  << llvm::format_hex(msgOutAddr, 16)
                                  << ") - blocking (mailbox empty)\n");

          // Add this process to the get wait queue
          syncPrimitivesManager.mailboxGet(mboxId, procId);

          // Save the output address so we can write the result when resumed
          auto &state = processStates[procId];
          state.pendingMailboxGetResultAddr = msgOutAddr;
          state.pendingMailboxGetId = mboxId;
          state.waiting = true;

          // Set up to resume at the next operation after the call
          state.destBlock = callOp->getBlock();
          state.currentOp = std::next(Block::iterator(callOp));
          state.resumeAtCurrentOp = true;

          Process *proc = scheduler.getProcess(procId);
          if (proc)
            proc->setState(ProcessState::Waiting);
        }
      }
      return success();
    }

    // Handle __moore_mailbox_peek - blocking peek (no removal)
    // Signature: (mbox_id: i64, msg_out: ptr) -> void
    // Blocks if the mailbox is empty
    if (calleeName == "__moore_mailbox_peek") {
      if (callOp.getNumOperands() >= 2) {
        MailboxId mboxId = static_cast<MailboxId>(
            getValue(procId, callOp.getOperand(0)).getUInt64());
        uint64_t msgOutAddr = getValue(procId, callOp.getOperand(1)).getUInt64();

        // Try non-blocking peek first
        uint64_t msg = 0;
        if (syncPrimitivesManager.mailboxPeek(mboxId, msg)) {
          // Got a message - write it to the output pointer
          if (msgOutAddr != 0) {
            uint64_t outOffset = 0;
            auto *outBlock = findMemoryBlockByAddress(msgOutAddr, procId, &outOffset);
            if (outBlock) { outBlock->initialized = true;
              // Write 64-bit message value
              for (int i = 0; i < 8; ++i)
                outBlock->data[outOffset + i] =
                    static_cast<uint8_t>((msg >> (i * 8)) & 0xFF);
            }
          }

          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_mailbox_peek("
                                  << mboxId << ", 0x"
                                  << llvm::format_hex(msgOutAddr, 16)
                                  << ") - got message " << msg << "\n");
        } else {
          // Mailbox is empty - block until a message is available
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_mailbox_peek("
                                  << mboxId << ", 0x"
                                  << llvm::format_hex(msgOutAddr, 16)
                                  << ") - blocking (mailbox empty)\n");

          Mailbox *mbox = syncPrimitivesManager.getOrCreateMailbox(mboxId);
          if (mbox)
            mbox->addPeekWaiter(procId);

          // Save the output address so we can write the result when resumed
          auto &state = processStates[procId];
          state.pendingMailboxPeekResultAddr = msgOutAddr;
          state.pendingMailboxPeekId = mboxId;
          state.waiting = true;

          // Set up to resume at the next operation after the call
          state.destBlock = callOp->getBlock();
          state.currentOp = std::next(Block::iterator(callOp));
          state.resumeAtCurrentOp = true;

          Process *proc = scheduler.getProcess(procId);
          if (proc)
            proc->setState(ProcessState::Waiting);
        }
      }
      return success();
    }

    // Handle __moore_semaphore_create - register a semaphore with initial count
    // Signature: (sem_addr: i64, keyCount: i32) -> void
    if (calleeName == "__moore_semaphore_create") {
      if (callOp.getNumOperands() >= 2) {
        uint64_t semAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        int32_t keyCount = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());

        // Create the semaphore with the given initial key count,
        // using the object address as the semaphore ID
        syncPrimitivesManager.getOrCreateSemaphore(
            static_cast<SemaphoreId>(semAddr), keyCount);

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_semaphore_create(0x"
                                << llvm::format_hex(semAddr, 16) << ", "
                                << keyCount << ")\n");
      }
      return success();
    }

    // Handle __moore_semaphore_get - blocking get
    // Signature: (sem_addr: i64, keyCount: i32) -> void
    // Blocks if insufficient keys are available
    if (calleeName == "__moore_semaphore_get") {
      if (callOp.getNumOperands() >= 2) {
        uint64_t semAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        int32_t keyCount = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        auto semId = static_cast<SemaphoreId>(semAddr);

        // Try non-blocking get first
        if (syncPrimitivesManager.semaphoreTryGet(semId, keyCount)) {
          LLVM_DEBUG(llvm::dbgs()
                     << "  llvm.call: __moore_semaphore_get(0x"
                     << llvm::format_hex(semAddr, 16) << ", " << keyCount
                     << ") - acquired immediately\n");

          // After acquiring, try to wake other waiting processes
          // (semaphorePut handles this, but get doesn't release keys)
        } else {
          // Not enough keys - block until available
          LLVM_DEBUG(llvm::dbgs()
                     << "  llvm.call: __moore_semaphore_get(0x"
                     << llvm::format_hex(semAddr, 16) << ", " << keyCount
                     << ") - blocking (insufficient keys)\n");

          // Add this process to the semaphore wait queue
          Semaphore *sem =
              syncPrimitivesManager.getOrCreateSemaphore(semId);
          if (sem)
            sem->addWaiter(procId, keyCount);

          // Suspend the process
          auto &state = processStates[procId];
          state.pendingSemaphoreGetId = semAddr;
          state.waiting = true;
          state.destBlock = callOp->getBlock();
          state.currentOp = std::next(Block::iterator(callOp));
          state.resumeAtCurrentOp = true;

          Process *proc = scheduler.getProcess(procId);
          if (proc)
            proc->setState(ProcessState::Waiting);
        }
      }
      return success();
    }

    // Handle __moore_semaphore_put - put keys back
    // Signature: (sem_addr: i64, keyCount: i32) -> void
    if (calleeName == "__moore_semaphore_put") {
      if (callOp.getNumOperands() >= 2) {
        uint64_t semAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        int32_t keyCount = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        auto semId = static_cast<SemaphoreId>(semAddr);

        syncPrimitivesManager.semaphorePut(semId, keyCount);

        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_semaphore_put(0x"
                   << llvm::format_hex(semAddr, 16) << ", " << keyCount
                   << ")\n");

        // semaphorePut already handles waking blocked processes
      }
      return success();
    }

    // Handle __moore_semaphore_try_get - non-blocking get
    // Signature: (sem_addr: i64, keyCount: i32) -> i1
    if (calleeName == "__moore_semaphore_try_get") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t semAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        int32_t keyCount = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        auto semId = static_cast<SemaphoreId>(semAddr);

        // Auto-create the semaphore if it doesn't exist yet. This handles
        // cases where the SV constructor chain didn't properly store the
        // semaphore handle (e.g., different class hierarchy struct layouts
        // cause the GEP to read uninitialized memory). The auto-created
        // semaphore starts with keyCount keys, so the first try_get succeeds
        // and subsequent re-entrant calls correctly fail with 0 keys.
        if (!syncPrimitivesManager.getSemaphore(semId)) {
          syncPrimitivesManager.getOrCreateSemaphore(semId, keyCount);
        }

        bool success = syncPrimitivesManager.semaphoreTryGet(semId, keyCount);

        setValue(procId, callOp.getResult(),
                 InterpretedValue(success ? 1ULL : 0ULL, 1));

        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_semaphore_try_get(0x"
                   << llvm::format_hex(semAddr, 16) << ", " << keyCount
                   << ") = " << (success ? "true" : "false") << "\n");
      }
      return success();
    }

    // ---- __moore_test_plusargs ----
    // Signature: (ptr_to_string: ptr, length: i32) -> i32
    // Checks if any plusarg starts with the given string.
    // IEEE 1800-2017 Section 21.6
    if (calleeName == "__moore_test_plusargs") {
      int32_t result = 0;
      if (callOp.getNumOperands() >= 2) {
        // Read the string from global memory
        uint64_t strAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        int32_t strLen = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());

        std::string pattern;
        if (strAddr != 0 && strLen > 0) {
          uint64_t blockOffset = 0;
          auto *block =
              findMemoryBlockByAddress(strAddr, procId, &blockOffset);
          if (block && block->initialized) {
            for (int32_t i = 0; i < strLen; ++i) {
              size_t idx = blockOffset + i;
              if (idx < block->data.size()) {
                char c = static_cast<char>(block->data[idx]);
                if (c == '\0')
                  break;
                pattern += c;
              }
            }
          }
        }

        // Check against CIRCT_UVM_ARGS environment variable
        if (!pattern.empty()) {
          const char *env = std::getenv("CIRCT_UVM_ARGS");
          if (!env)
            env = std::getenv("UVM_ARGS");
          if (env) {
            std::string args(env);
            // Search for +pattern in the args
            std::string searchFor = "+" + pattern;
            if (args.find(searchFor) != std::string::npos)
              result = 1;
          }
        }

        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_test_plusargs(\"" << pattern
                   << "\") = " << result << "\n");
      }
      if (callOp.getNumResults() >= 1) {
        setValue(procId, callOp.getResult(),
                 InterpretedValue(static_cast<uint64_t>(result), 32));
      }
      return success();
    }

    // ---- __moore_value_plusargs ----
    // Signature: (format_ptr: ptr, format_len: i32, output_ptr: ptr,
    //             output_bytes: i32) -> i32
    // Checks CIRCT_UVM_ARGS / UVM_ARGS for a matching +name=value plusarg.
    // Parses the format string (e.g., "UVM_TESTNAME=%s", "TIMEOUT=%d"),
    // extracts the value, writes it to the output pointer, and returns 1.
    // Returns 0 if the plusarg is not found.
    // IEEE 1800-2017 Section 21.6
    if (calleeName == "__moore_value_plusargs") {
      int32_t result = 0;
      if (callOp.getNumOperands() >= 4) {
        // Read the format string from global memory.
        uint64_t fmtAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        int32_t fmtLen = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        uint64_t outAddr = getValue(procId, callOp.getOperand(2)).getUInt64();
        int32_t outBytes = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(3)).getUInt64());

        std::string fmtStr;
        if (fmtAddr != 0 && fmtLen > 0) {
          uint64_t blockOffset = 0;
          auto *block =
              findMemoryBlockByAddress(fmtAddr, procId, &blockOffset);
          if (block && block->initialized) {
            for (int32_t i = 0; i < fmtLen; ++i) {
              size_t idx = blockOffset + i;
              if (idx < block->data.size()) {
                char c = static_cast<char>(block->data[idx]);
                if (c == '\0')
                  break;
                fmtStr += c;
              }
            }
          }
        }

        // Parse format: split at '%' to get plusarg name and format code.
        // E.g., "UVM_TESTNAME=%s" -> name="UVM_TESTNAME", code='s'
        std::string plusargName;
        char fmtCode = 's'; // default to string
        auto pctPos = fmtStr.find('%');
        if (pctPos != std::string::npos) {
          plusargName = fmtStr.substr(0, pctPos);
          // Remove trailing '=' from name if present.
          while (!plusargName.empty() && plusargName.back() == '=')
            plusargName.pop_back();
          if (pctPos + 1 < fmtStr.size())
            fmtCode = std::tolower(fmtStr[pctPos + 1]);
        } else {
          plusargName = fmtStr;
        }

        // Search CIRCT_UVM_ARGS / UVM_ARGS for +name=value.
        std::string foundValue;
        if (!plusargName.empty()) {
          const char *env = std::getenv("CIRCT_UVM_ARGS");
          if (!env)
            env = std::getenv("UVM_ARGS");
          if (env) {
            std::string args(env);
            std::string searchFor = "+" + plusargName + "=";
            auto pos = args.find(searchFor);
            if (pos != std::string::npos) {
              pos += searchFor.size();
              // Extract value until space or end.
              auto endPos = args.find(' ', pos);
              if (endPos == std::string::npos)
                endPos = args.size();
              foundValue = args.substr(pos, endPos - pos);
              result = 1;
            }
          }
        }

        // Write value to the output location if found.
        if (result == 1 && outBytes > 0) {
          bool isStringFmt = (fmtCode == 's');

          // Parse integer value for non-string formats.
          int64_t intVal = 0;
          if (!isStringFmt) {
            if (!foundValue.empty()) {
              char *endPtr = nullptr;
              int base = 10;
              if (fmtCode == 'h')
                base = 16;
              else if (fmtCode == 'o')
                base = 8;
              else if (fmtCode == 'b')
                base = 2;
              intVal = std::strtoll(foundValue.c_str(), &endPtr, base);
            }
          }

          // Trace the output operand through unrealized_conversion_cast
          // to find the underlying signal or alloca.
          Value outOperand = callOp.getOperand(2);
          bool written = false;

          // Try to trace through unrealized_conversion_cast to signal.
          if (auto castOp = outOperand.getDefiningOp<
                  mlir::UnrealizedConversionCastOp>()) {
            Value castInput = castOp.getInputs()[0];
            SignalId sigId = resolveSignalId(castInput);
            if (sigId != 0) {
              unsigned width = outBytes * 8;
              InterpretedValue driveVal;
              if (isStringFmt) {
                // Pack string into APInt: SV convention has first char
                // in the most significant byte position.
                llvm::APInt packed(width, 0);
                for (size_t i = 0; i < foundValue.size(); ++i) {
                  unsigned bitPos = (foundValue.size() - 1 - i) * 8;
                  if (bitPos + 8 <= width) {
                    llvm::APInt charBits(width,
                                         static_cast<uint8_t>(foundValue[i]));
                    packed |= charBits.shl(bitPos);
                  }
                }
                driveVal = InterpretedValue(packed);
              } else {
                driveVal = InterpretedValue(static_cast<uint64_t>(intVal),
                                            width);
              }
              pendingEpsilonDrives[sigId] = driveVal;
              SignalValue newVal = driveVal.toSignalValue();
              auto targetTime = scheduler.getCurrentTime();
              targetTime.deltaStep++;
              uint64_t driverId =
                  (static_cast<uint64_t>(procId) << 32) |
                  static_cast<uint64_t>(sigId);
              scheduler.getEventScheduler().schedule(
                  targetTime, SchedulingRegion::NBA,
                  Event([this, sigId, driverId, newVal]() {
                    scheduler.updateSignalWithStrength(
                        sigId, driverId, newVal, DriveStrength::Strong,
                        DriveStrength::Strong);
                  }));
              written = true;
            }
          }

          // Fallback: try writing to memory directly.
          if (!written && outAddr != 0) {
            uint64_t blockOffset = 0;
            auto *outBlock =
                findMemoryBlockByAddress(outAddr, procId, &blockOffset);
            if (outBlock) {
              if (isStringFmt) {
                // Write string characters directly to memory as a
                // C-style byte sequence (no truncation to 8 chars).
                for (size_t i = 0;
                     i < foundValue.size() &&
                     static_cast<int32_t>(i) < outBytes &&
                     (blockOffset + i) < outBlock->data.size();
                     ++i)
                  outBlock->data[blockOffset + i] =
                      static_cast<uint8_t>(foundValue[i]);
                // Null-terminate if space permits.
                size_t termPos = blockOffset + foundValue.size();
                if (static_cast<int32_t>(foundValue.size()) < outBytes &&
                    termPos < outBlock->data.size())
                  outBlock->data[termPos] = 0;
              } else {
                for (int32_t i = 0;
                     i < outBytes &&
                     (blockOffset + i) < outBlock->data.size();
                     ++i)
                  outBlock->data[blockOffset + i] =
                      static_cast<uint8_t>((intVal >> (i * 8)) & 0xFF);
              }
              written = true;
            }
          }
        }

        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_value_plusargs(\"" << fmtStr
                   << "\") = " << result
                   << (result ? " value=\"" + foundValue + "\"" : "") << "\n");
      }
      if (callOp.getNumResults() >= 1) {
        setValue(procId, callOp.getResult(),
                 InterpretedValue(static_cast<uint64_t>(result), 32));
      }
      return success();
    }

    // Handle __moore_int_to_string - convert i64 to string struct {ptr, i64}
    if (calleeName == "__moore_int_to_string" ||
        calleeName == "__moore_string_itoa") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        InterpretedValue intArg = getValue(procId, callOp.getOperand(0));
        std::string str;
        if (intArg.isX()) {
          str = "x";
        } else {
          str = std::to_string(intArg.getAPInt().getSExtValue());
        }

        // Store the string in persistent storage
        interpreterStrings.push_back(std::move(str));
        const std::string &stored = interpreterStrings.back();
        int64_t ptrVal = reinterpret_cast<int64_t>(stored.data());
        int64_t lenVal = static_cast<int64_t>(stored.size());

        // Register in dynamic strings registry
        dynamicStrings[ptrVal] = {stored.data(), lenVal};

        // Pack into 128-bit struct result {ptr(lower 64), len(upper 64)}
        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, static_cast<uint64_t>(ptrVal)), 0);
        safeInsertBits(packedResult,APInt(64, static_cast<uint64_t>(lenVal)), 64);
        setValue(procId, callOp.getResult(), InterpretedValue(packedResult));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_int_to_string("
                                << (intArg.isX() ? "X" : std::to_string(intArg.getAPInt().getSExtValue()))
                                << ") = \"" << stored << "\"\n");
      }
      return success();
    }

    // Handle __moore_readmemh / __moore_readmemb - load memory from file
    // Signature: void(filename_ptr, mem_ptr, elem_width_i32, num_elems_i32)
    // filename_ptr points to a stack-allocated {ptr, i64} string struct
    // mem_ptr is the !llhd.ref (signal) or alloca ptr for the memory array
    // elem_width is the logical bit width of each element (e.g. 8 for logic [7:0])
    // num_elems is the number of array elements
    if (calleeName == "__moore_readmemh" ||
        calleeName == "__moore_readmemb") {
      bool isHex = (calleeName == "__moore_readmemh");
      if (callOp.getNumOperands() >= 4) {
        // Extract filename from the string struct pointer (arg 0)
        InterpretedValue filenamePtrVal = getValue(procId, callOp.getOperand(0));
        std::string filename;
        if (!filenamePtrVal.isX()) {
          uint64_t structAddr = filenamePtrVal.getUInt64();
          uint64_t structOffset = 0;
          auto *block = findMemoryBlockByAddress(structAddr, procId, &structOffset);
          if (block && block->initialized && structOffset + 16 <= block->data.size()) {
            uint64_t strPtr = 0;
            int64_t strLen = 0;
            for (int i = 0; i < 8; ++i) {
              strPtr |= static_cast<uint64_t>(block->data[structOffset + i]) << (i * 8);
              strLen |= static_cast<int64_t>(block->data[structOffset + 8 + i]) << (i * 8);
            }
            if (strPtr != 0 && strLen > 0) {
              // Look up in dynamicStrings first
              auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
              if (dynIt != dynamicStrings.end() && dynIt->second.first) {
                filename = std::string(dynIt->second.first,
                    std::min(static_cast<size_t>(strLen),
                             static_cast<size_t>(dynIt->second.second)));
              } else {
                // Try global memory
                uint64_t strOffset = 0;
                auto *strBlock = findMemoryBlockByAddress(strPtr, procId, &strOffset);
                if (strBlock && strBlock->initialized &&
                    strOffset + strLen <= strBlock->data.size()) {
                  filename = std::string(
                      reinterpret_cast<const char *>(strBlock->data.data() + strOffset),
                      strLen);
                }
              }
            }
          }
        }

        // Get elem_width and num_elems from args 2 and 3
        InterpretedValue elemWidthVal = getValue(procId, callOp.getOperand(2));
        InterpretedValue numElemsVal = getValue(procId, callOp.getOperand(3));
        unsigned elemBitWidth = elemWidthVal.isX() ? 0 : static_cast<unsigned>(elemWidthVal.getUInt64());
        unsigned numElems = numElemsVal.isX() ? 0 : static_cast<unsigned>(numElemsVal.getUInt64());

        if (filename.empty() || elemBitWidth == 0 || numElems == 0) {
          LLVM_DEBUG(llvm::dbgs() << "  llvm.call: " << calleeName
                                  << " - invalid args (filename=\"" << filename
                                  << "\", elemWidth=" << elemBitWidth
                                  << ", numElems=" << numElems << ")\n");
          return success();
        }

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: " << calleeName
                                << "(\"" << filename << "\", elemWidth="
                                << elemBitWidth << ", numElems=" << numElems
                                << ")\n");

        // Parse the file - each line may contain: @addr, value, or // comment
        std::ifstream file(filename);
        if (!file.is_open()) {
          llvm::errs() << "Warning: " << (isHex ? "$readmemh" : "$readmemb")
                       << ": cannot open file \"" << filename << "\"\n";
          return success();
        }

        // Parse values from the file
        std::vector<std::pair<unsigned, APInt>> indexedValues;
        unsigned currentAddr = 0;
        std::string line;
        while (std::getline(file, line)) {
          // Strip comments (// style and /* */ style)
          auto commentPos = line.find("//");
          if (commentPos != std::string::npos)
            line = line.substr(0, commentPos);

          std::istringstream iss(line);
          std::string token;
          while (iss >> token) {
            if (token.empty())
              continue;

            // Address specification: @hex_addr
            if (token[0] == '@') {
              std::string addrStr = token.substr(1);
              currentAddr = std::stoul(addrStr, nullptr, 16);
              continue;
            }

            // Parse value token
            APInt val(elemBitWidth, 0);
            bool valid = true;
            if (isHex) {
              // Hex format - allow x/X/z/Z characters (treat as 0)
              std::string cleanToken;
              for (char c : token) {
                if (c == '_') continue; // Skip underscores
                if (c == 'x' || c == 'X' || c == 'z' || c == 'Z')
                  cleanToken += '0';
                else if (std::isxdigit(c))
                  cleanToken += c;
                else {
                  valid = false;
                  break;
                }
              }
              if (valid && !cleanToken.empty()) {
                // Parse hex value, truncating/extending to elemBitWidth
                unsigned numBits = cleanToken.size() * 4;
                if (numBits > elemBitWidth)
                  numBits = elemBitWidth;
                APInt parsed(std::max(numBits, elemBitWidth), cleanToken, 16);
                val = parsed.trunc(elemBitWidth);
              } else {
                valid = false;
              }
            } else {
              // Binary format - allow x/X/z/Z characters (treat as 0)
              std::string cleanToken;
              for (char c : token) {
                if (c == '_') continue;
                if (c == 'x' || c == 'X' || c == 'z' || c == 'Z')
                  cleanToken += '0';
                else if (c == '0' || c == '1')
                  cleanToken += c;
                else {
                  valid = false;
                  break;
                }
              }
              if (valid && !cleanToken.empty()) {
                unsigned numBits = cleanToken.size();
                if (numBits > elemBitWidth)
                  numBits = elemBitWidth;
                APInt parsed(std::max(numBits, elemBitWidth), cleanToken, 2);
                val = parsed.trunc(elemBitWidth);
              } else {
                valid = false;
              }
            }

            if (valid && currentAddr < numElems) {
              indexedValues.push_back({currentAddr, val});
              LLVM_DEBUG(llvm::dbgs() << "    [" << currentAddr << "] = 0x"
                                      << llvm::format_hex_no_prefix(
                                             val.getZExtValue(), (elemBitWidth + 3) / 4)
                                      << "\n");
              ++currentAddr;
            }
          }
        }
        file.close();

        if (indexedValues.empty()) {
          LLVM_DEBUG(llvm::dbgs() << "    No values parsed from file\n");
          return success();
        }

        // Now write the parsed values into the memory array.
        // The mem_ptr operand (arg 1) traces back to the !llhd.ref signal.
        Value memOperand = callOp.getOperand(1);
        SignalId sigId = resolveSignalId(memOperand);

        if (sigId != 0) {
          // Signal-backed memory: read current value, modify, write back
          const SignalValue &currentSV = scheduler.getSignalValue(sigId);
          unsigned totalWidth = currentSV.getWidth();
          APInt arrayBits = currentSV.isUnknown()
                                ? APInt(totalWidth, 0)
                                : currentSV.getAPInt();

          // Determine the total element width in the signal (including unknown bits)
          // For 4-state types: totalElemWidth = 2 * elemBitWidth
          // (struct<value: iN, unknown: iN>)
          unsigned totalElemWidth = totalWidth / numElems;

          for (auto &[idx, val] : indexedValues) {
            if (idx >= numElems)
              continue;
            // MooreToCore maps SV index i to hw.array index (N-1-i).
            // SV mem[0] is at the MSB end (hw.array index N-1).
            unsigned hwIdx = numElems - 1 - idx;
            unsigned elemBase = hwIdx * totalElemWidth;

            if (totalElemWidth == 2 * elemBitWidth) {
              // 4-state element: struct<value: iN, unknown: iN>
              // HW struct layout: field 0 ("value") at high bits,
              //                   field 1 ("unknown") at low bits
              // Set value bits (upper half of element) to the parsed value
              APInt valBits = val;
              if (valBits.getBitWidth() < elemBitWidth)
                valBits = valBits.zext(elemBitWidth);
              else if (valBits.getBitWidth() > elemBitWidth)
                valBits = valBits.trunc(elemBitWidth);
              safeInsertBits(arrayBits,valBits, elemBase + elemBitWidth);
              // Clear unknown bits (lower half of element)
              APInt zeroBits(elemBitWidth, 0);
              safeInsertBits(arrayBits,zeroBits, elemBase);
            } else {
              // 2-state or other: just insert the value directly
              APInt valBits = val;
              if (valBits.getBitWidth() < totalElemWidth)
                valBits = valBits.zext(totalElemWidth);
              else if (valBits.getBitWidth() > totalElemWidth)
                valBits = valBits.trunc(totalElemWidth);
              safeInsertBits(arrayBits,valBits, elemBase);
            }
          }

          scheduler.updateSignal(sigId, SignalValue(arrayBits));
          pendingEpsilonDrives[sigId] = InterpretedValue(arrayBits);

          // Also sync to backing memory block if one exists, so that
          // llhd.prb (which checks backing memory before scheduler)
          // sees the updated values.
          auto backingIt = signalBackingMemory.find(sigId);
          if (backingIt != signalBackingMemory.end()) {
            auto &st = processStates[backingIt->second.first];
            auto blkIt = st.memoryBlocks.find(backingIt->second.second);
            if (blkIt != st.memoryBlocks.end()) {
              unsigned totalBits = arrayBits.getBitWidth();
              unsigned totalBytes = (totalBits + 7) / 8;
              for (unsigned i = 0; i < totalBytes && i < blkIt->second.data.size(); ++i) {
                blkIt->second.data[i] = static_cast<uint8_t>(
                    arrayBits.extractBitsAsZExtValue(
                        std::min(8u, totalBits - i * 8), i * 8));
              }
            }
          }

          LLVM_DEBUG(llvm::dbgs() << "    Updated signal " << sigId
                                  << " with " << indexedValues.size()
                                  << " values\n");
        } else {
          // Alloca-backed memory: write values to the memory block
          InterpretedValue memPtrVal = getValue(procId, memOperand);
          if (!memPtrVal.isX()) {
            uint64_t memAddr = memPtrVal.getUInt64();
            uint64_t memOffset = 0;
            auto *memBlock = findMemoryBlockByAddress(memAddr, procId, &memOffset);
            if (memBlock && memBlock->initialized) {
              // For alloca-backed memory, the layout is LLVM-style:
              // each element is stored as a contiguous block of bytes.
              // For 4-state types in LLVM layout: struct{iN, iN} -> {value, unknown}
              // In LLVM layout, field 0 is at offset 0 (low bytes).
              unsigned totalElemWidth = (memBlock->data.size() - memOffset) * 8 / numElems;
              unsigned elemBytes = totalElemWidth / 8;

              for (auto &[idx, val] : indexedValues) {
                if (idx >= numElems)
                  continue;
                unsigned byteBase = memOffset + idx * elemBytes;
                unsigned valueBytes = (elemBitWidth + 7) / 8;

                // Write value bytes (in LLVM layout, value field is first)
                APInt valBits = val;
                if (valBits.getBitWidth() < elemBitWidth)
                  valBits = valBits.zext(elemBitWidth);
                for (unsigned b = 0; b < valueBytes && byteBase + b < memBlock->data.size(); ++b) {
                  memBlock->data[byteBase + b] =
                      static_cast<uint8_t>(valBits.extractBitsAsZExtValue(8, b * 8));
                }
                // Clear unknown bytes (in LLVM layout, unknown field follows value)
                for (unsigned b = valueBytes; b < elemBytes && byteBase + b < memBlock->data.size(); ++b) {
                  memBlock->data[byteBase + b] = 0;
                }
              }

              LLVM_DEBUG(llvm::dbgs() << "    Updated alloca memory at 0x"
                                      << llvm::format_hex(memAddr, 16)
                                      << " with " << indexedValues.size()
                                      << " values\n");
            }
          }
        }
      }
      return success();
    }

    // Handle __moore_string_concat - concatenate two string structs
    // Signature: (lhs_ptr: ptr, rhs_ptr: ptr) -> struct{ptr, i64}
    // lhs_ptr and rhs_ptr point to stack-allocated {ptr, i64} structs
    if (calleeName == "__moore_string_concat") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        // Helper to read a string struct from a pointer address
        auto readStringFromStructPtr = [&](Value operand) -> std::string {
          InterpretedValue ptrArg = getValue(procId, operand);
          if (ptrArg.isX())
            return "";

          uint64_t structAddr = ptrArg.getUInt64();
          uint64_t structOffset = 0;
          auto *block = findMemoryBlockByAddress(structAddr, procId, &structOffset);
          if (!block || !block->initialized || structOffset + 16 > block->data.size())
            return "";

          // Read ptr (first 8 bytes, little-endian) and len (next 8 bytes)
          uint64_t strPtr = 0;
          int64_t strLen = 0;
          for (int i = 0; i < 8; ++i) {
            strPtr |= static_cast<uint64_t>(block->data[structOffset + i]) << (i * 8);
            strLen |= static_cast<int64_t>(block->data[structOffset + 8 + i]) << (i * 8);
          }

          if (strPtr == 0 || strLen <= 0)
            return "";

          // Look up in dynamicStrings registry first
          auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
          if (dynIt != dynamicStrings.end() && dynIt->second.first &&
              dynIt->second.second > 0) {
            return std::string(dynIt->second.first,
                               std::min(static_cast<size_t>(strLen),
                                        static_cast<size_t>(dynIt->second.second)));
          }

          // Try global/malloc memory via O(log n) range index
          {
            uint64_t off = 0;
            MemoryBlock *gBlock = findBlockByAddress(strPtr, off);
            if (gBlock && gBlock->initialized) {
              size_t avail = std::min(static_cast<size_t>(strLen),
                                      gBlock->data.size() - static_cast<size_t>(off));
              if (avail > 0)
                return std::string(reinterpret_cast<const char *>(
                                       gBlock->data.data() + off),
                                   avail);
            }
          }

          // Try addressToGlobal reverse lookup
          auto globalIt = addressToGlobal.find(strPtr);
          if (globalIt != addressToGlobal.end()) {
            auto blockIt = globalMemoryBlocks.find(globalIt->second);
            if (blockIt != globalMemoryBlocks.end()) {
              const MemoryBlock &gBlock = blockIt->second;
              size_t avail = std::min(static_cast<size_t>(strLen),
                                      gBlock.data.size());
              if (avail > 0 && gBlock.initialized)
                return std::string(reinterpret_cast<const char *>(
                                       gBlock.data.data()),
                                   avail);
            }
          }

          return "";
        };

        std::string lhs = readStringFromStructPtr(callOp.getOperand(0));
        std::string rhs = readStringFromStructPtr(callOp.getOperand(1));
        std::string result = lhs + rhs;

        // Store the concatenated string in persistent storage
        interpreterStrings.push_back(std::move(result));
        const std::string &stored = interpreterStrings.back();
        int64_t ptrVal = reinterpret_cast<int64_t>(stored.data());
        int64_t lenVal = static_cast<int64_t>(stored.size());

        // Register in dynamic strings registry
        dynamicStrings[ptrVal] = {stored.data(), lenVal};

        // Pack into 128-bit struct result
        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, static_cast<uint64_t>(ptrVal)), 0);
        safeInsertBits(packedResult,APInt(64, static_cast<uint64_t>(lenVal)), 64);
        setValue(procId, callOp.getResult(), InterpretedValue(packedResult));

        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_concat(\"" << lhs
                                << "\", \"" << rhs << "\") = \"" << stored
                                << "\"\n");
      }
      return success();
    }

    // ---- __moore_dyn_cast_check ----
    if (calleeName == "__moore_dyn_cast_check") {
      if (callOp.getNumOperands() >= 3 && callOp.getNumResults() >= 1) {
        int32_t srcId = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(0)).getUInt64());
        int32_t targetId = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int32_t inheritanceDepth = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(2)).getUInt64());
        // Use RTTI parent table for correct hierarchy checking
        bool result = checkRTTICast(srcId, targetId);
        // Return type is i1 (bool) in the runtime, but MLIR may widen to i32
        unsigned resultWidth = getTypeWidth(callOp.getResult().getType());
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(resultWidth, result ? 1 : 0)));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_dyn_cast_check(src=" << srcId
                   << ", target=" << targetId
                   << ", depth=" << inheritanceDepth << ") = " << result
                   << "\n");
      }
      return success();
    }

    // ---- __moore_urandom ----
    // IEEE 1800-2017 §18.13.1: $urandom uses the calling process's RNG state.
    // This enables random stability: saving/restoring process RNG state via
    // process::get_randstate()/set_randstate() produces reproducible sequences.
    if (calleeName == "__moore_urandom") {
      auto &state = processStates[procId];
      uint32_t result = state.randomGenerator();
      setValue(procId, callOp.getResult(),
               InterpretedValue(APInt(32, result)));
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_urandom() = " << result
                               << " [per-process RNG, pid=" << procId << "]\n");
      return success();
    }

    // ---- __moore_urandom_range ----
    // IEEE 1800-2017 §18.13.2: $urandom_range uses the calling process's RNG.
    if (calleeName == "__moore_urandom_range") {
      uint32_t maxVal = static_cast<uint32_t>(
          getValue(procId, callOp.getOperand(0)).getUInt64());
      uint32_t minVal = static_cast<uint32_t>(
          getValue(procId, callOp.getOperand(1)).getUInt64());
      // IEEE 1800-2017: If min > max, swap them.
      if (minVal > maxVal)
        std::swap(minVal, maxVal);
      uint32_t result;
      if (minVal == maxVal) {
        result = minVal;
      } else {
        auto &state = processStates[procId];
        std::uniform_int_distribution<uint32_t> dist(minVal, maxVal);
        result = dist(state.randomGenerator);
      }
      setValue(procId, callOp.getResult(),
               InterpretedValue(APInt(32, result)));
      LLVM_DEBUG(llvm::dbgs()
                 << "  llvm.call: __moore_urandom_range(" << maxVal << ", "
                 << minVal << ") = " << result
                 << " [per-process RNG, pid=" << procId << "]\n");
      return success();
    }

    // ---- __moore_random ----
    // IEEE 1800-2017 §18.13: $random uses the calling process's RNG state.
    if (calleeName == "__moore_random") {
      auto &state = processStates[procId];
      int32_t result = static_cast<int32_t>(state.randomGenerator());
      setValue(procId, callOp.getResult(),
               InterpretedValue(APInt(32, static_cast<uint32_t>(result))));
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_random() = " << result
                               << " [per-process RNG, pid=" << procId << "]\n");
      return success();
    }

    // ---- __moore_urandom_seeded ----
    // Seeds the calling process's RNG and returns a value from it.
    if (calleeName == "__moore_urandom_seeded") {
      int32_t seed = static_cast<int32_t>(
          getValue(procId, callOp.getOperand(0)).getUInt64());
      auto &state = processStates[procId];
      state.randomGenerator.seed(static_cast<uint32_t>(seed));
      uint32_t result = state.randomGenerator();
      setValue(procId, callOp.getResult(),
               InterpretedValue(APInt(32, result)));
      LLVM_DEBUG(llvm::dbgs()
                 << "  llvm.call: __moore_urandom_seeded(" << seed
                 << ") = " << result
                 << " [per-process RNG, pid=" << procId << "]\n");
      return success();
    }

    // ---- __moore_random_seeded ----
    // Seeds the calling process's RNG and returns a value from it.
    if (calleeName == "__moore_random_seeded") {
      int32_t seed = static_cast<int32_t>(
          getValue(procId, callOp.getOperand(0)).getUInt64());
      auto &state = processStates[procId];
      state.randomGenerator.seed(static_cast<uint32_t>(seed));
      int32_t result = static_cast<int32_t>(state.randomGenerator());
      setValue(procId, callOp.getResult(),
               InterpretedValue(APInt(32, static_cast<uint32_t>(result))));
      LLVM_DEBUG(llvm::dbgs()
                 << "  llvm.call: __moore_random_seeded(" << seed
                 << ") = " << result
                 << " [per-process RNG, pid=" << procId << "]\n");
      return success();
    }

    // ---- __moore_randomize_basic ----
    // Signature: (classPtr: ptr, classSize: i64) -> i32
    // No-op: individual rand fields are set by subsequent _with_range/_with_dist
    // calls.  We only track the object address and advance the RNG seed.
    if (calleeName == "__moore_randomize_basic") {
      if (callOp.getNumOperands() >= 2) {
        uint64_t classAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t classSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        // Track last randomized object for subsequent range calls
        lastRandomizeObjAddr = classAddr;
        // If there's a pending seed from an old-style @srandom() stub,
        // apply it to this object's RNG now.
        if (pendingSrandomSeed.has_value()) {
          perObjectRng[classAddr] = std::mt19937(*pendingSrandomSeed);
          pendingSrandomSeed.reset();
        }

        // Do NOT fill the entire object with random bytes.  The object
        // contains non-rand metadata (class_id, vtable pointer, UVM base
        // class fields like m_sequencer, m_parent, m_name, etc.) that must
        // be preserved.  Each rand field gets its own constrained random
        // value from __moore_randomize_with_range / _with_dist calls that
        // follow this basic call.  Advance the RNG once to maintain
        // deterministic sequencing.
        if (classAddr != 0 && classSize > 0) {
          auto &rng = getObjectRng(classAddr);
          (void)rng(); // Advance RNG for determinism

          // The Moore compiler does not generate __moore_randomize_with_range
          // or __moore_dyn_array_new calls for rand dynamic array fields
          // during randomize(). Scan GEP operations on the class pointer to
          // find struct<(ptr, i64)> fields (MooreQueue / dynamic arrays).
          // For each empty one, allocate a 1-element array with random data.
          // The compiled restore code after this call will overwrite non-rand
          // fields back to their saved values, so only rand-enabled dynamic
          // array fields will keep the allocation.
          Value classPtr = callOp.getOperand(0);
          llvm::SmallVector<uint64_t, 8> dynArrayOffsets;
          for (auto &use : classPtr.getUses()) {
            auto *user = use.getOwner();
            auto gepOp = dyn_cast<LLVM::GEPOp>(user);
            if (!gepOp)
              continue;
            // Walk GEP indices to compute byte offset and final field type
            auto indices = gepOp.getIndices();
            Type currentType = gepOp.getElemType();
            unsigned fieldOffset = 0;
            size_t idx = 0;
            for (auto indexValue : indices) {
              int64_t indexVal = 0;
              if (auto intAttr =
                      llvm::dyn_cast_if_present<IntegerAttr>(indexValue))
                indexVal = intAttr.getInt();
              if (idx == 0) {
                fieldOffset += indexVal * getLLVMTypeSizeForGEP(currentType);
              } else if (auto structType =
                             dyn_cast<LLVM::LLVMStructType>(currentType)) {
                auto body = structType.getBody();
                for (int64_t j = 0;
                     j < indexVal &&
                     static_cast<size_t>(j) < body.size();
                     ++j)
                  fieldOffset += getLLVMTypeSizeForGEP(body[j]);
                if (static_cast<size_t>(indexVal) < body.size())
                  currentType = body[indexVal];
              }
              ++idx;
            }
            // Check if final type is struct<(ptr, i64)> = MooreQueue
            if (auto finalST =
                    dyn_cast<LLVM::LLVMStructType>(currentType)) {
              auto body = finalST.getBody();
              if (body.size() == 2 &&
                  isa<LLVM::LLVMPointerType>(body[0]) &&
                  isa<IntegerType>(body[1]) &&
                  cast<IntegerType>(body[1]).getWidth() == 64) {
                dynArrayOffsets.push_back(fieldOffset);
              }
            }
          }

          // Deduplicate offsets (multiple GEPs may point to same field)
          llvm::sort(dynArrayOffsets);
          dynArrayOffsets.erase(
              std::unique(dynArrayOffsets.begin(), dynArrayOffsets.end()),
              dynArrayOffsets.end());

          // Allocate 1-element arrays for empty dynamic array fields
          if (!dynArrayOffsets.empty()) {
            uint64_t objOff = 0;
            auto *block =
                findMemoryBlockByAddress(classAddr, procId, &objOff);
            if (block && block->initialized) {
              for (uint64_t fOff : dynArrayOffsets) {
                size_t dataOff = static_cast<size_t>(objOff) +
                                 static_cast<size_t>(fOff);
                if (dataOff + 16 > block->data.size())
                  continue;
                // Read ptr (8 bytes LE)
                uint64_t ptrField = 0;
                for (int i = 0; i < 8; ++i)
                  ptrField |=
                      static_cast<uint64_t>(block->data[dataOff + i])
                      << (i * 8);
                // Read len (8 bytes LE)
                uint64_t lenField = 0;
                for (int i = 0; i < 8; ++i)
                  lenField |=
                      static_cast<uint64_t>(block->data[dataOff + 8 + i])
                      << (i * 8);
                if (ptrField == 0 && lenField == 0) {
                  // Allocate 1-byte array (1 element for bit[7:0] types)
                  MooreQueue result = __moore_dyn_array_new(1);
                  if (result.data) {
                    auto *data = static_cast<uint8_t *>(result.data);
                    data[0] = rng() & 0xFF;
                    uint64_t newPtr =
                        reinterpret_cast<uint64_t>(result.data);
                    int64_t newLen = result.len;
                    for (int i = 0; i < 8; ++i)
                      block->data[dataOff + i] =
                          static_cast<uint8_t>(newPtr >> (i * 8));
                    for (int i = 0; i < 8; ++i)
                      block->data[dataOff + 8 + i] =
                          static_cast<uint8_t>(
                              static_cast<uint64_t>(newLen) >> (i * 8));
                    nativeMemoryBlocks[newPtr] = 1;
                    LLVM_DEBUG(llvm::dbgs()
                               << "  randomize_basic: allocated 1-elem "
                                  "array at field offset "
                               << fOff << " -> ptr=0x"
                               << llvm::format_hex(newPtr, 16) << "\n");
                  }
                }
              }
            }
          }
        }
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_randomize_basic(0x"
                   << llvm::format_hex(classAddr, 16)
                   << ", " << classSize << ") = 1\n");
      }
      setValue(procId, callOp.getResult(),
               InterpretedValue(APInt(32, 1)));
      return success();
    }

    // ---- __moore_randomize_with_dist ----
    // Signature: (ranges: ptr, weights: ptr, perRange: ptr,
    //             numRanges: i64, isSigned: i64) -> i64
    // Returns a random value from the weighted distribution of ranges.
    if (calleeName == "__moore_randomize_with_dist") {
      int64_t result = 0;
      if (callOp.getNumOperands() >= 4) {
        uint64_t rangesAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        uint64_t weightsAddr =
            getValue(procId, callOp.getOperand(1)).getUInt64();
        uint64_t perRangeAddr =
            getValue(procId, callOp.getOperand(2)).getUInt64();
        int64_t numRanges = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(3)).getUInt64());

        // Helper to read i64 from interpreter memory at address
        auto readI64 = [&](uint64_t addr) -> int64_t {
          uint64_t off = 0;
          auto *blk = findMemoryBlockByAddress(addr, procId, &off);
          if (!blk || !blk->initialized || off + 8 > blk->data.size())
            return 0;
          int64_t val = 0;
          for (int i = 0; i < 8; ++i)
            val |= static_cast<int64_t>(
                       static_cast<uint64_t>(blk->data[off + i]) << (i * 8));
          return val;
        };

        if (numRanges > 0 && rangesAddr != 0) {
          // Read ranges (pairs of low/high), weights, perRange
          std::vector<int64_t> ranges(numRanges * 2);
          std::vector<int64_t> weights(numRanges);
          std::vector<int64_t> perRange(numRanges);
          for (int64_t i = 0; i < numRanges * 2; ++i)
            ranges[i] = readI64(rangesAddr + i * 8);
          for (int64_t i = 0; i < numRanges; ++i)
            weights[i] = readI64(weightsAddr + i * 8);
          for (int64_t i = 0; i < numRanges; ++i)
            perRange[i] = readI64(perRangeAddr + i * 8);

          // Compute effective weights
          int64_t totalWeight = 0;
          std::vector<int64_t> effectiveWeights(numRanges);
          for (int64_t i = 0; i < numRanges; ++i) {
            int64_t low = ranges[i * 2];
            int64_t high = ranges[i * 2 + 1];
            int64_t rangeSize = high - low + 1;
            if (perRange[i] == 0)
              effectiveWeights[i] = weights[i] * rangeSize;
            else
              effectiveWeights[i] = weights[i];
            totalWeight += effectiveWeights[i];
          }

          if (totalWeight > 0) {
            auto &rng = getObjectRng(lastRandomizeObjAddr);
            int64_t randomWeight =
                static_cast<int64_t>(rng()) % totalWeight;
            int64_t cumulative = 0;
            for (int64_t i = 0; i < numRanges; ++i) {
              cumulative += effectiveWeights[i];
              if (randomWeight < cumulative) {
                int64_t low = ranges[i * 2];
                int64_t high = ranges[i * 2 + 1];
                int64_t rangeSize = high - low + 1;
                result = (rangeSize == 1) ? low
                                          : low + static_cast<int64_t>(rng() % rangeSize);
                break;
              }
            }
          } else {
            result = ranges[0];
          }
        }
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_randomize_with_dist(nRanges="
                   << numRanges << ") = " << result << "\n");
      }
      if (callOp.getNumResults() >= 1)
        setValue(procId, callOp.getResult(),
                 InterpretedValue(static_cast<uint64_t>(result), 64));
      return success();
    }

    // ---- __moore_randomize_with_range (singular) ----
    // Signature: (min: i64, max: i64) -> i64
    // Returns a uniformly random value in [min, max] using per-object RNG.
    if (calleeName == "__moore_randomize_with_range") {
      int64_t minVal = 0, maxVal = 0;
      if (callOp.getNumOperands() >= 2) {
        minVal = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(0)).getUInt64());
        maxVal = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
      }
      int64_t result = minVal;
      if (maxVal > minVal) {
        auto &rng = getObjectRng(lastRandomizeObjAddr);
        uint64_t range = static_cast<uint64_t>(maxVal - minVal) + 1;
        uint64_t randomVal = static_cast<uint64_t>(rng());
        if (range > UINT32_MAX)
          randomVal = (static_cast<uint64_t>(rng()) << 32) |
                      static_cast<uint64_t>(rng());
        result = minVal + static_cast<int64_t>(randomVal % range);
      }
      LLVM_DEBUG(llvm::dbgs()
                 << "  llvm.call: __moore_randomize_with_range(min="
                 << minVal << ", max=" << maxVal << ") = " << result << "\n");
      if (callOp.getNumResults() >= 1)
        setValue(procId, callOp.getResult(),
                 InterpretedValue(static_cast<uint64_t>(result), 64));
      return success();
    }

    // ---- __moore_randomize_with_ranges ----
    // Signature: (ranges: ptr, numRanges: i64) -> i64
    // Returns a uniformly random value from the union of [low,high] ranges.
    // The ranges array contains pairs of i64: [low1, high1, low2, high2, ...].
    if (calleeName == "__moore_randomize_with_ranges") {
      int64_t result = 0;
      if (callOp.getNumOperands() >= 2) {
        uint64_t rangesAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t numRanges = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());

        // Helper to read i64 from interpreter memory at address
        auto readI64 = [&](uint64_t addr) -> int64_t {
          uint64_t off = 0;
          auto *blk = findMemoryBlockByAddress(addr, procId, &off);
          if (!blk || !blk->initialized || off + 8 > blk->data.size())
            return 0;
          int64_t val = 0;
          for (int i = 0; i < 8; ++i)
            val |= static_cast<int64_t>(
                       static_cast<uint64_t>(blk->data[off + i]) << (i * 8));
          return val;
        };

        if (numRanges > 0 && rangesAddr != 0) {
          // Read range pairs from interpreter memory
          std::vector<int64_t> ranges(numRanges * 2);
          for (int64_t i = 0; i < numRanges * 2; ++i)
            ranges[i] = readI64(rangesAddr + i * 8);

          // Calculate total size across all ranges
          uint64_t totalSize = 0;
          for (int64_t i = 0; i < numRanges; ++i) {
            int64_t low = ranges[i * 2];
            int64_t high = ranges[i * 2 + 1];
            if (low > high)
              std::swap(low, high);
            totalSize += static_cast<uint64_t>(high - low) + 1;
          }

          if (totalSize > 0) {
            // Generate random position in [0, totalSize - 1]
            auto &rng = getObjectRng(lastRandomizeObjAddr);
            uint64_t randomVal = static_cast<uint64_t>(rng());
            if (totalSize > UINT32_MAX)
              randomVal = (static_cast<uint64_t>(rng()) << 32) |
                          static_cast<uint64_t>(rng());
            uint64_t position = randomVal % totalSize;

            // Map position to a specific range and value
            uint64_t accumulated = 0;
            for (int64_t i = 0; i < numRanges; ++i) {
              int64_t low = ranges[i * 2];
              int64_t high = ranges[i * 2 + 1];
              if (low > high)
                std::swap(low, high);
              uint64_t rangeSize = static_cast<uint64_t>(high - low) + 1;
              if (position < accumulated + rangeSize) {
                uint64_t offset = position - accumulated;
                result = low + static_cast<int64_t>(offset);
                break;
              }
              accumulated += rangeSize;
            }
          } else {
            result = ranges[0];
          }
        }
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_randomize_with_ranges(nRanges="
                   << numRanges << ") = " << result << "\n");
      }
      if (callOp.getNumResults() >= 1)
        setValue(procId, callOp.getResult(),
                 InterpretedValue(static_cast<uint64_t>(result), 64));
      return success();
    }

    // ---- Helper lambda: extract Moore string from struct pointer ----
    // (used by fopen, fwrite, fclose)
    auto extractMooreStringFromPtr = [&](Value operand) -> std::string {
      InterpretedValue ptrArg = getValue(procId, operand);
      if (ptrArg.isX())
        return "";

      uint64_t structAddr = ptrArg.getUInt64();
      uint64_t structOffset = 0;
      auto *block =
          findMemoryBlockByAddress(structAddr, procId, &structOffset);
      if (!block || !block->initialized ||
          structOffset + 16 > block->data.size())
        return "";

      // Read ptr (first 8 bytes, little-endian) and len (next 8 bytes)
      uint64_t strPtr = 0;
      int64_t strLen = 0;
      for (int i = 0; i < 8; ++i) {
        strPtr |=
            static_cast<uint64_t>(block->data[structOffset + i]) << (i * 8);
        strLen |= static_cast<int64_t>(block->data[structOffset + 8 + i])
                  << (i * 8);
      }

      if (strPtr == 0 || strLen <= 0)
        return "";

      // Look up in dynamicStrings registry first
      auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
      if (dynIt != dynamicStrings.end() && dynIt->second.first &&
          dynIt->second.second > 0) {
        return std::string(
            dynIt->second.first,
            std::min(static_cast<size_t>(strLen),
                     static_cast<size_t>(dynIt->second.second)));
      }

      // Try global/malloc memory via O(log n) range index
      {
        uint64_t off = 0;
        MemoryBlock *gBlock = findBlockByAddress(strPtr, off);
        if (gBlock && gBlock->initialized) {
          size_t avail = std::min(
              static_cast<size_t>(strLen),
              gBlock->data.size() - static_cast<size_t>(off));
          if (avail > 0)
            return std::string(
                reinterpret_cast<const char *>(gBlock->data.data() + off),
                avail);
        }
      }

      // Try addressToGlobal reverse lookup
      auto globalIt = addressToGlobal.find(strPtr);
      if (globalIt != addressToGlobal.end()) {
        auto blockIt = globalMemoryBlocks.find(globalIt->second);
        if (blockIt != globalMemoryBlocks.end()) {
          const MemoryBlock &gBlock = blockIt->second;
          size_t avail = std::min(static_cast<size_t>(strLen),
                                  gBlock.data.size());
          if (avail > 0 && gBlock.initialized)
            return std::string(
                reinterpret_cast<const char *>(gBlock.data.data()), avail);
        }
      }

      // Try memory block direct lookup for heap-allocated strings
      uint64_t strOffset = 0;
      auto *strBlock =
          findMemoryBlockByAddress(strPtr, procId, &strOffset);
      if (strBlock && strBlock->initialized &&
          strOffset + strLen <= strBlock->data.size()) {
        return std::string(
            reinterpret_cast<const char *>(strBlock->data.data() + strOffset),
            strLen);
      }

      return "";
    };

    // ---- __moore_fopen ----
    if (calleeName == "__moore_fopen") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        std::string filename =
            extractMooreStringFromPtr(callOp.getOperand(0));
        std::string mode =
            extractMooreStringFromPtr(callOp.getOperand(1));
        int32_t fd = 0;
        if (!filename.empty()) {
          if (mode.empty())
            mode = "r";
          // Build MooreString structs for the runtime call
          MooreString fnStr = {const_cast<char *>(filename.c_str()),
                               static_cast<int64_t>(filename.size())};
          MooreString modeStr = {const_cast<char *>(mode.c_str()),
                                 static_cast<int64_t>(mode.size())};
          fd = __moore_fopen(&fnStr, &modeStr);
        }
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(32, static_cast<uint32_t>(fd))));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_fopen(\"" << filename << "\", \""
                   << mode << "\") = " << fd << "\n");
      }
      return success();
    }

    // ---- __moore_fwrite ----
    if (calleeName == "__moore_fwrite") {
      if (callOp.getNumOperands() >= 2) {
        int32_t fd = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(0)).getUInt64());
        std::string message =
            extractMooreStringFromPtr(callOp.getOperand(1));
        if (fd != 0 && !message.empty()) {
          MooreString msgStr = {const_cast<char *>(message.c_str()),
                                static_cast<int64_t>(message.size())};
          __moore_fwrite(fd, &msgStr);
        }
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_fwrite(fd=" << fd << ", \""
                   << message << "\")\n");
      }
      return success();
    }

    // ---- __moore_fclose ----
    if (calleeName == "__moore_fclose") {
      if (callOp.getNumOperands() >= 1) {
        int32_t fd = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(0)).getUInt64());
        if (fd != 0)
          __moore_fclose(fd);
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_fclose(fd=" << fd << ")\n");
      }
      return success();
    }

    //===------------------------------------------------------------------===//
    // String method interceptors
    //===------------------------------------------------------------------===//

    // Helper lambda to read a MooreString from a struct pointer in interpreter
    // memory. Returns the string content as a std::string.
    // This is defined once and reused by all string interceptors below.
    auto readStringFromPtr = [&](Value operand) -> std::string {
      InterpretedValue ptrArg = getValue(procId, operand);
      if (ptrArg.isX())
        return "";

      uint64_t structAddr = ptrArg.getUInt64();
      uint64_t structOffset = 0;
      auto *block = findMemoryBlockByAddress(structAddr, procId, &structOffset);
      if (!block || !block->initialized || structOffset + 16 > block->data.size())
        return "";

      // Read ptr (first 8 bytes, little-endian) and len (next 8 bytes)
      uint64_t strPtr = 0;
      int64_t strLen = 0;
      for (int i = 0; i < 8; ++i) {
        strPtr |= static_cast<uint64_t>(block->data[structOffset + i]) << (i * 8);
        strLen |= static_cast<int64_t>(block->data[structOffset + 8 + i]) << (i * 8);
      }

      if (strPtr == 0 || strLen <= 0)
        return "";

      // Look up in dynamicStrings registry first
      auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
      if (dynIt != dynamicStrings.end() && dynIt->second.first &&
          dynIt->second.second > 0) {
        return std::string(dynIt->second.first,
                           std::min(static_cast<size_t>(strLen),
                                    static_cast<size_t>(dynIt->second.second)));
      }

      // Try global/malloc memory via O(log n) range index
      {
        uint64_t off = 0;
        MemoryBlock *gBlock = findBlockByAddress(strPtr, off);
        if (gBlock && gBlock->initialized) {
          size_t avail = std::min(static_cast<size_t>(strLen),
                                  gBlock->data.size() - static_cast<size_t>(off));
          if (avail > 0)
            return std::string(reinterpret_cast<const char *>(
                                   gBlock->data.data() + off),
                               avail);
        }
      }

      // Try addressToGlobal reverse lookup
      auto globalIt = addressToGlobal.find(strPtr);
      if (globalIt != addressToGlobal.end()) {
        auto blockIt = globalMemoryBlocks.find(globalIt->second);
        if (blockIt != globalMemoryBlocks.end()) {
          const MemoryBlock &gBlock = blockIt->second;
          size_t avail = std::min(static_cast<size_t>(strLen),
                                  gBlock.data.size());
          if (avail > 0 && gBlock.initialized)
            return std::string(reinterpret_cast<const char *>(
                                   gBlock.data.data()),
                               avail);
        }
      }

      // Try finding the data in alloca/malloc blocks directly
      uint64_t strDataOffset = 0;
      auto *strDataBlock = findMemoryBlockByAddress(strPtr, procId, &strDataOffset);
      if (strDataBlock && strDataBlock->initialized &&
          strDataOffset + strLen <= strDataBlock->data.size()) {
        return std::string(
            reinterpret_cast<const char *>(strDataBlock->data.data() + strDataOffset),
            strLen);
      }

      return "";
    };

    // Helper to store a string result and return as packed 128-bit struct
    auto storeStringResult = [&](const std::string &str) {
      interpreterStrings.push_back(str);
      const std::string &stored = interpreterStrings.back();
      int64_t ptrVal = reinterpret_cast<int64_t>(stored.data());
      int64_t lenVal = static_cast<int64_t>(stored.size());
      dynamicStrings[ptrVal] = {stored.data(), lenVal};
      APInt packedResult(128, 0);
      safeInsertBits(packedResult,APInt(64, static_cast<uint64_t>(ptrVal)), 0);
      safeInsertBits(packedResult,APInt(64, static_cast<uint64_t>(lenVal)), 64);
      return InterpretedValue(packedResult);
    };

    // ---- __moore_string_toupper ----
    // Signature: (str_ptr: ptr) -> struct{ptr, i64}
    if (calleeName == "__moore_string_toupper") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        std::string str = readStringFromPtr(callOp.getOperand(0));
        for (auto &c : str)
          c = std::toupper(static_cast<unsigned char>(c));
        setValue(procId, callOp.getResult(), storeStringResult(str));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_toupper() = \""
                                << str << "\"\n");
      }
      return success();
    }

    // ---- __moore_string_tolower ----
    // Signature: (str_ptr: ptr) -> struct{ptr, i64}
    if (calleeName == "__moore_string_tolower") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        std::string str = readStringFromPtr(callOp.getOperand(0));
        for (auto &c : str)
          c = std::tolower(static_cast<unsigned char>(c));
        setValue(procId, callOp.getResult(), storeStringResult(str));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_tolower() = \""
                                << str << "\"\n");
      }
      return success();
    }

    // ---- __moore_string_getc ----
    // Signature: (str_ptr: ptr, index: i32) -> i8
    if (calleeName == "__moore_string_getc") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        std::string str = readStringFromPtr(callOp.getOperand(0));
        int32_t index = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int8_t result = 0;
        if (index >= 0 && index < static_cast<int32_t>(str.size()))
          result = static_cast<int8_t>(str[index]);
        unsigned resultWidth = getTypeWidth(callOp.getResult().getType());
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(resultWidth, static_cast<uint64_t>(result))));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_getc(\"" << str
                                << "\", " << index << ") = " << static_cast<int>(result)
                                << "\n");
      }
      return success();
    }

    // ---- __moore_string_putc ----
    // Signature: (str_ptr: ptr, index: i32, ch: i8) -> struct{ptr, i64}
    if (calleeName == "__moore_string_putc") {
      if (callOp.getNumOperands() >= 3 && callOp.getNumResults() >= 1) {
        std::string str = readStringFromPtr(callOp.getOperand(0));
        int32_t index = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int8_t ch = static_cast<int8_t>(
            getValue(procId, callOp.getOperand(2)).getUInt64());
        // IEEE 1800-2017: putc is a no-op for out of bounds
        if (index >= 0 && index < static_cast<int32_t>(str.size()))
          str[index] = static_cast<char>(ch);
        setValue(procId, callOp.getResult(), storeStringResult(str));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_putc() = \""
                                << str << "\"\n");
      }
      return success();
    }

    // ---- __moore_string_substr ----
    // Signature: (str_ptr: ptr, start: i32, end: i32) -> struct{ptr, i64}
    // IEEE 1800-2017 §6.16.8: substr(i, j) returns characters from index i
    // to j inclusive. The third parameter is an end index, NOT a length.
    if (calleeName == "__moore_string_substr") {
      if (callOp.getNumOperands() >= 3 && callOp.getNumResults() >= 1) {
        std::string str = readStringFromPtr(callOp.getOperand(0));
        int32_t start = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int32_t endIdx = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(2)).getUInt64());
        std::string result;
        if (start >= 0 && start < static_cast<int32_t>(str.size()) &&
            endIdx >= start) {
          size_t count = static_cast<size_t>(endIdx - start + 1);
          size_t actualLen = std::min(count,
                                      str.size() - static_cast<size_t>(start));
          result = str.substr(start, actualLen);
        }
        setValue(procId, callOp.getResult(), storeStringResult(result));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_substr(\"" << str
                                << "\", " << start << ", " << endIdx << ") = \""
                                << result << "\"\n");
      }
      return success();
    }

    // ---- __moore_string_compare ----
    // Signature: (lhs_ptr: ptr, rhs_ptr: ptr) -> i32
    if (calleeName == "__moore_string_compare") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        std::string lhs = readStringFromPtr(callOp.getOperand(0));
        std::string rhs = readStringFromPtr(callOp.getOperand(1));
        int32_t result = 0;
        if (lhs < rhs) result = -1;
        else if (lhs > rhs) result = 1;
        unsigned resultWidth = getTypeWidth(callOp.getResult().getType());
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(resultWidth, static_cast<uint64_t>(static_cast<uint32_t>(result)), false)));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_compare(\"" << lhs
                                << "\", \"" << rhs << "\") = " << result << "\n");
      }
      return success();
    }

    // ---- __moore_string_icompare ----
    // Signature: (lhs_ptr: ptr, rhs_ptr: ptr) -> i32
    if (calleeName == "__moore_string_icompare") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        std::string lhs = readStringFromPtr(callOp.getOperand(0));
        std::string rhs = readStringFromPtr(callOp.getOperand(1));
        // Case-insensitive comparison
        std::string lhsLower = lhs, rhsLower = rhs;
        for (auto &c : lhsLower) c = std::tolower(static_cast<unsigned char>(c));
        for (auto &c : rhsLower) c = std::tolower(static_cast<unsigned char>(c));
        int32_t result = 0;
        if (lhsLower < rhsLower) result = -1;
        else if (lhsLower > rhsLower) result = 1;
        unsigned resultWidth = getTypeWidth(callOp.getResult().getType());
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(resultWidth, static_cast<uint64_t>(static_cast<uint32_t>(result)), false)));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_icompare(\"" << lhs
                                << "\", \"" << rhs << "\") = " << result << "\n");
      }
      return success();
    }

    // ---- __moore_string_replicate ----
    // Signature: (str_ptr: ptr, count: i32) -> struct{ptr, i64}
    if (calleeName == "__moore_string_replicate") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        std::string str = readStringFromPtr(callOp.getOperand(0));
        int32_t count = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        std::string result;
        if (count > 0 && !str.empty()) {
          result.reserve(str.size() * count);
          for (int32_t i = 0; i < count; ++i)
            result += str;
        }
        setValue(procId, callOp.getResult(), storeStringResult(result));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_replicate(\"" << str
                                << "\", " << count << ") = \"" << result << "\"\n");
      }
      return success();
    }

    // ---- __moore_string_to_int ----
    // Signature: (str_ptr: ptr) -> i64
    if (calleeName == "__moore_string_to_int") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        std::string str = readStringFromPtr(callOp.getOperand(0));
        int64_t result = 0;
        if (!str.empty()) {
          { char *endp = nullptr; result = std::strtoll(str.c_str(), &endp, 10); }
        }
        setValue(procId, callOp.getResult(),
                 InterpretedValue(static_cast<uint64_t>(result), 64));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_to_int(\"" << str
                                << "\") = " << result << "\n");
      }
      return success();
    }

    // ---- __moore_string_atoi ----
    // Signature: (str_ptr: ptr) -> i32
    if (calleeName == "__moore_string_atoi") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        std::string str = readStringFromPtr(callOp.getOperand(0));
        int32_t result = 0;
        if (!str.empty()) {
          { char *endp = nullptr; result = static_cast<int32_t>(std::strtol(str.c_str(), &endp, 10)); }
        }
        unsigned resultWidth = getTypeWidth(callOp.getResult().getType());
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(resultWidth, static_cast<uint64_t>(static_cast<uint32_t>(result)), false)));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_atoi(\"" << str
                                << "\") = " << result << "\n");
      }
      return success();
    }

    // ---- __moore_string_atohex ----
    // Signature: (str_ptr: ptr) -> i32
    if (calleeName == "__moore_string_atohex") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        std::string str = readStringFromPtr(callOp.getOperand(0));
        int32_t result = 0;
        if (!str.empty()) {
          { char *endp = nullptr; result = static_cast<int32_t>(std::strtoul(str.c_str(), &endp, 16)); }
        }
        unsigned resultWidth = getTypeWidth(callOp.getResult().getType());
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(resultWidth, static_cast<uint64_t>(static_cast<uint32_t>(result)), false)));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_atohex(\"" << str
                                << "\") = " << result << "\n");
      }
      return success();
    }

    // ---- __moore_string_atooct ----
    // Signature: (str_ptr: ptr) -> i32
    if (calleeName == "__moore_string_atooct") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        std::string str = readStringFromPtr(callOp.getOperand(0));
        int32_t result = 0;
        if (!str.empty()) {
          { char *endp = nullptr; result = static_cast<int32_t>(std::strtoul(str.c_str(), &endp, 8)); }
        }
        unsigned resultWidth = getTypeWidth(callOp.getResult().getType());
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(resultWidth, static_cast<uint64_t>(static_cast<uint32_t>(result)), false)));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_atooct(\"" << str
                                << "\") = " << result << "\n");
      }
      return success();
    }

    // ---- __moore_string_atobin ----
    // Signature: (str_ptr: ptr) -> i32
    if (calleeName == "__moore_string_atobin") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        std::string str = readStringFromPtr(callOp.getOperand(0));
        int32_t result = 0;
        if (!str.empty()) {
          { char *endp = nullptr; result = static_cast<int32_t>(std::strtoul(str.c_str(), &endp, 2)); }
        }
        unsigned resultWidth = getTypeWidth(callOp.getResult().getType());
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(resultWidth, static_cast<uint64_t>(static_cast<uint32_t>(result)), false)));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_atobin(\"" << str
                                << "\") = " << result << "\n");
      }
      return success();
    }

    // ---- __moore_string_atoreal ----
    // Signature: (str_ptr: ptr) -> f64
    if (calleeName == "__moore_string_atoreal") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        std::string str = readStringFromPtr(callOp.getOperand(0));
        double result = 0.0;
        if (!str.empty()) {
          { char *endp = nullptr; result = std::strtod(str.c_str(), &endp); }
        }
        // Store as 64-bit IEEE 754 double
        uint64_t bits;
        std::memcpy(&bits, &result, sizeof(bits));
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(64, bits)));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_atoreal(\"" << str
                                << "\") = " << result << "\n");
      }
      return success();
    }

    // ---- __moore_string_hextoa ----
    // Signature: (value: i64) -> struct{ptr, i64}
    if (calleeName == "__moore_string_hextoa") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        InterpretedValue arg = getValue(procId, callOp.getOperand(0));
        uint64_t value = arg.isX() ? 0 : arg.getUInt64();
        char buffer[32];
        int len = std::snprintf(buffer, sizeof(buffer), "%lx",
                                static_cast<unsigned long>(value));
        std::string result(buffer, len > 0 ? len : 0);
        setValue(procId, callOp.getResult(), storeStringResult(result));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_hextoa("
                                << value << ") = \"" << result << "\"\n");
      }
      return success();
    }

    // ---- __moore_string_octtoa ----
    // Signature: (value: i64) -> struct{ptr, i64}
    if (calleeName == "__moore_string_octtoa") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        InterpretedValue arg = getValue(procId, callOp.getOperand(0));
        uint64_t value = arg.isX() ? 0 : arg.getUInt64();
        char buffer[32];
        int len = std::snprintf(buffer, sizeof(buffer), "%lo",
                                static_cast<unsigned long>(value));
        std::string result(buffer, len > 0 ? len : 0);
        setValue(procId, callOp.getResult(), storeStringResult(result));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_octtoa("
                                << value << ") = \"" << result << "\"\n");
      }
      return success();
    }

    // ---- __moore_string_bintoa ----
    // Signature: (value: i64) -> struct{ptr, i64}
    if (calleeName == "__moore_string_bintoa") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        InterpretedValue arg = getValue(procId, callOp.getOperand(0));
        uint64_t value = arg.isX() ? 0 : arg.getUInt64();
        std::string result;
        if (value == 0) {
          result = "0";
        } else {
          // Find highest set bit
          int highBit = 63;
          while (highBit > 0 && !((value >> highBit) & 1))
            --highBit;
          for (int i = highBit; i >= 0; --i)
            result += ((value >> i) & 1) ? '1' : '0';
        }
        setValue(procId, callOp.getResult(), storeStringResult(result));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_bintoa("
                                << value << ") = \"" << result << "\"\n");
      }
      return success();
    }

    // ---- __moore_string_realtoa ----
    // Signature: (value: f64) -> struct{ptr, i64}
    if (calleeName == "__moore_string_realtoa") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        InterpretedValue arg = getValue(procId, callOp.getOperand(0));
        double value = 0.0;
        if (!arg.isX()) {
          uint64_t bits = arg.getUInt64();
          std::memcpy(&value, &bits, sizeof(value));
        }
        char buffer[64];
        int len = std::snprintf(buffer, sizeof(buffer), "%g", value);
        std::string result(buffer, len > 0 ? len : 0);
        setValue(procId, callOp.getResult(), storeStringResult(result));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_string_realtoa("
                                << value << ") = \"" << result << "\"\n");
      }
      return success();
    }

    //===------------------------------------------------------------------===//
    // Queue method interceptors
    //===------------------------------------------------------------------===//

    // ---- __moore_queue_delete_index ----
    // Signature: (queue_ptr, index: i32, element_size: i64) -> void
    if (calleeName == "__moore_queue_delete_index") {
      if (callOp.getNumOperands() >= 3) {
        uint64_t queueAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        int32_t index = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(2)).getUInt64());

        if (queueAddr != 0 && elemSize > 0) {
          uint64_t queueOffset = 0;
          auto *queueBlock = findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized &&
              queueOffset + 16 <= queueBlock->data.size()) {
            uint64_t dataPtr = 0;
            int64_t queueLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(queueBlock->data[queueOffset + i]) << (i * 8);
            for (int i = 0; i < 8; ++i)
              queueLen |= static_cast<int64_t>(queueBlock->data[queueOffset + 8 + i]) << (i * 8);

            // Bounds check
            if (index >= 0 && index < queueLen && dataPtr != 0) {
              if (queueLen == 1) {
                // Last element - set data to 0 and len to 0
                for (int i = 0; i < 8; ++i)
                  queueBlock->data[queueOffset + i] = 0;
                for (int i = 0; i < 8; ++i)
                  queueBlock->data[queueOffset + 8 + i] = 0;
              } else {
                // Allocate new storage
                int64_t newLen = queueLen - 1;
                uint64_t newDataAddr = globalNextAddress;
                globalNextAddress += newLen * elemSize;
                MemoryBlock newBlock(newLen * elemSize, 64);
                newBlock.initialized = true;

                auto *oldBlock = findMemoryBlockByAddress(dataPtr, procId);
                if (oldBlock && oldBlock->initialized) {
                  // Copy elements before deleted index
                  if (index > 0)
                    std::memcpy(newBlock.data.data(), oldBlock->data.data(),
                                index * elemSize);
                  // Copy elements after deleted index
                  if (index < queueLen - 1)
                    std::memcpy(newBlock.data.data() + index * elemSize,
                                oldBlock->data.data() + (index + 1) * elemSize,
                                (queueLen - index - 1) * elemSize);
                }

                mallocBlocks[newDataAddr] = std::move(newBlock);
                addrRangeIndexDirty = true;

                // Update queue struct
                for (int i = 0; i < 8; ++i)
                  queueBlock->data[queueOffset + i] =
                      static_cast<uint8_t>((newDataAddr >> (i * 8)) & 0xFF);
                for (int i = 0; i < 8; ++i)
                  queueBlock->data[queueOffset + 8 + i] =
                      static_cast<uint8_t>((newLen >> (i * 8)) & 0xFF);
              }
              checkMemoryEventWaiters();
            }

            LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_queue_delete_index("
                                    << "0x" << llvm::format_hex(queueAddr, 16)
                                    << ", " << index << ", " << elemSize << ")\n");
          }
        }
      }
      return success();
    }

    // ---- __moore_queue_insert ----
    // Signature: (queue_ptr, index: i32, element_ptr, element_size: i64) -> void
    if (calleeName == "__moore_queue_insert") {
      if (callOp.getNumOperands() >= 4) {
        uint64_t queueAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        int32_t index = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        uint64_t elemAddr = getValue(procId, callOp.getOperand(2)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(3)).getUInt64());

        if (queueAddr != 0 && elemSize > 0) {
          uint64_t queueOffset = 0;
          auto *queueBlock = findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized &&
              queueOffset + 16 <= queueBlock->data.size()) {
            uint64_t dataPtr = 0;
            int64_t queueLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(queueBlock->data[queueOffset + i]) << (i * 8);
            for (int i = 0; i < 8; ++i)
              queueLen |= static_cast<int64_t>(queueBlock->data[queueOffset + 8 + i]) << (i * 8);

            // Clamp index
            if (index < 0) index = 0;
            if (index > queueLen) index = static_cast<int32_t>(queueLen);

            // Allocate new storage
            int64_t newLen = queueLen + 1;
            uint64_t newDataAddr = globalNextAddress;
            globalNextAddress += newLen * elemSize;
            MemoryBlock newBlock(newLen * elemSize, 64);
            newBlock.initialized = true;

            // Copy elements before insertion point
            if (index > 0 && dataPtr != 0) {
              auto *oldBlock = findMemoryBlockByAddress(dataPtr, procId);
              if (oldBlock && oldBlock->initialized) {
                size_t copySize = std::min(static_cast<size_t>(index * elemSize),
                                           oldBlock->data.size());
                std::memcpy(newBlock.data.data(), oldBlock->data.data(), copySize);
              }
            }

            // Copy new element at insertion index
            uint64_t elemOffset = 0;
            auto *elemBlock = findMemoryBlockByAddress(elemAddr, procId, &elemOffset);
            if (elemBlock && elemBlock->initialized) {
              size_t avail = (elemOffset < elemBlock->data.size())
                  ? elemBlock->data.size() - elemOffset : 0;
              size_t copySize = std::min(static_cast<size_t>(elemSize), avail);
              if (copySize > 0)
                std::memcpy(newBlock.data.data() + index * elemSize,
                            elemBlock->data.data() + elemOffset, copySize);
            }

            // Copy elements after insertion point
            if (index < queueLen && dataPtr != 0) {
              auto *oldBlock = findMemoryBlockByAddress(dataPtr, procId);
              if (oldBlock && oldBlock->initialized) {
                size_t srcOffset = index * elemSize;
                size_t dstOffset = (index + 1) * elemSize;
                size_t copySize = (queueLen - index) * elemSize;
                if (srcOffset + copySize <= oldBlock->data.size() &&
                    dstOffset + copySize <= newBlock.data.size())
                  std::memcpy(newBlock.data.data() + dstOffset,
                              oldBlock->data.data() + srcOffset, copySize);
              }
            }

            mallocBlocks[newDataAddr] = std::move(newBlock);
            addrRangeIndexDirty = true;

            // Update queue struct
            for (int i = 0; i < 8; ++i)
              queueBlock->data[queueOffset + i] =
                  static_cast<uint8_t>((newDataAddr >> (i * 8)) & 0xFF);
            for (int i = 0; i < 8; ++i)
              queueBlock->data[queueOffset + 8 + i] =
                  static_cast<uint8_t>((newLen >> (i * 8)) & 0xFF);

            checkMemoryEventWaiters();

            LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_queue_insert("
                                    << "0x" << llvm::format_hex(queueAddr, 16)
                                    << ", " << index << ", elemSize=" << elemSize
                                    << ", newLen=" << newLen << ")\n");
          }
        }
      }
      return success();
    }

    //===------------------------------------------------------------------===//
    // Associative array method interceptors
    //===------------------------------------------------------------------===//

    // ---- __moore_assoc_delete ----
    // Signature: (array: ptr) -> void
    if (calleeName == "__moore_assoc_delete") {
      if (callOp.getNumOperands() >= 1) {
        uint64_t arrayAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        if (arrayAddr != 0 && validAssocArrayAddresses.contains(arrayAddr)) {
          void *arrayPtr = reinterpret_cast<void *>(arrayAddr);
          __moore_assoc_delete(arrayPtr);
        }
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_delete(0x"
                                << llvm::format_hex(arrayAddr, 16) << ")\n");
      }
      return success();
    }

    // ---- __moore_assoc_copy_into ----
    // Signature: (dst: ptr, src: ptr) -> void
    // Deep-copies all entries from src into dst (in-place).
    if (calleeName == "__moore_assoc_copy_into") {
      if (callOp.getNumOperands() >= 2) {
        uint64_t dstAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        uint64_t srcAddr = getValue(procId, callOp.getOperand(1)).getUInt64();
        bool dstValid = dstAddr != 0 &&
            validAssocArrayAddresses.contains(dstAddr);
        bool srcValid = srcAddr != 0 &&
            validAssocArrayAddresses.contains(srcAddr);
        if (dstValid && srcValid) {
          void *dstPtr = reinterpret_cast<void *>(dstAddr);
          void *srcPtr = reinterpret_cast<void *>(srcAddr);
          __moore_assoc_copy_into(dstPtr, srcPtr);
        }
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_copy_into(dst=0x"
                                << llvm::format_hex(dstAddr, 16) << ", src=0x"
                                << llvm::format_hex(srcAddr, 16) << ")\n");
      }
      return success();
    }

    // ---- __moore_assoc_delete_key ----
    // Signature: (array: ptr, key: ptr) -> void
    if (calleeName == "__moore_assoc_delete_key") {
      if (callOp.getNumOperands() >= 2) {
        uint64_t arrayAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        uint64_t keyAddr = getValue(procId, callOp.getOperand(1)).getUInt64();
        if (arrayAddr != 0 && validAssocArrayAddresses.contains(arrayAddr)) {
          void *arrayPtr = reinterpret_cast<void *>(arrayAddr);
          // Read key from interpreter memory
          uint64_t keyOffset = 0;
          auto *keyBlock = findMemoryBlockByAddress(keyAddr, procId, &keyOffset);
          uint8_t keyBuffer[16] = {0};
          void *keyPtr = keyBuffer;
          MooreString keyString = {nullptr, 0};
          std::string keyStorage;

          if (keyBlock && keyBlock->initialized) {
            size_t maxCopy = std::min<size_t>(16, keyBlock->data.size() - keyOffset);
            std::memcpy(keyBuffer, keyBlock->data.data() + keyOffset, maxCopy);

            auto *header = static_cast<AssocArrayHeader *>(arrayPtr);
            if (header->type == AssocArrayType_StringKey) {
              uint64_t strPtrVal = 0;
              int64_t strLen = 0;
              for (int i = 0; i < 8; ++i) {
                strPtrVal |= static_cast<uint64_t>(keyBuffer[i]) << (i * 8);
                strLen |= static_cast<int64_t>(keyBuffer[8 + i]) << (i * 8);
              }
              if (tryReadStringKey(procId, strPtrVal, strLen, keyStorage)) {
                keyString.data = keyStorage.data();
                keyString.len = keyStorage.size();
                keyPtr = &keyString;
              }
            }
          }

          __moore_assoc_delete_key(arrayPtr, keyPtr);
        }
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_assoc_delete_key(0x"
                                << llvm::format_hex(arrayAddr, 16) << ")\n");
      }
      return success();
    }

    // ---- __moore_dyn_array_new ----
    // Signature: (size: i32) -> struct<(ptr, i64)>
    if (calleeName == "__moore_dyn_array_new") {
      if (callOp.getNumOperands() >= 1 && callOp.getNumResults() >= 1) {
        int32_t size = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(0)).getUInt64());
        MooreQueue result = __moore_dyn_array_new(size);
        auto ptrVal = reinterpret_cast<uint64_t>(result.data);
        auto lenVal = static_cast<uint64_t>(result.len);
        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, ptrVal), 0);
        safeInsertBits(packedResult,APInt(64, lenVal), 64);
        setValue(procId, callOp.getResult(),
                 InterpretedValue(packedResult));
        // Register the allocated memory so that subsequent GEP-based
        // stores/loads through the returned pointer are handled correctly.
        // MooreToCore passes element count but the runtime allocates that
        // many bytes; GEP may index beyond with larger element types, so
        // the native store path will auto-expand as needed.
        if (result.data && size > 0)
          nativeMemoryBlocks[ptrVal] = static_cast<uint64_t>(size);
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_dyn_array_new("
                                << size << ") = {0x"
                                << llvm::format_hex(ptrVal, 16) << ", "
                                << lenVal << "}\n");
      }
      return success();
    }

    // ---- __moore_dyn_array_new_copy ----
    // Signature: (size: i32, init: ptr) -> struct<(ptr, i64)>
    if (calleeName == "__moore_dyn_array_new_copy") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        int32_t size = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(0)).getUInt64());
        uint64_t initAddr =
            getValue(procId, callOp.getOperand(1)).getUInt64();
        MooreQueue result = __moore_dyn_array_new(size);
        if (result.data && initAddr != 0 && size > 0) {
          uint64_t initOffset = 0;
          auto *initBlock =
              findMemoryBlockByAddress(initAddr, procId, &initOffset);
          if (initBlock && initBlock->initialized) {
            size_t avail = initBlock->data.size() - initOffset;
            size_t copySize = std::min<size_t>(size, avail);
            std::memcpy(result.data, initBlock->data.data() + initOffset,
                        copySize);
          } else if (initAddr >= 0x10000000000ULL) {
            std::memcpy(result.data,
                        reinterpret_cast<void *>(initAddr), size);
          }
        }
        auto ptrVal = reinterpret_cast<uint64_t>(result.data);
        auto lenVal = static_cast<uint64_t>(result.len);
        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, ptrVal), 0);
        safeInsertBits(packedResult,APInt(64, lenVal), 64);
        setValue(procId, callOp.getResult(),
                 InterpretedValue(packedResult));
        if (result.data && size > 0)
          nativeMemoryBlocks[ptrVal] = static_cast<uint64_t>(size);
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_dyn_array_new_copy(" << size
                   << ", 0x" << llvm::format_hex(initAddr, 16) << ")\n");
      }
      return success();
    }

    // Helper to build state keys for rand_mode/constraint_mode maps.
    auto makeStateKey = [&](Value classPtrOp, Value nameOp) -> std::string {
      uint64_t classAddr = getValue(procId, classPtrOp).getUInt64();
      const char *name = readCStringFromPtr(nameOp);
      return std::to_string(classAddr) + ":" + (name ? name : "");
    };

    // ---- __moore_is_rand_enabled ----
    // Signature: (classPtr: ptr, propertyName: ptr) -> i32
    if (calleeName == "__moore_is_rand_enabled") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t classAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        // Check "disable all" flag first
        std::string allKey = std::to_string(classAddr) + ":__all__";
        auto allIt = randModeState.find(allKey);
        if (allIt != randModeState.end() && allIt->second == 0) {
          setValue(procId, callOp.getResult(), InterpretedValue(0ULL, 32));
          LLVM_DEBUG(llvm::dbgs()
                     << "  llvm.call: __moore_is_rand_enabled() = 0 (all disabled)\n");
        } else {
          std::string key = makeStateKey(callOp.getOperand(0), callOp.getOperand(1));
          auto it = randModeState.find(key);
          int32_t mode = (it != randModeState.end()) ? it->second : 1;
          setValue(procId, callOp.getResult(),
                   InterpretedValue(static_cast<uint64_t>(mode), 32));
          LLVM_DEBUG(llvm::dbgs()
                     << "  llvm.call: __moore_is_rand_enabled() = " << mode << "\n");
        }
      }
      return success();
    }

    // ---- __moore_rand_mode_get ----
    // Signature: (classPtr: ptr, propertyName: ptr) -> i32
    if (calleeName == "__moore_rand_mode_get") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        std::string key = makeStateKey(callOp.getOperand(0), callOp.getOperand(1));
        auto it = randModeState.find(key);
        int32_t mode = (it != randModeState.end()) ? it->second : 1;
        setValue(procId, callOp.getResult(),
                 InterpretedValue(static_cast<uint64_t>(mode), 32));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_rand_mode_get() = " << mode << "\n");
      }
      return success();
    }

    // ---- __moore_rand_mode_set ----
    // Signature: (classPtr: ptr, propertyName: ptr, mode: i32) -> i32
    if (calleeName == "__moore_rand_mode_set") {
      if (callOp.getNumOperands() >= 3) {
        std::string key = makeStateKey(callOp.getOperand(0), callOp.getOperand(1));
        int32_t mode = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(2)).getUInt64());
        int32_t prevMode = 1;
        auto it = randModeState.find(key);
        if (it != randModeState.end())
          prevMode = it->second;
        randModeState[key] = mode;
        if (callOp.getNumResults() >= 1)
          setValue(procId, callOp.getResult(),
                   InterpretedValue(static_cast<uint64_t>(prevMode), 32));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_rand_mode_set(" << mode
                   << ") prev=" << prevMode << "\n");
      }
      return success();
    }

    // ---- __moore_rand_mode_enable_all ----
    if (calleeName == "__moore_rand_mode_enable_all") {
      if (callOp.getNumOperands() >= 1) {
        uint64_t classAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        std::string allKey = std::to_string(classAddr) + ":__all__";
        randModeState[allKey] = 1;
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_rand_mode_enable_all()\n");
      }
      return success();
    }

    // ---- __moore_rand_mode_disable_all ----
    if (calleeName == "__moore_rand_mode_disable_all") {
      if (callOp.getNumOperands() >= 1) {
        uint64_t classAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        std::string allKey = std::to_string(classAddr) + ":__all__";
        randModeState[allKey] = 0;
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_rand_mode_disable_all()\n");
      }
      return success();
    }

    // ---- __moore_is_constraint_enabled ----
    // Signature: (classPtr: ptr, constraintName: ptr) -> i32
    if (calleeName == "__moore_is_constraint_enabled") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        std::string key = makeStateKey(callOp.getOperand(0), callOp.getOperand(1));
        auto it = constraintModeState.find(key);
        int32_t mode = (it != constraintModeState.end()) ? it->second : 1;
        setValue(procId, callOp.getResult(),
                 InterpretedValue(static_cast<uint64_t>(mode), 32));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_is_constraint_enabled() = " << mode << "\n");
      }
      return success();
    }

    // ---- __moore_constraint_mode_get ----
    // Signature: (classPtr: ptr, constraintName: ptr) -> i32
    if (calleeName == "__moore_constraint_mode_get") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        std::string key = makeStateKey(callOp.getOperand(0), callOp.getOperand(1));
        auto it = constraintModeState.find(key);
        int32_t mode = (it != constraintModeState.end()) ? it->second : 1;
        setValue(procId, callOp.getResult(),
                 InterpretedValue(static_cast<uint64_t>(mode), 32));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_constraint_mode_get() = " << mode << "\n");
      }
      return success();
    }

    // ---- __moore_constraint_mode_set ----
    // Signature: (classPtr: ptr, constraintName: ptr, mode: i32) -> i32
    if (calleeName == "__moore_constraint_mode_set") {
      if (callOp.getNumOperands() >= 3) {
        std::string key = makeStateKey(callOp.getOperand(0), callOp.getOperand(1));
        int32_t mode = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(2)).getUInt64());
        int32_t prevMode = 1;
        auto it = constraintModeState.find(key);
        if (it != constraintModeState.end())
          prevMode = it->second;
        constraintModeState[key] = mode;
        if (callOp.getNumResults() >= 1)
          setValue(procId, callOp.getResult(),
                   InterpretedValue(static_cast<uint64_t>(prevMode), 32));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_constraint_mode_set(" << mode
                   << ") prev=" << prevMode << "\n");
      }
      return success();
    }

    // ---- __moore_constraint_mode_enable_all ----
    if (calleeName == "__moore_constraint_mode_enable_all") {
      if (callOp.getNumOperands() >= 1) {
        uint64_t classAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        std::string allKey = std::to_string(classAddr) + ":__all__";
        constraintModeState[allKey] = 1;
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_constraint_mode_enable_all()\n");
      }
      return success();
    }

    // ---- __moore_constraint_mode_disable_all ----
    if (calleeName == "__moore_constraint_mode_disable_all") {
      if (callOp.getNumOperands() >= 1) {
        uint64_t classAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
        std::string allKey = std::to_string(classAddr) + ":__all__";
        constraintModeState[allKey] = 0;
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_constraint_mode_disable_all()\n");
      }
      return success();
    }

    // ---- __moore_randc_next ----
    // Signature: (fieldPtr: ptr, bitWidth: i64) -> i64
    if (calleeName == "__moore_randc_next") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        int64_t bitWidth = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        uint64_t maxVal = (bitWidth >= 64) ? UINT64_MAX
                                            : ((1ULL << bitWidth) - 1);
        auto &rng = getObjectRng(lastRandomizeObjAddr);
        uint64_t result = static_cast<uint64_t>(rng()) & maxVal;
        setValue(procId, callOp.getResult(),
                 InterpretedValue(result, 64));
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_randc_next(bw="
                                << bitWidth << ") = " << result << "\n");
      }
      return success();
    }

    // ---- __moore_queue_pop_back_ptr ----
    // Signature: (queue_ptr: ptr, result_ptr: ptr, elem_size: i64) -> void
    if (calleeName == "__moore_queue_pop_back_ptr") {
      if (callOp.getNumOperands() >= 3) {
        uint64_t queueAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        uint64_t resultAddr =
            getValue(procId, callOp.getOperand(1)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(2)).getUInt64());

        if (queueAddr != 0 && elemSize > 0) {
          uint64_t queueOffset = 0;
          auto *queueBlock =
              findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized) {
            uint64_t dataPtr = 0;
            int64_t queueLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(
                             queueBlock->data[queueOffset + i])
                         << (i * 8);
            for (int i = 0; i < 8; ++i)
              queueLen |= static_cast<int64_t>(
                              queueBlock->data[queueOffset + 8 + i])
                          << (i * 8);

            if (queueLen > 0 && dataPtr != 0) {
              // Look up queue data via interpreter memory model
              uint64_t dataOffset = 0;
              auto *dataBlock =
                  findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
              if (dataBlock && dataBlock->initialized) {
                // Read last element from data array
                size_t lastElemOff =
                    dataOffset + (queueLen - 1) * elemSize;

                // Write to result_ptr in interpreter memory
                uint64_t resultOffset = 0;
                auto *resultBlock = findMemoryBlockByAddress(
                    resultAddr, procId, &resultOffset);
                if (resultBlock &&
                    lastElemOff + elemSize <= dataBlock->data.size()) {
                  size_t avail =
                      resultBlock->data.size() - resultOffset;
                  size_t copySize =
                      std::min<size_t>(elemSize, avail);
                  std::memcpy(
                      resultBlock->data.data() + resultOffset,
                      dataBlock->data.data() + lastElemOff, copySize);
                  resultBlock->initialized = true;
                }
              }

              // Decrement length
              int64_t newLen = queueLen - 1;
              for (int i = 0; i < 8; ++i)
                queueBlock->data[queueOffset + 8 + i] =
                    static_cast<uint8_t>((newLen >> (i * 8)) & 0xFF);
            }
          }
        }
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_queue_pop_back_ptr(0x"
                   << llvm::format_hex(queueAddr, 16) << ")\n");
        checkMemoryEventWaiters();
      }
      return success();
    }

    // ---- __moore_queue_pop_front_ptr ----
    // Signature: (queue_ptr: ptr, result_ptr: ptr, elem_size: i64) -> void
    if (calleeName == "__moore_queue_pop_front_ptr") {
      if (callOp.getNumOperands() >= 3) {
        uint64_t queueAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        uint64_t resultAddr =
            getValue(procId, callOp.getOperand(1)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(2)).getUInt64());

        if (queueAddr != 0 && elemSize > 0) {
          uint64_t queueOffset = 0;
          auto *queueBlock =
              findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized) {
            uint64_t dataPtr = 0;
            int64_t queueLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(
                             queueBlock->data[queueOffset + i])
                         << (i * 8);
            for (int i = 0; i < 8; ++i)
              queueLen |= static_cast<int64_t>(
                              queueBlock->data[queueOffset + 8 + i])
                          << (i * 8);

            if (queueLen > 0 && dataPtr != 0) {
              // Look up queue data via interpreter memory model
              uint64_t dataOffset = 0;
              auto *dataBlock =
                  findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
              if (dataBlock && dataBlock->initialized) {
                // Write first element to result_ptr
                uint64_t resultOffset = 0;
                auto *resultBlock = findMemoryBlockByAddress(
                    resultAddr, procId, &resultOffset);
                if (resultBlock &&
                    dataOffset + elemSize <= dataBlock->data.size()) {
                  size_t avail =
                      resultBlock->data.size() - resultOffset;
                  size_t copySize =
                      std::min<size_t>(elemSize, avail);
                  std::memcpy(
                      resultBlock->data.data() + resultOffset,
                      dataBlock->data.data() + dataOffset, copySize);
                  resultBlock->initialized = true;
                }

                // Shift remaining elements within the data block
                if (queueLen > 1) {
                  size_t moveSize = (queueLen - 1) * elemSize;
                  if (dataOffset + elemSize + moveSize <=
                      dataBlock->data.size()) {
                    std::memmove(
                        dataBlock->data.data() + dataOffset,
                        dataBlock->data.data() + dataOffset + elemSize,
                        moveSize);
                  }
                }
              }

              // Decrement length
              int64_t newLen = queueLen - 1;
              for (int i = 0; i < 8; ++i)
                queueBlock->data[queueOffset + 8 + i] =
                    static_cast<uint8_t>((newLen >> (i * 8)) & 0xFF);
            }
          }
        }
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_queue_pop_front_ptr(0x"
                   << llvm::format_hex(queueAddr, 16) << ")\n");
        checkMemoryEventWaiters();
      }
      return success();
    }

    // ---- __moore_queue_concat ----
    // Signature: (queues: ptr, count: i64, elem_size: i64)
    //            -> struct<(ptr, i64)>
    if (calleeName == "__moore_queue_concat") {
      if (callOp.getNumOperands() >= 3 && callOp.getNumResults() >= 1) {
        uint64_t queuesAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t count = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(2)).getUInt64());

        // Compute total length
        int64_t totalLen = 0;
        std::vector<std::pair<void *, int64_t>> srcs;
        if (queuesAddr != 0 && count > 0 && elemSize > 0) {
          uint64_t qOff = 0;
          auto *qBlock =
              findMemoryBlockByAddress(queuesAddr, procId, &qOff);
          if (qBlock && qBlock->initialized) {
            for (int64_t i = 0; i < count; ++i) {
              size_t base = qOff + i * 16;
              if (base + 16 > qBlock->data.size())
                break;
              uint64_t dp = 0;
              int64_t ln = 0;
              for (int b = 0; b < 8; ++b)
                dp |= static_cast<uint64_t>(qBlock->data[base + b])
                      << (b * 8);
              for (int b = 0; b < 8; ++b)
                ln |= static_cast<int64_t>(
                           qBlock->data[base + 8 + b])
                      << (b * 8);
              // Only use dp as native pointer if it's in native memory range
              if (dp >= 0x10000000000ULL)
                srcs.push_back({reinterpret_cast<void *>(dp), ln});
              else
                srcs.push_back({nullptr, 0});
              totalLen += ln;
            }
          }
        }

        MooreQueue result = __moore_dyn_array_new(
            static_cast<int32_t>(totalLen * elemSize));
        if (result.data) {
          int64_t offset = 0;
          for (auto &[srcPtr, srcLen] : srcs) {
            if (srcPtr && srcLen > 0) {
              std::memcpy(static_cast<char *>(result.data) +
                              offset * elemSize,
                          srcPtr, srcLen * elemSize);
              offset += srcLen;
            }
          }
          result.len = totalLen;
        }

        auto ptrVal = reinterpret_cast<uint64_t>(result.data);
        auto lenVal = static_cast<uint64_t>(result.len);
        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, ptrVal), 0);
        safeInsertBits(packedResult,APInt(64, lenVal), 64);
        setValue(procId, callOp.getResult(),
                 InterpretedValue(packedResult));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_queue_concat(count="
                   << count << ", totalLen=" << totalLen << ")\n");
      }
      return success();
    }

    // ---- __moore_assoc_last ----
    // Signature: (array: ptr, key_out: ptr) -> i1
    if (calleeName == "__moore_assoc_last") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        uint64_t keyOutAddr =
            getValue(procId, callOp.getOperand(1)).getUInt64();

        if (arrayAddr == 0 || !validAssocArrayAddresses.contains(arrayAddr)) {
          setValue(procId, callOp.getResult(),
                   InterpretedValue(0ULL, 1));
          return success();
        }

        void *arrayPtr = reinterpret_cast<void *>(arrayAddr);
        uint64_t keyOutOffset = 0;
        auto *keyOutBlock =
            findMemoryBlockByAddress(keyOutAddr, procId, &keyOutOffset);

        auto *header = static_cast<AssocArrayHeader *>(arrayPtr);
        bool isStringKey = (header->type == AssocArrayType_StringKey);

        bool result = false;
        if (isStringKey) {
          MooreString keyOut = {nullptr, 0};
          result = __moore_assoc_last(arrayPtr, &keyOut);
          if (result && keyOutBlock &&
              keyOutOffset + 16 <= keyOutBlock->data.size()) {
            uint64_t pv = reinterpret_cast<uint64_t>(keyOut.data);
            int64_t lv = keyOut.len;
            for (int i = 0; i < 8; ++i) {
              keyOutBlock->data[keyOutOffset + i] =
                  static_cast<uint8_t>((pv >> (i * 8)) & 0xFF);
              keyOutBlock->data[keyOutOffset + 8 + i] =
                  static_cast<uint8_t>((lv >> (i * 8)) & 0xFF);
            }
            keyOutBlock->initialized = true;
            // Register the malloc'd string in dynamicStrings so
            // tryReadStringKey can find it in subsequent operations.
            if (keyOut.data && keyOut.len > 0)
              dynamicStrings[pv] = {keyOut.data, keyOut.len};
          }
        } else {
          uint8_t keyBuffer[8] = {0};
          result = __moore_assoc_last(arrayPtr, keyBuffer);
          if (result && keyOutBlock) {
            size_t avail =
                keyOutBlock->data.size() - keyOutOffset;
            size_t copySize = std::min<size_t>(8, avail);
            std::memcpy(keyOutBlock->data.data() + keyOutOffset,
                        keyBuffer, copySize);
            keyOutBlock->initialized = true;
          }
        }

        setValue(procId, callOp.getResult(),
                 InterpretedValue(result ? 1ULL : 0ULL, 1));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_assoc_last(0x"
                   << llvm::format_hex(arrayAddr, 16) << ") = "
                   << result << "\n");
      }
      return success();
    }

    // ---- __moore_assoc_prev ----
    // Signature: (array: ptr, key_ref: ptr) -> i1
    if (calleeName == "__moore_assoc_prev") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        uint64_t keyRefAddr =
            getValue(procId, callOp.getOperand(1)).getUInt64();

        if (arrayAddr == 0 || !validAssocArrayAddresses.contains(arrayAddr)) {
          setValue(procId, callOp.getResult(),
                   InterpretedValue(0ULL, 1));
          return success();
        }

        void *arrayPtr = reinterpret_cast<void *>(arrayAddr);
        uint64_t keyRefOffset = 0;
        auto *keyRefBlock =
            findMemoryBlockByAddress(keyRefAddr, procId, &keyRefOffset);

        auto *header = static_cast<AssocArrayHeader *>(arrayPtr);
        bool isStringKey = (header->type == AssocArrayType_StringKey);

        bool result = false;
        if (isStringKey) {
          MooreString keyRef = {nullptr, 0};
          if (keyRefBlock && keyRefBlock->initialized &&
              keyRefOffset + 16 <= keyRefBlock->data.size()) {
            uint64_t spv = 0;
            int64_t sl = 0;
            for (int i = 0; i < 8; ++i) {
              spv |= static_cast<uint64_t>(
                         keyRefBlock->data[keyRefOffset + i])
                     << (i * 8);
              sl |= static_cast<int64_t>(
                        keyRefBlock->data[keyRefOffset + 8 + i])
                    << (i * 8);
            }
            keyRef.data = reinterpret_cast<char *>(spv);
            keyRef.len = sl;
          }

          result = __moore_assoc_prev(arrayPtr, &keyRef);

          if (result && keyRefBlock &&
              keyRefOffset + 16 <= keyRefBlock->data.size()) {
            uint64_t pv = reinterpret_cast<uint64_t>(keyRef.data);
            int64_t lv = keyRef.len;
            for (int i = 0; i < 8; ++i) {
              keyRefBlock->data[keyRefOffset + i] =
                  static_cast<uint8_t>((pv >> (i * 8)) & 0xFF);
              keyRefBlock->data[keyRefOffset + 8 + i] =
                  static_cast<uint8_t>((lv >> (i * 8)) & 0xFF);
            }
            // Register the malloc'd string in dynamicStrings so
            // tryReadStringKey can find it in subsequent operations.
            if (keyRef.data && keyRef.len > 0)
              dynamicStrings[pv] = {keyRef.data, keyRef.len};
          }
        } else {
          uint8_t keyBuffer[8] = {0};
          if (keyRefBlock && keyRefBlock->initialized) {
            size_t avail =
                keyRefBlock->data.size() - keyRefOffset;
            size_t readSize = std::min<size_t>(8, avail);
            std::memcpy(keyBuffer,
                        keyRefBlock->data.data() + keyRefOffset,
                        readSize);
          }

          result = __moore_assoc_prev(arrayPtr, keyBuffer);

          if (result && keyRefBlock) {
            size_t avail =
                keyRefBlock->data.size() - keyRefOffset;
            size_t copySize = std::min<size_t>(8, avail);
            std::memcpy(keyRefBlock->data.data() + keyRefOffset,
                        keyBuffer, copySize);
          }
        }

        setValue(procId, callOp.getResult(),
                 InterpretedValue(result ? 1ULL : 0ULL, 1));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_assoc_prev(0x"
                   << llvm::format_hex(arrayAddr, 16) << ") = "
                   << result << "\n");
      }
      return success();
    }

    // ---- __moore_stream_concat_bits ----
    // Signature: (queue: ptr, elementBitWidth: i32, isRightToLeft: i1) -> i64
    if (calleeName == "__moore_stream_concat_bits") {
      if (callOp.getNumOperands() >= 3 && callOp.getNumResults() >= 1) {
        uint64_t queueAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int32_t elemBitWidth = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        bool isRightToLeft = getValue(procId, callOp.getOperand(2)).getUInt64() != 0;

        int64_t result = 0;
        if (queueAddr != 0) {
          // Try to read MooreQueue struct from interpreter memory
          uint64_t queueOffset = 0;
          auto *qBlock =
              findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
          if (qBlock && qBlock->initialized &&
              queueOffset + 16 <= qBlock->data.size()) {
            uint64_t dataPtr = 0;
            int64_t queueLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(
                             qBlock->data[queueOffset + i])
                         << (i * 8);
            for (int i = 0; i < 8; ++i)
              queueLen |= static_cast<int64_t>(
                              qBlock->data[queueOffset + 8 + i])
                          << (i * 8);
            if (dataPtr != 0 &&
                (dataPtr >= 0x10000000000ULL ||
                 nativeMemoryBlocks.count(dataPtr))) {
              MooreQueue q;
              q.data = reinterpret_cast<void *>(dataPtr);
              q.len = queueLen;
              result = __moore_stream_concat_bits(
                  &q, elemBitWidth, isRightToLeft);
            }
          } else if (queueAddr >= 0x10000000000ULL) {
            result = __moore_stream_concat_bits(
                reinterpret_cast<MooreQueue *>(queueAddr),
                elemBitWidth, isRightToLeft);
          }
        }

        setValue(procId, callOp.getResult(),
                 InterpretedValue(static_cast<uint64_t>(result), 64));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_stream_concat_bits(bw="
                   << elemBitWidth << ") = " << result << "\n");
      }
      return success();
    }

    // ---- __moore_stream_concat_strings ----
    // Signature: (queue: ptr, isRightToLeft: i1) -> struct<(ptr, i64)>
    if (calleeName == "__moore_stream_concat_strings") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t queueAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        bool isRtl = getValue(procId, callOp.getOperand(1)).getUInt64() != 0;

        MooreString result = {nullptr, 0};
        if (queueAddr != 0) {
          uint64_t qOff = 0;
          auto *qBlock =
              findMemoryBlockByAddress(queueAddr, procId, &qOff);
          if (qBlock && qBlock->initialized &&
              qOff + 16 <= qBlock->data.size()) {
            uint64_t dp = 0;
            int64_t ln = 0;
            for (int i = 0; i < 8; ++i)
              dp |= static_cast<uint64_t>(qBlock->data[qOff + i])
                    << (i * 8);
            for (int i = 0; i < 8; ++i)
              ln |= static_cast<int64_t>(
                        qBlock->data[qOff + 8 + i])
                    << (i * 8);
            if (dp != 0) {
              // Only call native function if dp is a real native pointer,
              // not a synthetic interpreter address. Interpreter addresses
              // are assigned sequentially from a low range and cannot be
              // dereferenced natively.
              if (dp >= 0x10000000000ULL) {
                MooreQueue q;
                q.data = reinterpret_cast<void *>(dp);
                q.len = ln;
                result = __moore_stream_concat_strings(&q, isRtl);
              }
            }
          } else if (queueAddr >= 0x10000000000ULL) {
            result = __moore_stream_concat_strings(
                reinterpret_cast<MooreQueue *>(queueAddr), isRtl);
          }
        }

        auto ptrVal = reinterpret_cast<uint64_t>(result.data);
        auto lenVal = static_cast<uint64_t>(result.len);
        if (result.data)
          dynamicStrings[ptrVal] = {result.data, result.len};
        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, ptrVal), 0);
        safeInsertBits(packedResult,APInt(64, lenVal), 64);
        setValue(procId, callOp.getResult(),
                 InterpretedValue(packedResult));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_stream_concat_strings()\n");
      }
      return success();
    }

    // ---- __moore_stream_unpack_bits ----
    // Signature: (queue: ptr, sourceBits: i64, elementBitWidth: i32,
    //             isRightToLeft: i1) -> void
    if (calleeName == "__moore_stream_unpack_bits") {
      if (callOp.getNumOperands() >= 4) {
        uint64_t queueAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t sourceBits = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int32_t elemBitWidth = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(2)).getUInt64());
        bool isRightToLeft =
            getValue(procId, callOp.getOperand(3)).getUInt64() != 0;

        if (queueAddr != 0 && elemBitWidth > 0) {
          // Check if queue is in native memory
          if (queueAddr >= 0x10000000000ULL) {
            __moore_stream_unpack_bits(
                reinterpret_cast<MooreQueue *>(queueAddr), sourceBits,
                elemBitWidth, isRightToLeft);
          } else {
            // Queue is in interpreter memory - do the unpack manually
            uint64_t queueOffset = 0;
            auto *qBlock =
                findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
            if (qBlock && qBlock->initialized &&
                queueOffset + 16 <= qBlock->data.size()) {
              int64_t numElements = 64 / elemBitWidth;
              if (numElements <= 0)
                numElements = 1;
              int32_t bytesPerElem = (elemBitWidth + 7) / 8;
              int64_t newSize = numElements * bytesPerElem;

              // Allocate new data block in interpreter memory
              uint64_t newDataAddr = globalNextAddress;
              globalNextAddress += newSize;

              MemoryBlock newBlock(newSize, 64);
              newBlock.initialized = true;
              memset(newBlock.data.data(), 0, newSize);

              int64_t elementMask = (elemBitWidth < 64)
                                        ? ((1LL << elemBitWidth) - 1)
                                        : static_cast<int64_t>(-1);

              if (isRightToLeft) {
                int bitPos = 0;
                for (int64_t i = numElements - 1; i >= 0 && bitPos < 64;
                     --i) {
                  int64_t elemVal = (sourceBits >> bitPos) & elementMask;
                  for (int32_t b = 0; b < bytesPerElem && b < 8; ++b)
                    newBlock.data[i * bytesPerElem + b] =
                        static_cast<uint8_t>((elemVal >> (b * 8)) & 0xFF);
                  bitPos += elemBitWidth;
                }
              } else {
                int bitPos = 0;
                for (int64_t i = 0; i < numElements && bitPos < 64; ++i) {
                  int64_t elemVal = (sourceBits >> bitPos) & elementMask;
                  for (int32_t b = 0; b < bytesPerElem && b < 8; ++b)
                    newBlock.data[i * bytesPerElem + b] =
                        static_cast<uint8_t>((elemVal >> (b * 8)) & 0xFF);
                  bitPos += elemBitWidth;
                }
              }

              mallocBlocks[newDataAddr] = std::move(newBlock);
              addrRangeIndexDirty = true;

              // Update queue struct: data ptr and len
              for (int i = 0; i < 8; ++i)
                qBlock->data[queueOffset + i] =
                    static_cast<uint8_t>((newDataAddr >> (i * 8)) & 0xFF);
              for (int i = 0; i < 8; ++i)
                qBlock->data[queueOffset + 8 + i] =
                    static_cast<uint8_t>((numElements >> (i * 8)) & 0xFF);
            }
          }
        }

        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_stream_unpack_bits(bw="
                   << elemBitWidth << ", src=" << sourceBits << ")\n");
      }
      return success();
    }

    // ---- __moore_cross_create ----
    // Signature: (cg: ptr, name: ptr, cp_indices: ptr, num: i32) -> i32
    if (calleeName == "__moore_cross_create") {
      uint64_t cgAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
      void *cg = reinterpret_cast<void *>(cgAddr);
      const char *name = readCStringFromPtr(callOp.getOperand(1));
      int32_t numCps = static_cast<int32_t>(
          getValue(procId, callOp.getOperand(3)).getUInt64());
      // Read cp_indices array from interpreter memory
      uint64_t indicesAddr = getValue(procId, callOp.getOperand(2)).getUInt64();
      std::vector<int32_t> indices(numCps, 0);
      if (indicesAddr != 0) {
        uint64_t off = 0;
        MemoryBlock *block = findMemoryBlockByAddress(indicesAddr, procId, &off);
        if (block && block->initialized) {
          for (int32_t i = 0; i < numCps && off + 4 <= block->data.size(); ++i) {
            int32_t val = 0;
            for (int b = 0; b < 4; ++b)
              val |= static_cast<int32_t>(block->data[off + b]) << (b * 8);
            indices[i] = val;
            off += 4;
          }
        }
      }
      int32_t crossIdx = __moore_cross_create(cg, name, indices.data(), numCps);
      if (callOp.getNumResults() >= 1)
        setValue(procId, callOp.getResult(),
                InterpretedValue(static_cast<uint64_t>(crossIdx), 32));
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_cross_create("
                               << cg << ", \"" << name << "\", ..., "
                               << numCps << ") = " << crossIdx << "\n");
      return success();
    }

    // ---- __moore_cross_sample ----
    // Signature: (cg: ptr, cp_values: ptr, num_values: i32) -> void
    if (calleeName == "__moore_cross_sample") {
      uint64_t cgAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
      void *cg = reinterpret_cast<void *>(cgAddr);
      int32_t numValues = static_cast<int32_t>(
          getValue(procId, callOp.getOperand(2)).getUInt64());
      // Read cp_values array (i64 elements) from interpreter memory
      uint64_t valuesAddr = getValue(procId, callOp.getOperand(1)).getUInt64();
      std::vector<int64_t> values(numValues, 0);
      if (valuesAddr != 0) {
        uint64_t off = 0;
        MemoryBlock *block = findMemoryBlockByAddress(valuesAddr, procId, &off);
        if (block && block->initialized) {
          for (int32_t i = 0; i < numValues && off + 8 <= block->data.size(); ++i) {
            int64_t val = 0;
            for (int b = 0; b < 8; ++b)
              val |= static_cast<int64_t>(block->data[off + b]) << (b * 8);
            values[i] = val;
            off += 8;
          }
        }
      }
      __moore_cross_sample(cg, values.data(), numValues);
      LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_cross_sample("
                               << cg << ", ..., " << numValues << ")\n");
      return success();
    }

    // ---- __moore_cross_add_named_bin ----
    // Signature: (cg: ptr, cross_index: i32, name: ptr, kind: i32,
    //             filters: ptr, num_filters: i32) -> i32
    if (calleeName == "__moore_cross_add_named_bin") {
      uint64_t cgAddr = getValue(procId, callOp.getOperand(0)).getUInt64();
      void *cg = reinterpret_cast<void *>(cgAddr);
      int32_t crossIdx = static_cast<int32_t>(
          getValue(procId, callOp.getOperand(1)).getUInt64());
      const char *name = readCStringFromPtr(callOp.getOperand(2));
      int32_t kind = static_cast<int32_t>(
          getValue(procId, callOp.getOperand(3)).getUInt64());
      // Pass NULL filters for now (named bins without complex filters)
      int32_t numFilters = 0;
      if (callOp.getNumOperands() >= 6)
        numFilters = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(5)).getUInt64());
      int32_t binIdx = __moore_cross_add_named_bin(
          cg, crossIdx, name, kind, nullptr, numFilters);
      if (callOp.getNumResults() >= 1)
        setValue(procId, callOp.getResult(),
                InterpretedValue(static_cast<uint64_t>(binIdx), 32));
      LLVM_DEBUG(llvm::dbgs()
                 << "  llvm.call: __moore_cross_add_named_bin("
                 << cg << ", " << crossIdx << ", \"" << name << "\", "
                 << kind << ") = " << binIdx << "\n");
      return success();
    }

    // ---- __moore_queue_slice ----
    // Signature: (queue: ptr, start: i64, end: i64, elem_size: i64)
    //            -> struct<(ptr, i64)>
    if (calleeName == "__moore_queue_slice") {
      if (callOp.getNumOperands() >= 4 && callOp.getNumResults() >= 1) {
        uint64_t queueAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t start = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int64_t end = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(2)).getUInt64());
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(3)).getUInt64());

        MooreQueue result = {nullptr, 0};
        if (queueAddr != 0 && elemSize > 0 && end >= start) {
          uint64_t qOff = 0;
          auto *qBlock =
              findMemoryBlockByAddress(queueAddr, procId, &qOff);
          if (qBlock && qBlock->initialized &&
              qOff + 16 <= qBlock->data.size()) {
            uint64_t dp = 0;
            int64_t ln = 0;
            for (int i = 0; i < 8; ++i)
              dp |= static_cast<uint64_t>(qBlock->data[qOff + i])
                    << (i * 8);
            for (int i = 0; i < 8; ++i)
              ln |= static_cast<int64_t>(
                        qBlock->data[qOff + 8 + i])
                    << (i * 8);
            int64_t sliceLen = std::min(end, ln) - start;
            if (sliceLen > 0 && dp != 0 && dp >= 0x10000000000ULL) {
              result = __moore_dyn_array_new(
                  static_cast<int32_t>(sliceLen * elemSize));
              if (result.data) {
                std::memcpy(result.data,
                            static_cast<char *>(
                                reinterpret_cast<void *>(dp)) +
                                start * elemSize,
                            sliceLen * elemSize);
                result.len = sliceLen;
              }
            }
          }
        }

        auto ptrVal = reinterpret_cast<uint64_t>(result.data);
        auto lenVal = static_cast<uint64_t>(result.len);
        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, ptrVal), 0);
        safeInsertBits(packedResult,APInt(64, lenVal), 64);
        setValue(procId, callOp.getResult(),
                 InterpretedValue(packedResult));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_queue_slice()\n");
      }
      return success();
    }

    // ---- __moore_queue_sort ----
    // Signature: (queue: ptr) -> void
    // Sorts queue elements in ascending order using unsigned little-endian
    // comparison. Element size is inferred from the data block allocation.
    if (calleeName == "__moore_queue_sort") {
      if (callOp.getNumOperands() >= 1) {
        uint64_t queueAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();

        if (queueAddr != 0) {
          // For native pointers, delegate to runtime sort_inplace
          if (queueAddr >= 0x10000000000ULL) {
            auto *nativeQueue =
                reinterpret_cast<MooreQueue *>(queueAddr);
            if (nativeQueue && nativeQueue->data && nativeQueue->len > 1) {
              __moore_queue_sort_inplace(nativeQueue, 8);
            }
            LLVM_DEBUG(llvm::dbgs()
                       << "  llvm.call: __moore_queue_sort(native 0x"
                       << llvm::format_hex(queueAddr, 16) << ")\n");
          } else {
            // Interpreter-managed memory
            uint64_t queueOffset = 0;
            auto *queueBlock =
                findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
            if (queueBlock && queueBlock->initialized &&
                queueOffset + 16 <= queueBlock->data.size()) {
              // Read data pointer and length from queue struct
              // Layout: [ptr data @0, i64 len @8]
              uint64_t dataPtr = 0;
              int64_t queueLen = 0;
              for (int i = 0; i < 8; ++i)
                dataPtr |= static_cast<uint64_t>(
                               queueBlock->data[queueOffset + i])
                           << (i * 8);
              for (int i = 0; i < 8; ++i)
                queueLen |= static_cast<int64_t>(
                                queueBlock->data[queueOffset + 8 + i])
                            << (i * 8);

              if (queueLen > 1 && dataPtr != 0) {
                // Check if data is in a tracked native memory block
                // (from malloc in interceptors like queue_unique)
                auto nmIt = nativeMemoryBlocks.find(dataPtr);
                bool isNativeData = (dataPtr >= 0x10000000000ULL) ||
                                    (nmIt != nativeMemoryBlocks.end());
                if (isNativeData) {
                  // Data is in native memory but queue struct is interpreted
                  // Infer element size from tracked native memory block
                  int64_t nativeElemSize = 8; // default
                  if (nmIt != nativeMemoryBlocks.end() && queueLen > 0) {
                    nativeElemSize = static_cast<int64_t>(nmIt->second) /
                                    queueLen;
                    if (nativeElemSize <= 0)
                      nativeElemSize = 8;
                  }
                  MooreQueue tmpQ;
                  tmpQ.data = reinterpret_cast<void *>(dataPtr);
                  tmpQ.len = queueLen;
                  __moore_queue_sort_inplace(&tmpQ, nativeElemSize);
                } else {
                  // Both queue and data are in interpreter memory.
                  // Infer element size from data block size / queue length.
                  uint64_t dataOffset = 0;
                  auto *dataBlock =
                      findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
                  if (dataBlock && dataBlock->initialized &&
                      dataBlock->data.size() > 0) {
                    int64_t availableSize = static_cast<int64_t>(
                        dataBlock->data.size() - dataOffset);
                    int64_t elemSize = availableSize / queueLen;
                    if (elemSize > 0) {
                      uint8_t *base = dataBlock->data.data() + dataOffset;
                      // Copy elements into a sortable vector
                      std::vector<std::vector<uint8_t>> elements(queueLen);
                      for (int64_t i = 0; i < queueLen; ++i) {
                        elements[i].assign(base + i * elemSize,
                                           base + (i + 1) * elemSize);
                      }
                      // Sort ascending using unsigned little-endian comparison
                      std::sort(
                          elements.begin(), elements.end(),
                          [elemSize](const std::vector<uint8_t> &a,
                                     const std::vector<uint8_t> &b) {
                            // Compare from most significant byte down
                            for (int64_t j = elemSize - 1; j >= 0; --j) {
                              if (a[j] != b[j])
                                return a[j] < b[j];
                            }
                            return false;
                          });
                      // Write sorted elements back in-place
                      for (int64_t i = 0; i < queueLen; ++i) {
                        std::memcpy(base + i * elemSize, elements[i].data(),
                                    elemSize);
                      }
                    }
                  }
                }
              }

              LLVM_DEBUG(llvm::dbgs()
                         << "  llvm.call: __moore_queue_sort(0x"
                         << llvm::format_hex(queueAddr, 16)
                         << ", len=" << queueLen << ")\n");
            }
          }
        }
      }
      return success();
    }

    // ---- __moore_queue_rsort ----
    // Signature: (queue: ptr) -> void
    // Sorts queue elements in descending order.
    if (calleeName == "__moore_queue_rsort") {
      if (callOp.getNumOperands() >= 1) {
        uint64_t queueAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();

        if (queueAddr != 0) {
          if (queueAddr >= 0x10000000000ULL) {
            auto *nativeQueue =
                reinterpret_cast<MooreQueue *>(queueAddr);
            if (nativeQueue && nativeQueue->data && nativeQueue->len > 1) {
              __moore_queue_rsort(nativeQueue, 8);
            }
            LLVM_DEBUG(llvm::dbgs()
                       << "  llvm.call: __moore_queue_rsort(native 0x"
                       << llvm::format_hex(queueAddr, 16) << ")\n");
          } else {
            uint64_t queueOffset = 0;
            auto *queueBlock =
                findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
            if (queueBlock && queueBlock->initialized &&
                queueOffset + 16 <= queueBlock->data.size()) {
              uint64_t dataPtr = 0;
              int64_t queueLen = 0;
              for (int i = 0; i < 8; ++i)
                dataPtr |= static_cast<uint64_t>(
                               queueBlock->data[queueOffset + i])
                           << (i * 8);
              for (int i = 0; i < 8; ++i)
                queueLen |= static_cast<int64_t>(
                                queueBlock->data[queueOffset + 8 + i])
                            << (i * 8);

              if (queueLen > 1 && dataPtr != 0) {
                auto nmItR = nativeMemoryBlocks.find(dataPtr);
                bool isNativeR = (dataPtr >= 0x10000000000ULL) ||
                                 (nmItR != nativeMemoryBlocks.end());
                if (isNativeR) {
                  int64_t nativeElemSize = 8;
                  if (nmItR != nativeMemoryBlocks.end() && queueLen > 0) {
                    nativeElemSize = static_cast<int64_t>(nmItR->second) /
                                    queueLen;
                    if (nativeElemSize <= 0)
                      nativeElemSize = 8;
                  }
                  MooreQueue tmpQ;
                  tmpQ.data = reinterpret_cast<void *>(dataPtr);
                  tmpQ.len = queueLen;
                  __moore_queue_rsort(&tmpQ, nativeElemSize);
                } else {
                  uint64_t dataOffset = 0;
                  auto *dataBlock =
                      findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
                  if (dataBlock && dataBlock->initialized &&
                      dataBlock->data.size() > 0) {
                    int64_t availableSize = static_cast<int64_t>(
                        dataBlock->data.size() - dataOffset);
                    int64_t elemSize = availableSize / queueLen;
                    if (elemSize > 0) {
                      uint8_t *base = dataBlock->data.data() + dataOffset;
                      std::vector<std::vector<uint8_t>> elements(queueLen);
                      for (int64_t i = 0; i < queueLen; ++i) {
                        elements[i].assign(base + i * elemSize,
                                           base + (i + 1) * elemSize);
                      }
                      // Sort descending
                      std::sort(
                          elements.begin(), elements.end(),
                          [elemSize](const std::vector<uint8_t> &a,
                                     const std::vector<uint8_t> &b) {
                            for (int64_t j = elemSize - 1; j >= 0; --j) {
                              if (a[j] != b[j])
                                return a[j] > b[j];
                            }
                            return false;
                          });
                      for (int64_t i = 0; i < queueLen; ++i) {
                        std::memcpy(base + i * elemSize, elements[i].data(),
                                    elemSize);
                      }
                    }
                  }
                }
              }

              LLVM_DEBUG(llvm::dbgs()
                         << "  llvm.call: __moore_queue_rsort(0x"
                         << llvm::format_hex(queueAddr, 16)
                         << ", len=" << queueLen << ")\n");
            }
          }
        }
      }
      return success();
    }

    // ---- __moore_queue_shuffle ----
    // Signature: (queue: ptr) -> void
    // Randomly shuffles queue elements using Fisher-Yates algorithm.
    if (calleeName == "__moore_queue_shuffle") {
      if (callOp.getNumOperands() >= 1) {
        uint64_t queueAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();

        if (queueAddr != 0) {
          if (queueAddr >= 0x10000000000ULL) {
            auto *nativeQueue =
                reinterpret_cast<MooreQueue *>(queueAddr);
            if (nativeQueue && nativeQueue->data && nativeQueue->len > 1) {
              // Fisher-Yates shuffle using per-process RNG for random
              // stability instead of __moore_queue_shuffle (std::rand).
              auto *data = static_cast<char *>(nativeQueue->data);
              int64_t len = nativeQueue->len;
              int64_t elemSize = 8;
              auto &rng = processStates[procId].randomGenerator;
              std::vector<char> temp(elemSize);
              for (int64_t i = len - 1; i > 0; --i) {
                std::uniform_int_distribution<int64_t> dist(0, i);
                int64_t j = dist(rng);
                if (i != j) {
                  std::memcpy(temp.data(), data + i * elemSize, elemSize);
                  std::memcpy(data + i * elemSize, data + j * elemSize,
                              elemSize);
                  std::memcpy(data + j * elemSize, temp.data(), elemSize);
                }
              }
            }
            LLVM_DEBUG(llvm::dbgs()
                       << "  llvm.call: __moore_queue_shuffle(native 0x"
                       << llvm::format_hex(queueAddr, 16) << ")\n");
          } else {
            uint64_t queueOffset = 0;
            auto *queueBlock =
                findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
            if (queueBlock && queueBlock->initialized &&
                queueOffset + 16 <= queueBlock->data.size()) {
              uint64_t dataPtr = 0;
              int64_t queueLen = 0;
              for (int i = 0; i < 8; ++i)
                dataPtr |= static_cast<uint64_t>(
                               queueBlock->data[queueOffset + i])
                           << (i * 8);
              for (int i = 0; i < 8; ++i)
                queueLen |= static_cast<int64_t>(
                                queueBlock->data[queueOffset + 8 + i])
                            << (i * 8);

              if (queueLen > 1 && dataPtr != 0) {
                auto nmItS = nativeMemoryBlocks.find(dataPtr);
                bool isNativeS = (dataPtr >= 0x10000000000ULL) ||
                                 (nmItS != nativeMemoryBlocks.end());
                if (isNativeS) {
                  int64_t nativeElemSize = 8;
                  if (nmItS != nativeMemoryBlocks.end() && queueLen > 0) {
                    nativeElemSize = static_cast<int64_t>(nmItS->second) /
                                    queueLen;
                    if (nativeElemSize <= 0)
                      nativeElemSize = 8;
                  }
                  // Fisher-Yates shuffle using per-process RNG for
                  // random stability instead of __moore_queue_shuffle
                  // which uses std::rand().
                  {
                    auto *data = reinterpret_cast<char *>(dataPtr);
                    auto &rng = processStates[procId].randomGenerator;
                    std::vector<char> temp(nativeElemSize);
                    for (int64_t i = queueLen - 1; i > 0; --i) {
                      std::uniform_int_distribution<int64_t> dist(0, i);
                      int64_t j = dist(rng);
                      if (i != j) {
                        std::memcpy(temp.data(), data + i * nativeElemSize,
                                    nativeElemSize);
                        std::memcpy(data + i * nativeElemSize,
                                    data + j * nativeElemSize, nativeElemSize);
                        std::memcpy(data + j * nativeElemSize, temp.data(),
                                    nativeElemSize);
                      }
                    }
                  }
                } else {
                  uint64_t dataOffset = 0;
                  auto *dataBlock =
                      findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
                  if (dataBlock && dataBlock->initialized &&
                      dataBlock->data.size() > 0) {
                    int64_t availableSize = static_cast<int64_t>(
                        dataBlock->data.size() - dataOffset);
                    int64_t elemSize = availableSize / queueLen;
                    if (elemSize > 0) {
                      uint8_t *base = dataBlock->data.data() + dataOffset;
                      // Fisher-Yates shuffle using per-process RNG for
                      // random stability (IEEE 1800-2017 §18.14).
                      auto &rng = processStates[procId].randomGenerator;
                      std::vector<uint8_t> temp(elemSize);
                      for (int64_t i = queueLen - 1; i > 0; --i) {
                        std::uniform_int_distribution<int64_t> dist(0, i);
                        int64_t j = dist(rng);
                        if (i != j) {
                          std::memcpy(temp.data(), base + i * elemSize,
                                      elemSize);
                          std::memcpy(base + i * elemSize,
                                      base + j * elemSize, elemSize);
                          std::memcpy(base + j * elemSize, temp.data(),
                                      elemSize);
                        }
                      }
                    }
                  }
                }
              }

              LLVM_DEBUG(llvm::dbgs()
                         << "  llvm.call: __moore_queue_shuffle(0x"
                         << llvm::format_hex(queueAddr, 16)
                         << ", len=" << queueLen << ")\n");
            }
          }
        }
      }
      return success();
    }

    // ---- __moore_queue_reverse ----
    // Signature: (queue: ptr) -> void
    // Reverses queue elements in-place.
    if (calleeName == "__moore_queue_reverse") {
      if (callOp.getNumOperands() >= 1) {
        uint64_t queueAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();

        if (queueAddr != 0) {
          if (queueAddr >= 0x10000000000ULL) {
            auto *nativeQueue =
                reinterpret_cast<MooreQueue *>(queueAddr);
            if (nativeQueue && nativeQueue->data && nativeQueue->len > 1) {
              __moore_queue_reverse(nativeQueue, 8);
            }
            LLVM_DEBUG(llvm::dbgs()
                       << "  llvm.call: __moore_queue_reverse(native 0x"
                       << llvm::format_hex(queueAddr, 16) << ")\n");
          } else {
            uint64_t queueOffset = 0;
            auto *queueBlock =
                findMemoryBlockByAddress(queueAddr, procId, &queueOffset);
            if (queueBlock && queueBlock->initialized &&
                queueOffset + 16 <= queueBlock->data.size()) {
              uint64_t dataPtr = 0;
              int64_t queueLen = 0;
              for (int i = 0; i < 8; ++i)
                dataPtr |= static_cast<uint64_t>(
                               queueBlock->data[queueOffset + i])
                           << (i * 8);
              for (int i = 0; i < 8; ++i)
                queueLen |= static_cast<int64_t>(
                                queueBlock->data[queueOffset + 8 + i])
                            << (i * 8);

              if (queueLen > 1 && dataPtr != 0) {
                auto nmItV = nativeMemoryBlocks.find(dataPtr);
                bool isNativeV = (dataPtr >= 0x10000000000ULL) ||
                                 (nmItV != nativeMemoryBlocks.end());
                if (isNativeV) {
                  int64_t nativeElemSize = 8;
                  if (nmItV != nativeMemoryBlocks.end() && queueLen > 0) {
                    nativeElemSize = static_cast<int64_t>(nmItV->second) /
                                    queueLen;
                    if (nativeElemSize <= 0)
                      nativeElemSize = 8;
                  }
                  MooreQueue tmpQ;
                  tmpQ.data = reinterpret_cast<void *>(dataPtr);
                  tmpQ.len = queueLen;
                  __moore_queue_reverse(&tmpQ, nativeElemSize);
                } else {
                  uint64_t dataOffset = 0;
                  auto *dataBlock =
                      findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
                  if (dataBlock && dataBlock->initialized &&
                      dataBlock->data.size() > 0) {
                    int64_t availableSize = static_cast<int64_t>(
                        dataBlock->data.size() - dataOffset);
                    int64_t elemSize = availableSize / queueLen;
                    if (elemSize > 0) {
                      uint8_t *base = dataBlock->data.data() + dataOffset;
                      std::vector<uint8_t> temp(elemSize);
                      int64_t left = 0, right = queueLen - 1;
                      while (left < right) {
                        std::memcpy(temp.data(), base + left * elemSize,
                                    elemSize);
                        std::memcpy(base + left * elemSize,
                                    base + right * elemSize, elemSize);
                        std::memcpy(base + right * elemSize, temp.data(),
                                    elemSize);
                        ++left;
                        --right;
                      }
                    }
                  }
                }
              }

              LLVM_DEBUG(llvm::dbgs()
                         << "  llvm.call: __moore_queue_reverse(0x"
                         << llvm::format_hex(queueAddr, 16)
                         << ", len=" << queueLen << ")\n");
            }
          }
        }
      }
      return success();
    }

    // ---- __moore_queue_unique ----
    // Signature: (queue: ptr) -> struct<(ptr, i64)>
    if (calleeName == "__moore_queue_unique") {
      if (callOp.getNumResults() >= 1) {
        uint64_t queueAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        MooreQueue result = {nullptr, 0};
        if (queueAddr >= 0x10000000000ULL) {
          result = __moore_queue_unique(
              reinterpret_cast<MooreQueue *>(queueAddr));
        } else if (queueAddr != 0) {
          // Interpreter-managed queue: read struct {ptr, i64} from memory
          uint64_t qOff = 0;
          auto *qBlock = findMemoryBlockByAddress(queueAddr, procId, &qOff);
          if (qBlock) {
            uint64_t dataPtr = 0;
            int64_t queueLen = 0;
            if (qOff + 16 <= qBlock->data.size()) {
              std::memcpy(&dataPtr, qBlock->data.data() + qOff, 8);
              std::memcpy(&queueLen, qBlock->data.data() + qOff + 8, 8);
            }
            if (dataPtr != 0 && queueLen > 0) {
              // Read element data
              std::vector<uint8_t> elemData;
              int64_t elemSize = 0;
              // Check if data is in a native memory block (malloc or
              // nativeMemoryBlocks) or interpreter-managed memory
              auto nmItU = nativeMemoryBlocks.find(dataPtr);
              bool isNativeU = (dataPtr >= 0x10000000000ULL) ||
                               (nmItU != nativeMemoryBlocks.end());
              if (isNativeU) {
                // Native data pointer - infer element size from tracked
                // block if available, otherwise default to 4 (int)
                if (nmItU != nativeMemoryBlocks.end() && queueLen > 0) {
                  elemSize = static_cast<int64_t>(nmItU->second) /
                             queueLen;
                }
                if (elemSize <= 0)
                  elemSize = 4; // common case for int queues
                elemData.resize(queueLen * elemSize);
                std::memcpy(elemData.data(),
                            reinterpret_cast<void *>(dataPtr),
                            queueLen * elemSize);
              } else {
                uint64_t dOff = 0;
                auto *dataBlock =
                    findMemoryBlockByAddress(dataPtr, procId, &dOff);
                if (dataBlock) {
                  size_t available = dataBlock->data.size() - dOff;
                  elemSize = (queueLen > 0)
                                 ? static_cast<int64_t>(available / queueLen)
                                 : 0;
                  if (elemSize > 0) {
                    elemData.resize(queueLen * elemSize);
                    std::memcpy(elemData.data(),
                                dataBlock->data.data() + dOff,
                                queueLen * elemSize);
                  }
                }
              }
              if (elemSize > 0 && !elemData.empty()) {
                // Deduplicate: for each element, check if already in result
                std::vector<uint8_t> uniqueData;
                int64_t uniqueLen = 0;
                for (int64_t i = 0; i < queueLen; ++i) {
                  uint8_t *elem = elemData.data() + i * elemSize;
                  bool found = false;
                  for (int64_t j = 0; j < uniqueLen; ++j) {
                    if (std::memcmp(uniqueData.data() + j * elemSize, elem,
                                    elemSize) == 0) {
                      found = true;
                      break;
                    }
                  }
                  if (!found) {
                    uniqueData.insert(uniqueData.end(), elem,
                                      elem + elemSize);
                    ++uniqueLen;
                  }
                }
                // Allocate native memory for result
                if (uniqueLen > 0) {
                  void *nativeData =
                      std::malloc(uniqueLen * elemSize);
                  if (nativeData) {
                    std::memcpy(nativeData, uniqueData.data(),
                                uniqueLen * elemSize);
                    result.data = nativeData;
                    result.len = uniqueLen;
                    // Register in nativeMemoryBlocks so loads can find it
                    uint64_t nativeAddr =
                        reinterpret_cast<uint64_t>(nativeData);
                    nativeMemoryBlocks[nativeAddr] =
                        uniqueLen * elemSize;
                  }
                }
              }
            }
          }
        }
        auto ptrVal = reinterpret_cast<uint64_t>(result.data);
        auto lenVal = static_cast<uint64_t>(result.len);
        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, ptrVal), 0);
        safeInsertBits(packedResult,APInt(64, lenVal), 64);
        setValue(procId, callOp.getResult(),
                 InterpretedValue(packedResult));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_queue_unique() -> len="
                   << result.len << "\n");
      }
      return success();
    }

    // ---- __moore_array_max ----
    // Signature: (array: ptr, elemSize: i64, isSigned: i32)
    //            -> struct<(ptr, i64)>
    if (calleeName == "__moore_array_max") {
      if (callOp.getNumOperands() >= 3 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int32_t isSigned = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(2)).getUInt64());
        MooreQueue result = {nullptr, 0};
        if (arrayAddr >= 0x10000000000ULL) {
          result = __moore_array_max(
              reinterpret_cast<MooreQueue *>(arrayAddr),
              elemSize, isSigned);
        } else if (arrayAddr != 0) {
          // Interpreter-managed memory: read queue struct {ptr, len}
          uint64_t queueOffset = 0;
          auto *queueBlock =
              findMemoryBlockByAddress(arrayAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized &&
              queueOffset + 16 <= queueBlock->data.size()) {
            uint64_t dataPtr = 0;
            int64_t arrLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(
                             queueBlock->data[queueOffset + i])
                         << (i * 8);
            for (int i = 0; i < 8; ++i)
              arrLen |= static_cast<int64_t>(
                            queueBlock->data[queueOffset + 8 + i])
                        << (i * 8);
            if (arrLen > 0 && dataPtr != 0) {
              auto nmIt = nativeMemoryBlocks.find(dataPtr);
              bool isNativeData = (dataPtr >= 0x10000000000ULL) ||
                                  (nmIt != nativeMemoryBlocks.end());
              if (isNativeData) {
                MooreQueue tmpQ;
                tmpQ.data = reinterpret_cast<void *>(dataPtr);
                tmpQ.len = arrLen;
                result = __moore_array_max(&tmpQ, elemSize, isSigned);
              } else {
                uint64_t dataOffset = 0;
                auto *dataBlock =
                    findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
                if (dataBlock && dataBlock->initialized) {
                  uint8_t *base = dataBlock->data.data() + dataOffset;
                  // Build a temporary native queue from interpreter data
                  std::vector<uint8_t> tmpData(arrLen * elemSize);
                  std::memcpy(tmpData.data(), base, arrLen * elemSize);
                  MooreQueue tmpQ;
                  tmpQ.data = tmpData.data();
                  tmpQ.len = arrLen;
                  result = __moore_array_max(&tmpQ, elemSize, isSigned);
                }
              }
            }
          }
        }
        auto ptrVal = reinterpret_cast<uint64_t>(result.data);
        auto lenVal = static_cast<uint64_t>(result.len);
        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, ptrVal), 0);
        safeInsertBits(packedResult,APInt(64, lenVal), 64);
        setValue(procId, callOp.getResult(),
                 InterpretedValue(packedResult));
        if (result.data && result.len > 0) {
          nativeMemoryBlocks[ptrVal] =
              static_cast<size_t>(result.len * elemSize);
        }
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_array_max()\n");
      }
      return success();
    }

    // ---- __moore_array_min ----
    // Signature: (array: ptr, elemSize: i64, isSigned: i32)
    //            -> struct<(ptr, i64)>
    if (calleeName == "__moore_array_min") {
      if (callOp.getNumOperands() >= 3 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int32_t isSigned = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(2)).getUInt64());
        MooreQueue result = {nullptr, 0};
        if (arrayAddr >= 0x10000000000ULL) {
          result = __moore_array_min(
              reinterpret_cast<MooreQueue *>(arrayAddr),
              elemSize, isSigned);
        } else if (arrayAddr != 0) {
          // Interpreter-managed memory: read queue struct {ptr, len}
          uint64_t queueOffset = 0;
          auto *queueBlock =
              findMemoryBlockByAddress(arrayAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized &&
              queueOffset + 16 <= queueBlock->data.size()) {
            uint64_t dataPtr = 0;
            int64_t arrLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(
                             queueBlock->data[queueOffset + i])
                         << (i * 8);
            for (int i = 0; i < 8; ++i)
              arrLen |= static_cast<int64_t>(
                            queueBlock->data[queueOffset + 8 + i])
                        << (i * 8);
            if (arrLen > 0 && dataPtr != 0) {
              auto nmIt = nativeMemoryBlocks.find(dataPtr);
              bool isNativeData = (dataPtr >= 0x10000000000ULL) ||
                                  (nmIt != nativeMemoryBlocks.end());
              if (isNativeData) {
                MooreQueue tmpQ;
                tmpQ.data = reinterpret_cast<void *>(dataPtr);
                tmpQ.len = arrLen;
                result = __moore_array_min(&tmpQ, elemSize, isSigned);
              } else {
                uint64_t dataOffset = 0;
                auto *dataBlock =
                    findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
                if (dataBlock && dataBlock->initialized) {
                  uint8_t *base = dataBlock->data.data() + dataOffset;
                  std::vector<uint8_t> tmpData(arrLen * elemSize);
                  std::memcpy(tmpData.data(), base, arrLen * elemSize);
                  MooreQueue tmpQ;
                  tmpQ.data = tmpData.data();
                  tmpQ.len = arrLen;
                  result = __moore_array_min(&tmpQ, elemSize, isSigned);
                }
              }
            }
          }
        }
        auto ptrVal = reinterpret_cast<uint64_t>(result.data);
        auto lenVal = static_cast<uint64_t>(result.len);
        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, ptrVal), 0);
        safeInsertBits(packedResult,APInt(64, lenVal), 64);
        setValue(procId, callOp.getResult(),
                 InterpretedValue(packedResult));
        if (result.data && result.len > 0) {
          nativeMemoryBlocks[ptrVal] =
              static_cast<size_t>(result.len * elemSize);
        }
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_array_min()\n");
      }
      return success();
    }

    // ---- __moore_array_unique_index ----
    // Signature: (array: ptr, elemSize: i64) -> struct<(ptr, i64)>
    if (calleeName == "__moore_array_unique_index") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        MooreQueue result = {nullptr, 0};
        if (arrayAddr >= 0x10000000000ULL) {
          result = __moore_array_unique_index(
              reinterpret_cast<MooreQueue *>(arrayAddr), elemSize);
        } else if (arrayAddr != 0) {
          // Interpreter-managed memory: read queue struct {ptr, len}
          uint64_t queueOffset = 0;
          auto *queueBlock =
              findMemoryBlockByAddress(arrayAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized &&
              queueOffset + 16 <= queueBlock->data.size()) {
            uint64_t dataPtr = 0;
            int64_t arrLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(
                             queueBlock->data[queueOffset + i])
                         << (i * 8);
            for (int i = 0; i < 8; ++i)
              arrLen |= static_cast<int64_t>(
                            queueBlock->data[queueOffset + 8 + i])
                        << (i * 8);
            if (arrLen > 0 && dataPtr != 0) {
              auto nmIt = nativeMemoryBlocks.find(dataPtr);
              bool isNativeData = (dataPtr >= 0x10000000000ULL) ||
                                  (nmIt != nativeMemoryBlocks.end());
              if (isNativeData) {
                MooreQueue tmpQ;
                tmpQ.data = reinterpret_cast<void *>(dataPtr);
                tmpQ.len = arrLen;
                result = __moore_array_unique_index(&tmpQ, elemSize);
              } else {
                uint64_t dataOffset = 0;
                auto *dataBlock =
                    findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
                if (dataBlock && dataBlock->initialized) {
                  uint8_t *base = dataBlock->data.data() + dataOffset;
                  std::vector<uint8_t> tmpData(arrLen * elemSize);
                  std::memcpy(tmpData.data(), base, arrLen * elemSize);
                  MooreQueue tmpQ;
                  tmpQ.data = tmpData.data();
                  tmpQ.len = arrLen;
                  result = __moore_array_unique_index(&tmpQ, elemSize);
                }
              }
            }
          }
        }
        auto ptrVal = reinterpret_cast<uint64_t>(result.data);
        auto lenVal = static_cast<uint64_t>(result.len);
        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, ptrVal), 0);
        safeInsertBits(packedResult,APInt(64, lenVal), 64);
        setValue(procId, callOp.getResult(),
                 InterpretedValue(packedResult));
        if (result.data && result.len > 0) {
          nativeMemoryBlocks[ptrVal] =
              static_cast<size_t>(result.len * 8);
        }
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_array_unique_index() -> len="
                   << result.len << "\n");
      }
      return success();
    }

    // ---- __moore_array_reduce_sum ----
    // Signature: (array: ptr, elemSize: i64) -> i64
    if (calleeName == "__moore_array_reduce_sum") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int64_t result = 0;
        if (arrayAddr >= 0x10000000000ULL) {
          result = __moore_array_reduce_sum(
              reinterpret_cast<MooreQueue *>(arrayAddr), elemSize);
        } else if (arrayAddr != 0) {
          // Interpreter-managed memory: read queue struct {ptr, len}
          uint64_t queueOffset = 0;
          auto *queueBlock =
              findMemoryBlockByAddress(arrayAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized &&
              queueOffset + 16 <= queueBlock->data.size()) {
            uint64_t dataPtr = 0;
            int64_t arrLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(
                             queueBlock->data[queueOffset + i])
                         << (i * 8);
            for (int i = 0; i < 8; ++i)
              arrLen |= static_cast<int64_t>(
                            queueBlock->data[queueOffset + 8 + i])
                        << (i * 8);
            if (arrLen > 0 && dataPtr != 0) {
              auto nmIt = nativeMemoryBlocks.find(dataPtr);
              bool isNativeData = (dataPtr >= 0x10000000000ULL) ||
                                  (nmIt != nativeMemoryBlocks.end());
              if (isNativeData) {
                MooreQueue tmpQ;
                tmpQ.data = reinterpret_cast<void *>(dataPtr);
                tmpQ.len = arrLen;
                result = __moore_array_reduce_sum(&tmpQ, elemSize);
              } else {
                uint64_t dataOffset = 0;
                auto *dataBlock =
                    findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
                if (dataBlock && dataBlock->initialized) {
                  uint8_t *base = dataBlock->data.data() + dataOffset;
                  for (int64_t i = 0; i < arrLen; ++i) {
                    int64_t elem = 0;
                    int64_t bytesToRead =
                        std::min(elemSize, static_cast<int64_t>(8));
                    for (int64_t b = 0; b < bytesToRead; ++b)
                      elem |= static_cast<int64_t>(
                                  base[i * elemSize + b])
                              << (b * 8);
                    result += elem;
                  }
                }
              }
            }
          }
        }
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(64, result)));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_array_reduce_sum() -> "
                   << result << "\n");
      }
      return success();
    }

    // ---- __moore_array_reduce_product ----
    // Signature: (array: ptr, elemSize: i64) -> i64
    if (calleeName == "__moore_array_reduce_product") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int64_t result = 1;
        if (arrayAddr >= 0x10000000000ULL) {
          result = __moore_array_reduce_product(
              reinterpret_cast<MooreQueue *>(arrayAddr), elemSize);
        } else if (arrayAddr != 0) {
          uint64_t queueOffset = 0;
          auto *queueBlock =
              findMemoryBlockByAddress(arrayAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized &&
              queueOffset + 16 <= queueBlock->data.size()) {
            uint64_t dataPtr = 0;
            int64_t arrLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(
                             queueBlock->data[queueOffset + i])
                         << (i * 8);
            for (int i = 0; i < 8; ++i)
              arrLen |= static_cast<int64_t>(
                            queueBlock->data[queueOffset + 8 + i])
                        << (i * 8);
            if (arrLen > 0 && dataPtr != 0) {
              auto nmIt = nativeMemoryBlocks.find(dataPtr);
              bool isNativeData = (dataPtr >= 0x10000000000ULL) ||
                                  (nmIt != nativeMemoryBlocks.end());
              if (isNativeData) {
                MooreQueue tmpQ;
                tmpQ.data = reinterpret_cast<void *>(dataPtr);
                tmpQ.len = arrLen;
                result = __moore_array_reduce_product(&tmpQ, elemSize);
              } else {
                uint64_t dataOffset = 0;
                auto *dataBlock =
                    findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
                if (dataBlock && dataBlock->initialized) {
                  uint8_t *base = dataBlock->data.data() + dataOffset;
                  for (int64_t i = 0; i < arrLen; ++i) {
                    int64_t elem = 0;
                    int64_t bytesToRead =
                        std::min(elemSize, static_cast<int64_t>(8));
                    for (int64_t b = 0; b < bytesToRead; ++b)
                      elem |= static_cast<int64_t>(
                                  base[i * elemSize + b])
                              << (b * 8);
                    result *= elem;
                  }
                }
              }
            }
          }
        }
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(64, result)));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_array_reduce_product() -> "
                   << result << "\n");
      }
      return success();
    }

    // ---- __moore_array_reduce_and ----
    // Signature: (array: ptr, elemSize: i64) -> i64
    if (calleeName == "__moore_array_reduce_and") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int64_t result = 0;
        if (arrayAddr >= 0x10000000000ULL) {
          result = __moore_array_reduce_and(
              reinterpret_cast<MooreQueue *>(arrayAddr), elemSize);
        } else if (arrayAddr != 0) {
          uint64_t queueOffset = 0;
          auto *queueBlock =
              findMemoryBlockByAddress(arrayAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized &&
              queueOffset + 16 <= queueBlock->data.size()) {
            uint64_t dataPtr = 0;
            int64_t arrLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(
                             queueBlock->data[queueOffset + i])
                         << (i * 8);
            for (int i = 0; i < 8; ++i)
              arrLen |= static_cast<int64_t>(
                            queueBlock->data[queueOffset + 8 + i])
                        << (i * 8);
            if (arrLen > 0 && dataPtr != 0) {
              auto nmIt = nativeMemoryBlocks.find(dataPtr);
              bool isNativeData = (dataPtr >= 0x10000000000ULL) ||
                                  (nmIt != nativeMemoryBlocks.end());
              if (isNativeData) {
                MooreQueue tmpQ;
                tmpQ.data = reinterpret_cast<void *>(dataPtr);
                tmpQ.len = arrLen;
                result = __moore_array_reduce_and(&tmpQ, elemSize);
              } else {
                uint64_t dataOffset = 0;
                auto *dataBlock =
                    findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
                if (dataBlock && dataBlock->initialized) {
                  uint8_t *base = dataBlock->data.data() + dataOffset;
                  // Start with all-ones for AND
                  result = -1LL;
                  for (int64_t i = 0; i < arrLen; ++i) {
                    int64_t elem = 0;
                    int64_t bytesToRead =
                        std::min(elemSize, static_cast<int64_t>(8));
                    for (int64_t b = 0; b < bytesToRead; ++b)
                      elem |= static_cast<int64_t>(
                                  base[i * elemSize + b])
                              << (b * 8);
                    result &= elem;
                  }
                }
              }
            }
          }
        }
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(64, result)));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_array_reduce_and() -> "
                   << result << "\n");
      }
      return success();
    }

    // ---- __moore_array_reduce_or ----
    // Signature: (array: ptr, elemSize: i64) -> i64
    if (calleeName == "__moore_array_reduce_or") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int64_t result = 0;
        if (arrayAddr >= 0x10000000000ULL) {
          result = __moore_array_reduce_or(
              reinterpret_cast<MooreQueue *>(arrayAddr), elemSize);
        } else if (arrayAddr != 0) {
          uint64_t queueOffset = 0;
          auto *queueBlock =
              findMemoryBlockByAddress(arrayAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized &&
              queueOffset + 16 <= queueBlock->data.size()) {
            uint64_t dataPtr = 0;
            int64_t arrLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(
                             queueBlock->data[queueOffset + i])
                         << (i * 8);
            for (int i = 0; i < 8; ++i)
              arrLen |= static_cast<int64_t>(
                            queueBlock->data[queueOffset + 8 + i])
                        << (i * 8);
            if (arrLen > 0 && dataPtr != 0) {
              auto nmIt = nativeMemoryBlocks.find(dataPtr);
              bool isNativeData = (dataPtr >= 0x10000000000ULL) ||
                                  (nmIt != nativeMemoryBlocks.end());
              if (isNativeData) {
                MooreQueue tmpQ;
                tmpQ.data = reinterpret_cast<void *>(dataPtr);
                tmpQ.len = arrLen;
                result = __moore_array_reduce_or(&tmpQ, elemSize);
              } else {
                uint64_t dataOffset = 0;
                auto *dataBlock =
                    findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
                if (dataBlock && dataBlock->initialized) {
                  uint8_t *base = dataBlock->data.data() + dataOffset;
                  for (int64_t i = 0; i < arrLen; ++i) {
                    int64_t elem = 0;
                    int64_t bytesToRead =
                        std::min(elemSize, static_cast<int64_t>(8));
                    for (int64_t b = 0; b < bytesToRead; ++b)
                      elem |= static_cast<int64_t>(
                                  base[i * elemSize + b])
                              << (b * 8);
                    result |= elem;
                  }
                }
              }
            }
          }
        }
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(64, result)));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_array_reduce_or() -> "
                   << result << "\n");
      }
      return success();
    }

    // ---- __moore_array_reduce_xor ----
    // Signature: (array: ptr, elemSize: i64) -> i64
    if (calleeName == "__moore_array_reduce_xor") {
      if (callOp.getNumOperands() >= 2 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int64_t result = 0;
        if (arrayAddr >= 0x10000000000ULL) {
          result = __moore_array_reduce_xor(
              reinterpret_cast<MooreQueue *>(arrayAddr), elemSize);
        } else if (arrayAddr != 0) {
          uint64_t queueOffset = 0;
          auto *queueBlock =
              findMemoryBlockByAddress(arrayAddr, procId, &queueOffset);
          if (queueBlock && queueBlock->initialized &&
              queueOffset + 16 <= queueBlock->data.size()) {
            uint64_t dataPtr = 0;
            int64_t arrLen = 0;
            for (int i = 0; i < 8; ++i)
              dataPtr |= static_cast<uint64_t>(
                             queueBlock->data[queueOffset + i])
                         << (i * 8);
            for (int i = 0; i < 8; ++i)
              arrLen |= static_cast<int64_t>(
                            queueBlock->data[queueOffset + 8 + i])
                        << (i * 8);
            if (arrLen > 0 && dataPtr != 0) {
              auto nmIt = nativeMemoryBlocks.find(dataPtr);
              bool isNativeData = (dataPtr >= 0x10000000000ULL) ||
                                  (nmIt != nativeMemoryBlocks.end());
              if (isNativeData) {
                MooreQueue tmpQ;
                tmpQ.data = reinterpret_cast<void *>(dataPtr);
                tmpQ.len = arrLen;
                result = __moore_array_reduce_xor(&tmpQ, elemSize);
              } else {
                uint64_t dataOffset = 0;
                auto *dataBlock =
                    findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
                if (dataBlock && dataBlock->initialized) {
                  uint8_t *base = dataBlock->data.data() + dataOffset;
                  for (int64_t i = 0; i < arrLen; ++i) {
                    int64_t elem = 0;
                    int64_t bytesToRead =
                        std::min(elemSize, static_cast<int64_t>(8));
                    for (int64_t b = 0; b < bytesToRead; ++b)
                      elem |= static_cast<int64_t>(
                                  base[i * elemSize + b])
                              << (b * 8);
                    result ^= elem;
                  }
                }
              }
            }
          }
        }
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(64, result)));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_array_reduce_xor() -> "
                   << result << "\n");
      }
      return success();
    }

    // ---- __moore_array_contains ----
    // Signature: (arr: ptr, numElems: i64, value: ptr, elemSize: i64) -> i1
    if (calleeName == "__moore_array_contains") {
      if (callOp.getNumOperands() >= 4 && callOp.getNumResults() >= 1) {
        uint64_t arrAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t numElems = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        uint64_t valueAddr =
            getValue(procId, callOp.getOperand(2)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(3)).getUInt64());
        bool result = false;

        // Get raw pointers for arr and value
        void *arrPtr = nullptr;
        void *valuePtr = nullptr;
        std::vector<uint8_t> arrCopy, valueCopy;

        // Resolve array pointer
        if (arrAddr >= 0x10000000000ULL ||
            nativeMemoryBlocks.count(arrAddr)) {
          arrPtr = reinterpret_cast<void *>(arrAddr);
        } else if (arrAddr != 0) {
          uint64_t offset = 0;
          auto *block = findMemoryBlockByAddress(arrAddr, procId, &offset);
          if (block && block->initialized) {
            uint64_t totalBytes =
                static_cast<uint64_t>(numElems) * static_cast<uint64_t>(elemSize);
            if (offset + totalBytes <= block->data.size()) {
              arrCopy.assign(block->data.begin() + offset,
                             block->data.begin() + offset + totalBytes);
              arrPtr = arrCopy.data();
            }
          }
        }

        // Resolve value pointer
        if (valueAddr >= 0x10000000000ULL ||
            nativeMemoryBlocks.count(valueAddr)) {
          valuePtr = reinterpret_cast<void *>(valueAddr);
        } else if (valueAddr != 0) {
          uint64_t offset = 0;
          auto *block = findMemoryBlockByAddress(valueAddr, procId, &offset);
          if (block && block->initialized) {
            if (offset + static_cast<uint64_t>(elemSize) <=
                block->data.size()) {
              valueCopy.assign(block->data.begin() + offset,
                               block->data.begin() + offset + elemSize);
              valuePtr = valueCopy.data();
            }
          }
        }

        if (arrPtr && valuePtr) {
          result = __moore_array_contains(arrPtr, numElems, valuePtr, elemSize);
        }
        setValue(procId, callOp.getResult(),
                 InterpretedValue(APInt(1, result ? 1 : 0)));
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_array_contains() -> "
                   << result << "\n");
      }
      return success();
    }

    // ---- __moore_array_find_eq ----
    // Signature: (array: ptr, elemSize: i64, value: ptr, mode: i32,
    //             returnIndices: i1) -> struct<(ptr, i64)>
    if (calleeName == "__moore_array_find_eq") {
      if (callOp.getNumOperands() >= 5 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        uint64_t valueAddr =
            getValue(procId, callOp.getOperand(2)).getUInt64();
        int32_t mode = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(3)).getUInt64());
        bool returnIndices =
            getValue(procId, callOp.getOperand(4)).getUInt64() != 0;
        MooreQueue result = {nullptr, 0};

        // Resolve value pointer
        void *valuePtr = nullptr;
        std::vector<uint8_t> valueCopy;
        if (valueAddr >= 0x10000000000ULL ||
            nativeMemoryBlocks.count(valueAddr)) {
          valuePtr = reinterpret_cast<void *>(valueAddr);
        } else if (valueAddr != 0) {
          uint64_t offset = 0;
          auto *block = findMemoryBlockByAddress(valueAddr, procId, &offset);
          if (block && block->initialized &&
              offset + static_cast<uint64_t>(elemSize) <=
                  block->data.size()) {
            valueCopy.assign(block->data.begin() + offset,
                             block->data.begin() + offset + elemSize);
            valuePtr = valueCopy.data();
          }
        }

        if (valuePtr) {
          if (arrayAddr >= 0x10000000000ULL) {
            result = __moore_array_find_eq(
                reinterpret_cast<MooreQueue *>(arrayAddr), elemSize, valuePtr,
                mode, returnIndices);
          } else if (arrayAddr != 0) {
            // Interpreter-managed memory: read queue struct {ptr, len}
            uint64_t queueOffset = 0;
            auto *queueBlock =
                findMemoryBlockByAddress(arrayAddr, procId, &queueOffset);
            if (queueBlock && queueBlock->initialized &&
                queueOffset + 16 <= queueBlock->data.size()) {
              uint64_t dataPtr = 0;
              int64_t arrLen = 0;
              for (int i = 0; i < 8; ++i)
                dataPtr |= static_cast<uint64_t>(
                               queueBlock->data[queueOffset + i])
                           << (i * 8);
              for (int i = 0; i < 8; ++i)
                arrLen |= static_cast<int64_t>(
                              queueBlock->data[queueOffset + 8 + i])
                          << (i * 8);
              if (arrLen > 0 && dataPtr != 0) {
                auto nmIt = nativeMemoryBlocks.find(dataPtr);
                bool isNativeData = (dataPtr >= 0x10000000000ULL) ||
                                    (nmIt != nativeMemoryBlocks.end());
                if (isNativeData) {
                  MooreQueue tmpQ;
                  tmpQ.data = reinterpret_cast<void *>(dataPtr);
                  tmpQ.len = arrLen;
                  result = __moore_array_find_eq(&tmpQ, elemSize, valuePtr,
                                                 mode, returnIndices);
                } else {
                  uint64_t dataOffset = 0;
                  auto *dataBlock =
                      findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
                  if (dataBlock && dataBlock->initialized) {
                    std::vector<uint8_t> tmpData(arrLen * elemSize);
                    std::memcpy(tmpData.data(),
                                dataBlock->data.data() + dataOffset,
                                arrLen * elemSize);
                    MooreQueue tmpQ;
                    tmpQ.data = tmpData.data();
                    tmpQ.len = arrLen;
                    result = __moore_array_find_eq(&tmpQ, elemSize, valuePtr,
                                                   mode, returnIndices);
                  }
                }
              }
            }
          }
        }
        auto ptrVal = reinterpret_cast<uint64_t>(result.data);
        auto lenVal = static_cast<uint64_t>(result.len);
        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, ptrVal), 0);
        safeInsertBits(packedResult,APInt(64, lenVal), 64);
        setValue(procId, callOp.getResult(),
                 InterpretedValue(packedResult));
        if (result.data && result.len > 0) {
          int64_t resultElemSize = returnIndices ? 8 : elemSize;
          nativeMemoryBlocks[ptrVal] =
              static_cast<size_t>(result.len * resultElemSize);
        }
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_array_find_eq()\n");
      }
      return success();
    }

    // ---- __moore_array_find_cmp ----
    // Signature: (array: ptr, elemSize: i64, value: ptr, cmpMode: i32,
    //             locatorMode: i32, returnIndices: i1) -> struct<(ptr, i64)>
    if (calleeName == "__moore_array_find_cmp") {
      if (callOp.getNumOperands() >= 6 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        uint64_t valueAddr =
            getValue(procId, callOp.getOperand(2)).getUInt64();
        int32_t cmpMode = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(3)).getUInt64());
        int32_t locatorMode = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(4)).getUInt64());
        bool returnIndices =
            getValue(procId, callOp.getOperand(5)).getUInt64() != 0;
        MooreQueue result = {nullptr, 0};

        // Resolve value pointer
        void *valuePtr = nullptr;
        std::vector<uint8_t> valueCopy;
        if (valueAddr >= 0x10000000000ULL ||
            nativeMemoryBlocks.count(valueAddr)) {
          valuePtr = reinterpret_cast<void *>(valueAddr);
        } else if (valueAddr != 0) {
          uint64_t offset = 0;
          auto *block = findMemoryBlockByAddress(valueAddr, procId, &offset);
          if (block && block->initialized &&
              offset + static_cast<uint64_t>(elemSize) <=
                  block->data.size()) {
            valueCopy.assign(block->data.begin() + offset,
                             block->data.begin() + offset + elemSize);
            valuePtr = valueCopy.data();
          }
        }

        if (valuePtr) {
          if (arrayAddr >= 0x10000000000ULL) {
            result = __moore_array_find_cmp(
                reinterpret_cast<MooreQueue *>(arrayAddr), elemSize, valuePtr,
                cmpMode, locatorMode, returnIndices);
          } else if (arrayAddr != 0) {
            uint64_t queueOffset = 0;
            auto *queueBlock =
                findMemoryBlockByAddress(arrayAddr, procId, &queueOffset);
            if (queueBlock && queueBlock->initialized &&
                queueOffset + 16 <= queueBlock->data.size()) {
              uint64_t dataPtr = 0;
              int64_t arrLen = 0;
              for (int i = 0; i < 8; ++i)
                dataPtr |= static_cast<uint64_t>(
                               queueBlock->data[queueOffset + i])
                           << (i * 8);
              for (int i = 0; i < 8; ++i)
                arrLen |= static_cast<int64_t>(
                              queueBlock->data[queueOffset + 8 + i])
                          << (i * 8);
              if (arrLen > 0 && dataPtr != 0) {
                auto nmIt = nativeMemoryBlocks.find(dataPtr);
                bool isNativeData = (dataPtr >= 0x10000000000ULL) ||
                                    (nmIt != nativeMemoryBlocks.end());
                if (isNativeData) {
                  MooreQueue tmpQ;
                  tmpQ.data = reinterpret_cast<void *>(dataPtr);
                  tmpQ.len = arrLen;
                  result = __moore_array_find_cmp(&tmpQ, elemSize, valuePtr,
                                                  cmpMode, locatorMode,
                                                  returnIndices);
                } else {
                  uint64_t dataOffset = 0;
                  auto *dataBlock =
                      findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
                  if (dataBlock && dataBlock->initialized) {
                    std::vector<uint8_t> tmpData(arrLen * elemSize);
                    std::memcpy(tmpData.data(),
                                dataBlock->data.data() + dataOffset,
                                arrLen * elemSize);
                    MooreQueue tmpQ;
                    tmpQ.data = tmpData.data();
                    tmpQ.len = arrLen;
                    result = __moore_array_find_cmp(&tmpQ, elemSize, valuePtr,
                                                    cmpMode, locatorMode,
                                                    returnIndices);
                  }
                }
              }
            }
          }
        }
        auto ptrVal = reinterpret_cast<uint64_t>(result.data);
        auto lenVal = static_cast<uint64_t>(result.len);
        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, ptrVal), 0);
        safeInsertBits(packedResult,APInt(64, lenVal), 64);
        setValue(procId, callOp.getResult(),
                 InterpretedValue(packedResult));
        if (result.data && result.len > 0) {
          int64_t resultElemSize = returnIndices ? 8 : elemSize;
          nativeMemoryBlocks[ptrVal] =
              static_cast<size_t>(result.len * resultElemSize);
        }
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_array_find_cmp()\n");
      }
      return success();
    }

    // ---- __moore_array_find_field_cmp ----
    // Signature: (array: ptr, elemSize: i64, fieldOffset: i64, fieldSize: i64,
    //             value: ptr, cmpMode: i32, locatorMode: i32,
    //             returnIndices: i1) -> struct<(ptr, i64)>
    if (calleeName == "__moore_array_find_field_cmp") {
      if (callOp.getNumOperands() >= 8 && callOp.getNumResults() >= 1) {
        uint64_t arrayAddr =
            getValue(procId, callOp.getOperand(0)).getUInt64();
        int64_t elemSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(1)).getUInt64());
        int64_t fieldOffset = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(2)).getUInt64());
        int64_t fieldSize = static_cast<int64_t>(
            getValue(procId, callOp.getOperand(3)).getUInt64());
        uint64_t valueAddr =
            getValue(procId, callOp.getOperand(4)).getUInt64();
        int32_t cmpMode = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(5)).getUInt64());
        int32_t locatorMode = static_cast<int32_t>(
            getValue(procId, callOp.getOperand(6)).getUInt64());
        bool returnIndices =
            getValue(procId, callOp.getOperand(7)).getUInt64() != 0;
        MooreQueue result = {nullptr, 0};

        // Resolve value pointer
        void *valuePtr = nullptr;
        std::vector<uint8_t> valueCopy;
        if (valueAddr >= 0x10000000000ULL ||
            nativeMemoryBlocks.count(valueAddr)) {
          valuePtr = reinterpret_cast<void *>(valueAddr);
        } else if (valueAddr != 0) {
          uint64_t offset = 0;
          auto *block = findMemoryBlockByAddress(valueAddr, procId, &offset);
          if (block && block->initialized &&
              offset + static_cast<uint64_t>(fieldSize) <=
                  block->data.size()) {
            valueCopy.assign(block->data.begin() + offset,
                             block->data.begin() + offset + fieldSize);
            valuePtr = valueCopy.data();
          }
        }

        if (valuePtr) {
          if (arrayAddr >= 0x10000000000ULL) {
            result = __moore_array_find_field_cmp(
                reinterpret_cast<MooreQueue *>(arrayAddr), elemSize,
                fieldOffset, fieldSize, valuePtr, cmpMode, locatorMode,
                returnIndices);
          } else if (arrayAddr != 0) {
            uint64_t queueOffset = 0;
            auto *queueBlock =
                findMemoryBlockByAddress(arrayAddr, procId, &queueOffset);
            if (queueBlock && queueBlock->initialized &&
                queueOffset + 16 <= queueBlock->data.size()) {
              uint64_t dataPtr = 0;
              int64_t arrLen = 0;
              for (int i = 0; i < 8; ++i)
                dataPtr |= static_cast<uint64_t>(
                               queueBlock->data[queueOffset + i])
                           << (i * 8);
              for (int i = 0; i < 8; ++i)
                arrLen |= static_cast<int64_t>(
                              queueBlock->data[queueOffset + 8 + i])
                          << (i * 8);
              if (arrLen > 0 && dataPtr != 0) {
                auto nmIt = nativeMemoryBlocks.find(dataPtr);
                bool isNativeData = (dataPtr >= 0x10000000000ULL) ||
                                    (nmIt != nativeMemoryBlocks.end());
                if (isNativeData) {
                  MooreQueue tmpQ;
                  tmpQ.data = reinterpret_cast<void *>(dataPtr);
                  tmpQ.len = arrLen;
                  result = __moore_array_find_field_cmp(
                      &tmpQ, elemSize, fieldOffset, fieldSize, valuePtr,
                      cmpMode, locatorMode, returnIndices);
                } else {
                  uint64_t dataOffset = 0;
                  auto *dataBlock =
                      findMemoryBlockByAddress(dataPtr, procId, &dataOffset);
                  if (dataBlock && dataBlock->initialized) {
                    std::vector<uint8_t> tmpData(arrLen * elemSize);
                    std::memcpy(tmpData.data(),
                                dataBlock->data.data() + dataOffset,
                                arrLen * elemSize);
                    MooreQueue tmpQ;
                    tmpQ.data = tmpData.data();
                    tmpQ.len = arrLen;
                    result = __moore_array_find_field_cmp(
                        &tmpQ, elemSize, fieldOffset, fieldSize, valuePtr,
                        cmpMode, locatorMode, returnIndices);
                  }
                }
              }
            }
          }
        }
        auto ptrVal = reinterpret_cast<uint64_t>(result.data);
        auto lenVal = static_cast<uint64_t>(result.len);
        APInt packedResult(128, 0);
        safeInsertBits(packedResult,APInt(64, ptrVal), 0);
        safeInsertBits(packedResult,APInt(64, lenVal), 64);
        setValue(procId, callOp.getResult(),
                 InterpretedValue(packedResult));
        if (result.data && result.len > 0) {
          int64_t resultElemSize = returnIndices ? 8 : elemSize;
          nativeMemoryBlocks[ptrVal] =
              static_cast<size_t>(result.len * resultElemSize);
        }
        LLVM_DEBUG(llvm::dbgs()
                   << "  llvm.call: __moore_array_find_field_cmp()\n");
      }
      return success();
    }

    // ---- __moore_display ----
    // Signature: (message_ptr: ptr) -> void
    if (calleeName == "__moore_display") {
      if (callOp.getNumOperands() >= 1) {
        std::string message = readStringFromPtr(callOp.getOperand(0));
        if (!message.empty()) {
          std::fwrite(message.data(), 1, message.size(), stdout);
        }
        std::fputc('\n', stdout);
        std::fflush(stdout);
        LLVM_DEBUG(llvm::dbgs() << "  llvm.call: __moore_display(\"" << message
                                << "\")\n");
      }
      return success();
    }

    // Cache this function as non-intercepted so we skip the entire 128-entry
    // string comparison chain on subsequent calls.
    nonInterceptedExternals.insert(funcOp.getOperation());
    LLVM_DEBUG(llvm::dbgs() << "  llvm.call: function '" << calleeName
                            << "' is external (no body, cached)\n");
    for (Value result : callOp.getResults()) {
      setValue(procId, result,
               InterpretedValue::makeX(getTypeWidth(result.getType())));
    }
    return success();
  }

  // Gather argument values and operands (for signal reference tracking)
  SmallVector<InterpretedValue, 4> args;
  SmallVector<Value, 4> callOperands;
  for (Value arg : callOp.getArgOperands()) {
    args.push_back(getValue(procId, arg));
    callOperands.push_back(arg);
  }

  // Check call depth to prevent stack overflow from unbounded recursion.
  // Using 100 as the limit since each recursive call uses significant C++ stack
  // space due to the deep call chain: interpretLLVMFuncBody -> interpretOperation
  // -> interpretLLVMCall -> interpretLLVMFuncBody.
  constexpr size_t maxCallDepth = 200;
  if (state.callDepth >= maxCallDepth) {
    LLVM_DEBUG(llvm::dbgs() << "  llvm.call: max call depth (" << maxCallDepth
                            << ") exceeded for '" << calleeName << "'\n");
    // Return zero values for results instead of X to prevent cascading issues
    for (Value result : callOp.getResults()) {
      unsigned width = getTypeWidth(result.getType());
      setValue(procId, result, InterpretedValue(llvm::APInt(width, 0)));
    }
    return success();
  }

  // Recursive DFS depth detection (same as func.call handler)
  Operation *llvmFuncKey = funcOp.getOperation();
  uint64_t llvmArg0Val = 0;
  bool llvmHasArg0 = !args.empty() && !args[0].isX();
  if (llvmHasArg0)
    llvmArg0Val = args[0].getUInt64();
  constexpr unsigned maxRecursionDepthLLVM = 20;
  auto &llvmDepthMap = state.recursionVisited[llvmFuncKey];
  if (llvmHasArg0 && state.callDepth > 0) {
    unsigned &depth = llvmDepthMap[llvmArg0Val];
    if (depth >= maxRecursionDepthLLVM) {
      LLVM_DEBUG(llvm::dbgs()
                 << "  llvm.call: recursion depth " << depth
                 << " exceeded for '" << calleeName << "' with arg0=0x"
                 << llvm::format_hex(llvmArg0Val, 16) << "\n");
      for (Value result : callOp.getResults()) {
        unsigned width = getTypeWidth(result.getType());
        setValue(procId, result, InterpretedValue(llvm::APInt(width, 0)));
      }
      return success();
    }
  }
  bool llvmAddedToVisited = llvmHasArg0;
  if (llvmHasArg0)
    ++llvmDepthMap[llvmArg0Val];

  // Increment call depth before entering function
  ++state.callDepth;

  // Interpret the function body, passing call operands for signal mapping
  SmallVector<InterpretedValue, 2> results;
  LogicalResult funcResult =
      interpretLLVMFuncBody(procId, funcOp, args, results, callOperands,
                            callOp.getOperation());

  // Decrement call depth after returning (but not if function suspended -
  // the call stack resume logic will handle depth management)
  --state.callDepth;

  // Decrement depth counter after returning
  if (llvmAddedToVisited) {
    auto &depthRef = processStates[procId].recursionVisited[llvmFuncKey][llvmArg0Val];
    if (depthRef > 0)
      --depthRef;
  }

  if (failed(funcResult))
    return failure();

  // Check if process suspended during function execution (e.g., due to wait)
  // If so, return early without setting results - the function didn't complete
  auto &postCallState = processStates[procId];
  if (postCallState.waiting) {
    LLVM_DEBUG(llvm::dbgs() << "  llvm.call: process suspended during call to '"
                            << calleeName << "'\n");
    return success();
  }

  // Set the return values
  for (auto [result, retVal] : llvm::zip(callOp.getResults(), results)) {
    setValue(procId, result, retVal);
  }

  LLVM_DEBUG(llvm::dbgs() << "  llvm.call: called '" << calleeName << "'\n");

  return success();
}

//===----------------------------------------------------------------------===//
// DPI Function Interception
//===----------------------------------------------------------------------===//
// Intercepts calls to external DPI functions (func.func with no body) that
// have native implementations in MooreRuntime.cpp. Without this, UVM DPI
// functions like uvm_re_compexecfree return X, breaking regex matching,
// component hierarchy building, and all UVM phases.

LogicalResult LLHDProcessInterpreter::interceptDPIFunc(
    ProcessId procId, StringRef calleeName, LLVM::CallOp callOp) {

  // Helper: extract a std::string from a MooreString struct value argument.
  // The argument is an InterpretedValue holding a 128-bit {ptr, len} struct.
  auto extractStringFromVal = [&](Value operand) -> std::string {
    InterpretedValue val = getValue(procId, operand);
    if (val.isX() || val.getWidth() < 128)
      return "";
    APInt bits = val.getAPInt();
    uint64_t strPtr = bits.extractBits(64, 0).getZExtValue();
    int64_t strLen = bits.extractBits(64, 64).getSExtValue();
    if (strPtr == 0 || strLen <= 0)
      return "";

    // Try dynamicStrings registry
    auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
    if (dynIt != dynamicStrings.end() && dynIt->second.first &&
        dynIt->second.second > 0) {
      return std::string(dynIt->second.first,
                         std::min(static_cast<size_t>(strLen),
                                  static_cast<size_t>(dynIt->second.second)));
    }

    // Try global/malloc memory via O(log n) range index
    {
      uint64_t off = 0;
      MemoryBlock *gBlock = findBlockByAddress(strPtr, off);
      if (gBlock && gBlock->initialized) {
        size_t avail = std::min(static_cast<size_t>(strLen),
                                gBlock->data.size() - static_cast<size_t>(off));
        if (avail > 0)
          return std::string(
              reinterpret_cast<const char *>(gBlock->data.data() + off), avail);
      }
    }

    // Try native memory (direct pointer read)
    bool isNative = false;
    for (auto &entry : nativeMemoryBlocks) {
      if (strPtr >= entry.first && strPtr < entry.first + entry.second) {
        isNative = true;
        break;
      }
    }
    if (isNative || strPtr >= 0x10000) {
      const char *p = reinterpret_cast<const char *>(strPtr);
      return std::string(p, static_cast<size_t>(strLen));
    }

    return "";
  };

  // Helper: pack a string result into a 128-bit MooreString struct.
  auto packStringResult = [&](const std::string &str, Value resultVal) {
    if (str.empty()) {
      setValue(procId, resultVal, InterpretedValue(APInt(128, 0)));
      return;
    }
    interpreterStrings.push_back(str);
    const std::string &stored = interpreterStrings.back();
    int64_t ptrVal = reinterpret_cast<int64_t>(stored.data());
    int64_t lenVal = static_cast<int64_t>(stored.size());
    dynamicStrings[ptrVal] = {stored.data(), lenVal};
    APInt packed(128, 0);
    safeInsertBits(packed,APInt(64, static_cast<uint64_t>(ptrVal)), 0);
    safeInsertBits(packed,APInt(64, static_cast<uint64_t>(lenVal)), 64);
    setValue(procId, resultVal, InterpretedValue(packed));
  };

  // Helper: write an i32 value to an !llhd.ref<i32> output argument.
  auto writeRefI32 = [&](Value refOperand, int32_t value) {
    InterpretedValue refVal = getValue(procId, refOperand);
    Type refType = refOperand.getType();
    InterpretedValue writeVal(APInt(32, static_cast<uint32_t>(value)));

    if (auto refT = dyn_cast<llhd::RefType>(refType)) {
      unsigned sigId = resolveSignalId(refOperand);
      if (sigId > 0) {
        pendingEpsilonDrives[sigId] = writeVal;
      } else {
        uint64_t addr = refVal.isX() ? 0 : refVal.getUInt64();
        if (addr > 0) {
          uint64_t offset = 0;
          auto *block = findMemoryBlockByAddress(addr, procId, &offset);
          if (block && block->initialized && offset + 4 <= block->data.size()) {
            for (int i = 0; i < 4; ++i)
              block->data[offset + i] =
                  static_cast<uint8_t>((value >> (i * 8)) & 0xFF);
          }
        }
      }
    } else if (isa<LLVM::LLVMPointerType>(refType)) {
      uint64_t addr = refVal.isX() ? 0 : refVal.getUInt64();
      if (addr > 0) {
        uint64_t offset = 0;
        auto *block = findMemoryBlockByAddress(addr, procId, &offset);
        if (block && block->initialized && offset + 4 <= block->data.size()) {
          for (int i = 0; i < 4; ++i)
            block->data[offset + i] =
                static_cast<uint8_t>((value >> (i * 8)) & 0xFF);
        }
      }
    }
  };

  // ---- uvm_re_compexecfree ----
  // Signature: (pattern: struct{ptr,i64}, str: struct{ptr,i64}, deglob: i1,
  //             exec_ret: ref<i32>) -> i1
  if (calleeName == "uvm_re_compexecfree") {
    std::string pattern = extractStringFromVal(callOp.getOperand(0));
    std::string str = extractStringFromVal(callOp.getOperand(1));
    InterpretedValue deglobVal = getValue(procId, callOp.getOperand(2));
    int32_t deglob =
        deglobVal.isX() ? 0 : static_cast<int32_t>(deglobVal.getUInt64());

    MooreString patStr = {const_cast<char *>(pattern.c_str()),
                          static_cast<int64_t>(pattern.size())};
    MooreString strStr = {const_cast<char *>(str.c_str()),
                          static_cast<int64_t>(str.size())};
    int32_t exec_ret = -1;
    int32_t result = uvm_re_compexecfree(&patStr, &strStr, deglob, &exec_ret);

    // Write exec_ret to the !llhd.ref<i32> output argument
    if (callOp.getNumOperands() > 3)
      writeRefI32(callOp.getOperand(3), exec_ret);

    // Return i1 result
    if (callOp.getNumResults() > 0)
      setValue(procId, callOp.getResult(),
              InterpretedValue(APInt(1, result != 0 ? 1 : 0)));

    LLVM_DEBUG(llvm::dbgs()
               << "  DPI: uvm_re_compexecfree(\"" << pattern << "\", \"" << str
               << "\", " << deglob << ") = " << result
               << " (exec_ret=" << exec_ret << ")\n");
    return success();
  }

  // ---- uvm_re_buffer ----
  // Signature: () -> struct{ptr,i64}
  if (calleeName == "uvm_re_buffer") {
    MooreString result = uvm_re_buffer();
    std::string resultStr;
    if (result.data && result.len > 0)
      resultStr = std::string(result.data, result.len);
    if (result.data)
      std::free(result.data);

    if (callOp.getNumResults() > 0)
      packStringResult(resultStr, callOp.getResult());

    LLVM_DEBUG(llvm::dbgs()
               << "  DPI: uvm_re_buffer() = \"" << resultStr << "\"\n");
    return success();
  }

  // ---- uvm_re_free ----
  // Signature: (ptr) -> void
  if (calleeName == "uvm_re_free") {
    if (callOp.getNumOperands() > 0) {
      InterpretedValue ptrVal = getValue(procId, callOp.getOperand(0));
      void *ptr =
          ptrVal.isX() ? nullptr
                       : reinterpret_cast<void *>(ptrVal.getUInt64());
      uvm_re_free(ptr);
      LLVM_DEBUG(llvm::dbgs() << "  DPI: uvm_re_free(" << ptr << ")\n");
    }
    return success();
  }

  // ---- uvm_re_deglobbed ----
  // Signature: (glob: struct{ptr,i64}, with_brackets: i1) -> struct{ptr,i64}
  if (calleeName == "uvm_re_deglobbed") {
    std::string glob = extractStringFromVal(callOp.getOperand(0));
    InterpretedValue bracketVal = getValue(procId, callOp.getOperand(1));
    int32_t withBrackets =
        bracketVal.isX() ? 0 : static_cast<int32_t>(bracketVal.getUInt64());

    MooreString globStr = {const_cast<char *>(glob.c_str()),
                           static_cast<int64_t>(glob.size())};
    MooreString result = uvm_re_deglobbed(&globStr, withBrackets);
    std::string resultStr;
    if (result.data && result.len > 0)
      resultStr = std::string(result.data, result.len);
    if (result.data)
      std::free(result.data);

    if (callOp.getNumResults() > 0)
      packStringResult(resultStr, callOp.getResult());

    LLVM_DEBUG(llvm::dbgs() << "  DPI: uvm_re_deglobbed(\"" << glob << "\", "
                            << withBrackets << ") = \"" << resultStr << "\"\n");
    return success();
  }

  // ---- uvm_dpi_get_next_arg_c ----
  // Signature: (init: i32) -> struct{ptr,i64}
  if (calleeName == "uvm_dpi_get_next_arg_c") {
    InterpretedValue initVal = getValue(procId, callOp.getOperand(0));
    int32_t init =
        initVal.isX() ? 1 : static_cast<int32_t>(initVal.getUInt64());

    MooreString result = uvm_dpi_get_next_arg_c(init);
    std::string resultStr;
    if (result.data && result.len > 0)
      resultStr = std::string(result.data, result.len);
    if (result.data)
      std::free(result.data);

    if (callOp.getNumResults() > 0)
      packStringResult(resultStr, callOp.getResult());

    LLVM_DEBUG(llvm::dbgs() << "  DPI: uvm_dpi_get_next_arg_c(" << init
                            << ") = \"" << resultStr << "\"\n");
    return success();
  }

  // ---- uvm_hdl_check_path ----
  // Signature: (path: struct{ptr,i64}) -> i32
  if (calleeName == "uvm_hdl_check_path") {
    std::string path = extractStringFromVal(callOp.getOperand(0));

    MooreString pathStr = {const_cast<char *>(path.c_str()),
                           static_cast<int64_t>(path.size())};
    int32_t result = uvm_hdl_check_path(&pathStr);

    if (callOp.getNumResults() > 0)
      setValue(procId, callOp.getResult(),
              InterpretedValue(APInt(32, static_cast<uint32_t>(result))));

    LLVM_DEBUG(llvm::dbgs() << "  DPI: uvm_hdl_check_path(\"" << path
                            << "\") = " << result << "\n");
    return success();
  }

  // ---- uvm_hdl_deposit ----
  // Signature: (path: struct{ptr,i64}, value: hw.struct<value:i1024,unknown:i1024>) -> i32
  if (calleeName == "uvm_hdl_deposit") {
    std::string path = extractStringFromVal(callOp.getOperand(0));
    // Extract low 64 bits of the 2048-bit value struct as the deposit value
    InterpretedValue dataArg = getValue(procId, callOp.getOperand(1));
    uvm_hdl_data_t value = 0;
    if (!dataArg.isX()) {
      APInt bits = dataArg.getAPInt();
      value = static_cast<uvm_hdl_data_t>(
          bits.extractBits(64, 0).getZExtValue());
    }

    MooreString pathStr = {const_cast<char *>(path.c_str()),
                           static_cast<int64_t>(path.size())};
    int32_t result = uvm_hdl_deposit(&pathStr, value);

    if (callOp.getNumResults() > 0)
      setValue(procId, callOp.getResult(),
              InterpretedValue(APInt(32, static_cast<uint32_t>(result))));

    LLVM_DEBUG(llvm::dbgs() << "  DPI: uvm_hdl_deposit(\"" << path << "\", "
                            << value << ") = " << result << "\n");
    return success();
  }

  // ---- uvm_hdl_read ----
  // Signature: (path: struct{ptr,i64}, ref<hw.struct<value:i1024,unknown:i1024>>) -> i32
  if (calleeName == "uvm_hdl_read") {
    std::string path = extractStringFromVal(callOp.getOperand(0));

    MooreString pathStr = {const_cast<char *>(path.c_str()),
                           static_cast<int64_t>(path.size())};
    uvm_hdl_data_t readValue = 0;
    int32_t result = uvm_hdl_read(&pathStr, &readValue);

    // Write read value to the !llhd.ref output argument
    if (callOp.getNumOperands() > 1) {
      Value outputRef = callOp.getOperand(1);
      InterpretedValue refVal = getValue(procId, outputRef);
      Type refType = outputRef.getType();

      if (auto refT = dyn_cast<llhd::RefType>(refType)) {
        Type innerType = refT.getNestedType();
        unsigned innerBits = getTypeWidth(innerType);
        APInt valueBits(innerBits, 0);
        // Set low 64 bits of value field to readValue
        safeInsertBits(valueBits,
            APInt(64, static_cast<uint64_t>(readValue)), 0);
        InterpretedValue writeVal(valueBits);

        unsigned sigId = resolveSignalId(outputRef);
        if (sigId > 0) {
          pendingEpsilonDrives[sigId] = writeVal;
        } else {
          uint64_t addr = refVal.isX() ? 0 : refVal.getUInt64();
          if (addr > 0) {
            uint64_t offset = 0;
            auto *block = findMemoryBlockByAddress(addr, procId, &offset);
            if (block && block->initialized) {
              unsigned innerBytes = (innerBits + 7) / 8;
              for (unsigned i = 0;
                   i < std::min(innerBytes,
                                (unsigned)(block->data.size() - offset));
                   ++i)
                block->data[offset + i] =
                    (i < 8) ? static_cast<uint8_t>(
                                  (readValue >> (i * 8)) & 0xFF)
                            : 0;
            }
          }
        }
      }
    }

    if (callOp.getNumResults() > 0)
      setValue(procId, callOp.getResult(),
              InterpretedValue(APInt(32, static_cast<uint32_t>(result))));

    LLVM_DEBUG(llvm::dbgs() << "  DPI: uvm_hdl_read(\"" << path << "\") = "
                            << result << " (value=" << readValue << ")\n");
    return success();
  }

  // Not a known DPI function
  LLVM_DEBUG(llvm::dbgs() << "  DPI: unknown function '" << calleeName
                          << "' - not intercepted\n");
  return failure();
}

// func::CallOp overload for DPI interception (used by interpretFuncCall).
// The logic is identical to the LLVM::CallOp overload above, but uses
// func::CallOp's getResult(index) accessor instead of getResult().
LogicalResult LLHDProcessInterpreter::interceptDPIFunc(
    ProcessId procId, StringRef calleeName, func::CallOp callOp) {

  // Helper: extract a std::string from a MooreString struct value argument.
  auto extractStringFromVal = [&](Value operand) -> std::string {
    InterpretedValue val = getValue(procId, operand);
    if (val.isX() || val.getWidth() < 128)
      return "";
    APInt bits = val.getAPInt();
    uint64_t strPtr = bits.extractBits(64, 0).getZExtValue();
    int64_t strLen = bits.extractBits(64, 64).getSExtValue();
    if (strPtr == 0 || strLen <= 0)
      return "";

    auto dynIt = dynamicStrings.find(static_cast<int64_t>(strPtr));
    if (dynIt != dynamicStrings.end() && dynIt->second.first &&
        dynIt->second.second > 0) {
      return std::string(dynIt->second.first,
                         std::min(static_cast<size_t>(strLen),
                                  static_cast<size_t>(dynIt->second.second)));
    }

    {
      uint64_t off = 0;
      MemoryBlock *gBlock = findBlockByAddress(strPtr, off);
      if (gBlock && gBlock->initialized) {
        size_t avail = std::min(static_cast<size_t>(strLen),
                                gBlock->data.size() - static_cast<size_t>(off));
        if (avail > 0)
          return std::string(
              reinterpret_cast<const char *>(gBlock->data.data() + off), avail);
      }
    }

    bool isNative = false;
    for (auto &entry : nativeMemoryBlocks) {
      if (strPtr >= entry.first && strPtr < entry.first + entry.second) {
        isNative = true;
        break;
      }
    }
    if (isNative || strPtr >= 0x10000) {
      const char *p = reinterpret_cast<const char *>(strPtr);
      return std::string(p, static_cast<size_t>(strLen));
    }

    return "";
  };

  auto packStringResult = [&](const std::string &str, Value resultVal) {
    if (str.empty()) {
      setValue(procId, resultVal, InterpretedValue(APInt(128, 0)));
      return;
    }
    interpreterStrings.push_back(str);
    const std::string &stored = interpreterStrings.back();
    int64_t ptrVal = reinterpret_cast<int64_t>(stored.data());
    int64_t lenVal = static_cast<int64_t>(stored.size());
    dynamicStrings[ptrVal] = {stored.data(), lenVal};
    APInt packed(128, 0);
    safeInsertBits(packed,APInt(64, static_cast<uint64_t>(ptrVal)), 0);
    safeInsertBits(packed,APInt(64, static_cast<uint64_t>(lenVal)), 64);
    setValue(procId, resultVal, InterpretedValue(packed));
  };

  auto writeRefI32 = [&](Value refOperand, int32_t value) {
    InterpretedValue refVal = getValue(procId, refOperand);
    Type refType = refOperand.getType();
    InterpretedValue writeVal(APInt(32, static_cast<uint32_t>(value)));

    if (auto refT = dyn_cast<llhd::RefType>(refType)) {
      unsigned sigId = resolveSignalId(refOperand);
      if (sigId > 0) {
        pendingEpsilonDrives[sigId] = writeVal;
      } else {
        uint64_t addr = refVal.isX() ? 0 : refVal.getUInt64();
        if (addr > 0) {
          uint64_t offset = 0;
          auto *block = findMemoryBlockByAddress(addr, procId, &offset);
          if (block && block->initialized && offset + 4 <= block->data.size()) {
            for (int i = 0; i < 4; ++i)
              block->data[offset + i] =
                  static_cast<uint8_t>((value >> (i * 8)) & 0xFF);
          }
        }
      }
    } else if (isa<LLVM::LLVMPointerType>(refType)) {
      uint64_t addr = refVal.isX() ? 0 : refVal.getUInt64();
      if (addr > 0) {
        uint64_t offset = 0;
        auto *block = findMemoryBlockByAddress(addr, procId, &offset);
        if (block && block->initialized && offset + 4 <= block->data.size()) {
          for (int i = 0; i < 4; ++i)
            block->data[offset + i] =
                static_cast<uint8_t>((value >> (i * 8)) & 0xFF);
        }
      }
    }
  };

  // ---- uvm_re_compexecfree ----
  if (calleeName == "uvm_re_compexecfree") {
    std::string pattern = extractStringFromVal(callOp.getOperand(0));
    std::string str = extractStringFromVal(callOp.getOperand(1));
    InterpretedValue deglobVal = getValue(procId, callOp.getOperand(2));
    int32_t deglob =
        deglobVal.isX() ? 0 : static_cast<int32_t>(deglobVal.getUInt64());

    MooreString patStr = {const_cast<char *>(pattern.c_str()),
                          static_cast<int64_t>(pattern.size())};
    MooreString strStr = {const_cast<char *>(str.c_str()),
                          static_cast<int64_t>(str.size())};
    int32_t exec_ret = -1;
    int32_t result = uvm_re_compexecfree(&patStr, &strStr, deglob, &exec_ret);

    if (callOp.getNumOperands() > 3)
      writeRefI32(callOp.getOperand(3), exec_ret);

    if (callOp.getNumResults() > 0)
      setValue(procId, callOp.getResult(0),
              InterpretedValue(APInt(1, result != 0 ? 1 : 0)));

    LLVM_DEBUG(llvm::dbgs()
               << "  DPI: uvm_re_compexecfree(\"" << pattern << "\", \"" << str
               << "\", " << deglob << ") = " << result
               << " (exec_ret=" << exec_ret << ")\n");
    return success();
  }

  // ---- uvm_re_buffer ----
  if (calleeName == "uvm_re_buffer") {
    MooreString result = uvm_re_buffer();
    std::string resultStr;
    if (result.data && result.len > 0)
      resultStr = std::string(result.data, result.len);
    if (result.data)
      std::free(result.data);

    if (callOp.getNumResults() > 0)
      packStringResult(resultStr, callOp.getResult(0));

    LLVM_DEBUG(llvm::dbgs()
               << "  DPI: uvm_re_buffer() = \"" << resultStr << "\"\n");
    return success();
  }

  // ---- uvm_re_free ----
  if (calleeName == "uvm_re_free") {
    if (callOp.getNumOperands() > 0) {
      InterpretedValue ptrVal = getValue(procId, callOp.getOperand(0));
      void *ptr =
          ptrVal.isX() ? nullptr
                       : reinterpret_cast<void *>(ptrVal.getUInt64());
      uvm_re_free(ptr);
      LLVM_DEBUG(llvm::dbgs() << "  DPI: uvm_re_free(" << ptr << ")\n");
    }
    return success();
  }

  // ---- uvm_re_deglobbed ----
  if (calleeName == "uvm_re_deglobbed") {
    std::string glob = extractStringFromVal(callOp.getOperand(0));
    InterpretedValue bracketVal = getValue(procId, callOp.getOperand(1));
    int32_t withBrackets =
        bracketVal.isX() ? 0 : static_cast<int32_t>(bracketVal.getUInt64());

    MooreString globStr = {const_cast<char *>(glob.c_str()),
                           static_cast<int64_t>(glob.size())};
    MooreString result = uvm_re_deglobbed(&globStr, withBrackets);
    std::string resultStr;
    if (result.data && result.len > 0)
      resultStr = std::string(result.data, result.len);
    if (result.data)
      std::free(result.data);

    if (callOp.getNumResults() > 0)
      packStringResult(resultStr, callOp.getResult(0));

    LLVM_DEBUG(llvm::dbgs() << "  DPI: uvm_re_deglobbed(\"" << glob << "\", "
                            << withBrackets << ") = \"" << resultStr << "\"\n");
    return success();
  }

  // ---- uvm_dpi_get_next_arg_c ----
  if (calleeName == "uvm_dpi_get_next_arg_c") {
    InterpretedValue initVal = getValue(procId, callOp.getOperand(0));
    int32_t init =
        initVal.isX() ? 1 : static_cast<int32_t>(initVal.getUInt64());

    MooreString result = uvm_dpi_get_next_arg_c(init);
    std::string resultStr;
    if (result.data && result.len > 0)
      resultStr = std::string(result.data, result.len);
    if (result.data)
      std::free(result.data);

    if (callOp.getNumResults() > 0)
      packStringResult(resultStr, callOp.getResult(0));

    LLVM_DEBUG(llvm::dbgs() << "  DPI: uvm_dpi_get_next_arg_c(" << init
                            << ") = \"" << resultStr << "\"\n");
    return success();
  }

  // ---- uvm_hdl_check_path ----
  if (calleeName == "uvm_hdl_check_path") {
    std::string path = extractStringFromVal(callOp.getOperand(0));

    MooreString pathStr = {const_cast<char *>(path.c_str()),
                           static_cast<int64_t>(path.size())};
    int32_t result = uvm_hdl_check_path(&pathStr);

    if (callOp.getNumResults() > 0)
      setValue(procId, callOp.getResult(0),
              InterpretedValue(APInt(32, static_cast<uint32_t>(result))));

    LLVM_DEBUG(llvm::dbgs() << "  DPI: uvm_hdl_check_path(\"" << path
                            << "\") = " << result << "\n");
    return success();
  }

  // ---- uvm_hdl_deposit ----
  if (calleeName == "uvm_hdl_deposit") {
    std::string path = extractStringFromVal(callOp.getOperand(0));
    InterpretedValue dataArg = getValue(procId, callOp.getOperand(1));
    uvm_hdl_data_t value = 0;
    if (!dataArg.isX()) {
      APInt bits = dataArg.getAPInt();
      value = static_cast<uvm_hdl_data_t>(
          bits.extractBits(64, 0).getZExtValue());
    }

    MooreString pathStr = {const_cast<char *>(path.c_str()),
                           static_cast<int64_t>(path.size())};
    int32_t result = uvm_hdl_deposit(&pathStr, value);

    if (callOp.getNumResults() > 0)
      setValue(procId, callOp.getResult(0),
              InterpretedValue(APInt(32, static_cast<uint32_t>(result))));

    LLVM_DEBUG(llvm::dbgs() << "  DPI: uvm_hdl_deposit(\"" << path << "\", "
                            << value << ") = " << result << "\n");
    return success();
  }

  // ---- uvm_hdl_read ----
  if (calleeName == "uvm_hdl_read") {
    std::string path = extractStringFromVal(callOp.getOperand(0));

    MooreString pathStr = {const_cast<char *>(path.c_str()),
                           static_cast<int64_t>(path.size())};
    uvm_hdl_data_t readValue = 0;
    int32_t result = uvm_hdl_read(&pathStr, &readValue);

    if (callOp.getNumOperands() > 1) {
      Value outputRef = callOp.getOperand(1);
      InterpretedValue refVal = getValue(procId, outputRef);
      Type refType = outputRef.getType();

      if (auto refT = dyn_cast<llhd::RefType>(refType)) {
        Type innerType = refT.getNestedType();
        unsigned innerBits = getTypeWidth(innerType);
        APInt valueBits(innerBits, 0);
        safeInsertBits(valueBits,
            APInt(64, static_cast<uint64_t>(readValue)), 0);
        InterpretedValue writeVal(valueBits);

        unsigned sigId = resolveSignalId(outputRef);
        if (sigId > 0) {
          pendingEpsilonDrives[sigId] = writeVal;
        } else {
          uint64_t addr = refVal.isX() ? 0 : refVal.getUInt64();
          if (addr > 0) {
            uint64_t offset = 0;
            auto *block = findMemoryBlockByAddress(addr, procId, &offset);
            if (block && block->initialized) {
              unsigned innerBytes = (innerBits + 7) / 8;
              for (unsigned i = 0;
                   i < std::min(innerBytes,
                                (unsigned)(block->data.size() - offset));
                   ++i)
                block->data[offset + i] =
                    (i < 8) ? static_cast<uint8_t>(
                                  (readValue >> (i * 8)) & 0xFF)
                            : 0;
            }
          }
        }
      }
    }

    if (callOp.getNumResults() > 0)
      setValue(procId, callOp.getResult(0),
              InterpretedValue(APInt(32, static_cast<uint32_t>(result))));

    LLVM_DEBUG(llvm::dbgs() << "  DPI: uvm_hdl_read(\"" << path << "\") = "
                            << result << " (value=" << readValue << ")\n");
    return success();
  }

  // Not a known DPI function
  return failure();
}

LogicalResult LLHDProcessInterpreter::interpretLLVMFuncBody(
    ProcessId procId, LLVM::LLVMFuncOp funcOp, ArrayRef<InterpretedValue> args,
    SmallVectorImpl<InterpretedValue> &results, ArrayRef<Value> callOperands,
    Operation *callerOp, Block *resumeBlock, Block::iterator resumeOp) {
  // NOTE: processStates uses std::map which guarantees reference stability
  // across inserts/erases, so we can safely cache a pointer to the state.
  // Use the activeProcessState cache when available to avoid std::map lookups.
  ProcessExecutionState *cachedState =
      (procId == activeProcessId && activeProcessState) ? activeProcessState
                                                         : &processStates[procId];

  // Map arguments to block arguments
  Block &entryBlock = funcOp.getBody().front();

  // Track signal mappings created for this call (to clean up later)
  SmallVector<Value, 4> tempSignalMappings;

  // Track recursion depth for this function. Use a local key to avoid
  // dangling reference - DenseMap may rehash during recursive calls.
  Operation *funcKey = funcOp.getOperation();
  unsigned currentDepth = ++funcCallDepth[funcKey];
  bool isRecursive = (currentDepth > 1);

  // Save ALL SSA values defined in this function when recursive.
  llvm::DenseMap<Value, InterpretedValue> savedFuncValues;
  llvm::DenseMap<Value, MemoryBlock> savedFuncMemBlocks;
  if (isRecursive) {
    for (Block &block : funcOp.getBody()) {
      for (auto arg : block.getArguments()) {
        auto it = cachedState->valueMap.find(arg);
        if (it != cachedState->valueMap.end())
          savedFuncValues[arg] = it->second;
        auto mIt = cachedState->memoryBlocks.find(arg);
        if (mIt != cachedState->memoryBlocks.end())
          savedFuncMemBlocks[arg] = mIt->second;
      }
      for (Operation &op : block) {
        for (auto result : op.getResults()) {
          auto it = cachedState->valueMap.find(result);
          if (it != cachedState->valueMap.end())
            savedFuncValues[result] = it->second;
          auto mIt = cachedState->memoryBlocks.find(result);
          if (mIt != cachedState->memoryBlocks.end())
            savedFuncMemBlocks[result] = mIt->second;
        }
      }
    }
  }

  for (auto [idx, blockArg] :
       llvm::enumerate(entryBlock.getArguments())) {
    if (idx < args.size())
      cachedState->valueMap[blockArg] = args[idx];

    // If call operands are provided, create signal mappings for BlockArguments
    // when the corresponding call operand resolves to a signal ID.
    // This allows llhd.prb to work on signal references passed as function args.
    if (idx < callOperands.size()) {
      if (SignalId sigId = resolveSignalId(callOperands[idx])) {
        valueToSignal[blockArg] = sigId;
        tempSignalMappings.push_back(blockArg);
        LLVM_DEBUG(llvm::dbgs()
                   << "  Created temp signal mapping for BlockArg " << idx
                   << " -> signal " << sigId << "\n");
      }
    }
  }

  // Helper to restore saved function values and decrement recursion depth
  auto restoreSavedFuncValues = [&]() {
    --funcCallDepth[funcKey];
    if (isRecursive) {
      for (const auto &[val, saved] : savedFuncValues)
        cachedState->valueMap[val] = saved;
      for (auto &[val, saved] : savedFuncMemBlocks)
        cachedState->memoryBlocks[val] = saved;
    }
  };

  // Set current function name for progress reporting and save previous
  std::string prevFuncName = cachedState->currentFuncName;
  cachedState->currentFuncName = funcOp.getName().str();

  // Helper to clean up temporary signal mappings and restore values
  auto cleanupTempMappings = [&]() {
    for (Value v : tempSignalMappings) {
      valueToSignal.erase(v);
    }
    restoreSavedFuncValues();
    // Restore previous function name
    cachedState->currentFuncName = prevFuncName;
  };

  // Execute the function body with operation limit to prevent infinite loops
  Block *currentBlock = resumeBlock ? resumeBlock : &entryBlock;
  constexpr size_t maxOps = 1000000;
  size_t opCount = 0;

  // Track if we're starting from a resume point
  bool skipToResumeOp = (resumeBlock != nullptr);

  while (currentBlock && opCount < maxOps) {
    bool tookBranch = false;
    for (auto opIt = currentBlock->begin(); opIt != currentBlock->end();
         ++opIt) {
      Operation &op = *opIt;

      // If resuming, skip operations until we reach the resume point
      if (skipToResumeOp) {
        if (&op == &*resumeOp) {
          skipToResumeOp = false;
          LLVM_DEBUG(llvm::dbgs()
                     << "  Resuming LLVM function " << funcOp.getName()
                     << " from saved position\n");
        } else {
          continue;
        }
      }

      ++opCount;
      // Track func body steps in process state for global step limiting
      {
          ++cachedState->totalSteps;
          ++cachedState->funcBodySteps;
          maybeSampleMemoryState(cachedState->totalSteps);
          if (collectOpStats)
            ++opStats[op.getName().getStringRef()];
          // Progress report every ~16M func body steps (power-of-2 for cheap
          // bitwise check instead of expensive integer division)
          if ((cachedState->funcBodySteps & 0xFFFFFF) == 0) {
            llvm::errs() << "[circt-sim] func progress: process " << procId
                         << " funcBodySteps=" << cachedState->funcBodySteps
                         << " totalSteps=" << cachedState->totalSteps
                         << " in '" << funcOp.getName() << "'"
                         << " (callDepth=" << cachedState->callDepth << ")"
                         << " op=" << op.getName().getStringRef()
                         << "\n";
          }
          // Enforce global process step limit inside function bodies
          if (maxProcessSteps > 0 &&
              cachedState->totalSteps > (size_t)maxProcessSteps) {
            llvm::errs()
                << "[circt-sim] ERROR(PROCESS_STEP_OVERFLOW in func): process "
                << procId << " exceeded " << maxProcessSteps
                << " total steps in LLVM function '" << funcOp.getName() << "'"
                << " (totalSteps=" << cachedState->totalSteps << ")\n";
            cachedState->halted = true;
            cleanupTempMappings();
            return failure();
          }
          // Periodically check for abort (timeout watchdog, every ~16K ops)
          if ((cachedState->funcBodySteps & 0x3FFF) == 0 && isAbortRequested()) {
            cachedState->halted = true;
            cleanupTempMappings();
            if (abortCallback)
              abortCallback();
            return failure();
          }
      }
      if (opCount >= maxOps) {
        LLVM_DEBUG(llvm::dbgs() << "  Warning: LLVM function '"
                                << funcOp.getName()
                                << "' reached max operations (" << maxOps
                                << ")\n");
        cleanupTempMappings();
        return failure();
      }

      // Handle return
      if (auto returnOp = dyn_cast<LLVM::ReturnOp>(&op)) {
        for (Value retVal : returnOp.getOperands()) {
          results.push_back(getValue(procId, retVal));
        }
        cleanupTempMappings();
        return success();
      }

      // Handle branch
      if (auto branchOp = dyn_cast<LLVM::BrOp>(&op)) {
        currentBlock = branchOp.getDest();
        for (auto [blockArg, operand] :
             llvm::zip(currentBlock->getArguments(), branchOp.getDestOperands())) {
          cachedState->valueMap[blockArg] = getValue(procId, operand);
        }
        tookBranch = true;
        break;
      }

      // Handle conditional branch
      if (auto condBrOp = dyn_cast<LLVM::CondBrOp>(&op)) {
        InterpretedValue cond = getValue(procId, condBrOp.getCondition());
        if (!cond.isX() && cond.getUInt64() != 0) {
          currentBlock = condBrOp.getTrueDest();
          for (auto [blockArg, operand] :
               llvm::zip(currentBlock->getArguments(),
                        condBrOp.getTrueDestOperands())) {
            cachedState->valueMap[blockArg] = getValue(procId, operand);
          }
        } else {
          currentBlock = condBrOp.getFalseDest();
          for (auto [blockArg, operand] :
               llvm::zip(currentBlock->getArguments(),
                        condBrOp.getFalseDestOperands())) {
            cachedState->valueMap[blockArg] = getValue(procId, operand);
          }
        }
        tookBranch = true;
        break;
      }

      // Fast-path: handle cf dialect branch ops inline (7.4% of ops)
      // to avoid falling through the full interpretOperation dispatch chain.
      if (auto cfCondBrOp = dyn_cast<mlir::cf::CondBranchOp>(&op)) {
        InterpretedValue cond = getValue(procId, cfCondBrOp.getCondition());
        if (!cond.isX() && cond.getUInt64() != 0) {
          currentBlock = cfCondBrOp.getTrueDest();
          for (auto [blockArg, operand] :
               llvm::zip(currentBlock->getArguments(),
                        cfCondBrOp.getTrueDestOperands())) {
            cachedState->valueMap[blockArg] = getValue(procId, operand);
          }
        } else {
          currentBlock = cfCondBrOp.getFalseDest();
          for (auto [blockArg, operand] :
               llvm::zip(currentBlock->getArguments(),
                        cfCondBrOp.getFalseDestOperands())) {
            cachedState->valueMap[blockArg] = getValue(procId, operand);
          }
        }
        tookBranch = true;
        break;
      }

      if (auto cfBrOp = dyn_cast<mlir::cf::BranchOp>(&op)) {
        currentBlock = cfBrOp.getDest();
        for (auto [blockArg, operand] :
             llvm::zip(currentBlock->getArguments(),
                      cfBrOp.getDestOperands())) {
          cachedState->valueMap[blockArg] = getValue(procId, operand);
        }
        tookBranch = true;
        break;
      }

      // Interpret other operations
      if (failed(interpretOperation(procId, &op))) {
        llvm::errs() << "circt-sim: Failed in LLVM func body for process "
                     << procId << "\n";
        llvm::errs() << "  Function: " << funcOp.getName() << "\n";
        llvm::errs() << "  Operation: ";
        op.print(llvm::errs(), OpPrintingFlags().printGenericOpForm());
        llvm::errs() << "\n";
        llvm::errs() << "  Location: " << op.getLoc() << "\n";
        cleanupTempMappings();
        return failure();
      }

      // Check if process was halted or is waiting (e.g., by sim.terminate,
      // llvm.unreachable, moore.wait_event, or __moore_delay). Save a call
      // stack frame so the function can be resumed from the correct position.
      if (cachedState->halted || cachedState->waiting) {
          LLVM_DEBUG(llvm::dbgs()
                     << "  Process halted/waiting during LLVM function body '"
                     << funcOp.getName() << "'\n");

          // If waiting (not halted), save a call stack frame for resumption
          if (cachedState->waiting && callerOp) {
            auto nextOpIt = opIt;
            ++nextOpIt;

            // Only save if there are more operations to execute
            if (nextOpIt != currentBlock->end() ||
                currentBlock != &entryBlock) {
              CallStackFrame frame(funcOp, currentBlock, nextOpIt, callerOp);
              frame.args.assign(args.begin(), args.end());
              frame.callOperands.assign(callOperands.begin(),
                                        callOperands.end());
              cachedState->callStack.push_back(std::move(frame));
              LLVM_DEBUG(llvm::dbgs()
                         << "    Saved LLVM call frame for function '"
                         << funcOp.getName() << "' with " << args.size()
                         << " args, will resume after current op\n");
            }
          }

          cleanupTempMappings();
          return success();
      }
    }

    // If we didn't branch, we're done
    if (!tookBranch)
      break;
  }

  // If no return was encountered, return nothing
  cleanupTempMappings();
  return success();
}

//===----------------------------------------------------------------------===//
// RTTI Parent Table (for $cast hierarchy checking)
//===----------------------------------------------------------------------===//

void LLHDProcessInterpreter::loadRTTIParentTable() {
  if (rttiTableLoaded)
    return;
  rttiTableLoaded = true;

  if (!rootModule)
    return;

  // Look for the circt.rtti_parent_table module attribute emitted by
  // MooreToCore. It maps typeId -> parentTypeId (0 = root).
  // The attribute is on the builtin.module (rootModule itself), not its parent.
  auto tableAttr =
      rootModule->getAttrOfType<DenseIntElementsAttr>("circt.rtti_parent_table");
  if (!tableAttr)
    return;

  rttiParentTable.clear();
  for (auto val : tableAttr.getValues<int32_t>())
    rttiParentTable.push_back(val);

  LLVM_DEBUG(llvm::dbgs() << "Loaded RTTI parent table with "
                          << rttiParentTable.size() << " entries\n");
}

bool LLHDProcessInterpreter::checkRTTICast(int32_t srcTypeId,
                                            int32_t targetTypeId) {
  if (srcTypeId == 0 || targetTypeId == 0)
    return false;
  if (srcTypeId == targetTypeId)
    return true;

  // Load the RTTI table on first use
  loadRTTIParentTable();

  // If we have a hierarchy table, walk the parent chain
  if (!rttiParentTable.empty()) {
    int32_t current = srcTypeId;
    // Guard against infinite loops with a max depth
    for (int i = 0; i < 1000 && current != 0; ++i) {
      if (current < 0 || current >= static_cast<int32_t>(rttiParentTable.size()))
        break;
      current = rttiParentTable[current];
      if (current == targetTypeId)
        return true;
    }
    return false;
  }

  // Fallback: use the simple >= heuristic (backward compat for old MLIR files)
  return srcTypeId >= targetTypeId;
}

//===----------------------------------------------------------------------===//
// Global Variable and VTable Support
//===----------------------------------------------------------------------===//

LogicalResult
LLHDProcessInterpreter::initializeGlobals(const DiscoveredGlobalOps &globalOps) {
  if (!rootModule)
    return success();

  LLVM_DEBUG(llvm::dbgs() << "LLHDProcessInterpreter: Initializing globals\n");

  // Process all pre-discovered LLVM global operations (no walk() needed)
  for (LLVM::GlobalOp globalOp : globalOps.globals) {
    StringRef globalName = globalOp.getSymName();

    LLVM_DEBUG(llvm::dbgs() << "  Found global: " << globalName << "\n");

    // Get the global's type to calculate size
    Type globalType = globalOp.getGlobalType();
    unsigned size = getLLVMTypeSizeForGEP(globalType);
    if (size == 0)
      size = 8; // Default minimum size

    // Allocate memory for the global
    uint64_t addr = nextGlobalAddress;
    nextGlobalAddress += ((size + 7) / 8) * 8; // Align to 8 bytes

    globalAddresses[globalName] = addr;
    addrRangeIndexDirty = true;

    // Also populate the reverse map for address-to-global lookup
    addressToGlobal[addr] = globalName.str();

    // Create memory block
    MemoryBlock block(size, 64);

    // Check the initializer attribute
    // Handle both #llvm.zero and string constant initializers
    if (auto initAttr = globalOp.getValueOrNull()) {
      block.initialized = true;

      // Check if this is a string initializer
      if (auto strAttr = dyn_cast<StringAttr>(initAttr)) {
        StringRef strContent = strAttr.getValue();
        // Copy the string content to the memory block
        size_t copyLen = std::min(strContent.size(), block.data.size());
        std::memcpy(block.data.data(), strContent.data(), copyLen);
        LLVM_DEBUG(llvm::dbgs() << "    Initialized with string: \""
                                << strContent << "\" (" << copyLen << " bytes)\n");
      } else {
        // For #llvm.zero or other initializers, data is already zeroed
        LLVM_DEBUG(llvm::dbgs() << "    Initialized to zero\n");
      }
    }

    // Check if this is a vtable (has circt.vtable_entries attribute)
    if (auto vtableEntriesAttr = globalOp->getAttr("circt.vtable_entries")) {
      LLVM_DEBUG(llvm::dbgs() << "    This is a vtable with entries\n");

      if (auto entriesArray = dyn_cast<ArrayAttr>(vtableEntriesAttr)) {
        // Each entry is [index, funcSymbol]
        for (auto entry : entriesArray) {
          if (auto entryArray = dyn_cast<ArrayAttr>(entry)) {
            if (entryArray.size() >= 2) {
              auto indexAttr = dyn_cast<IntegerAttr>(entryArray[0]);
              auto funcSymbol = dyn_cast<FlatSymbolRefAttr>(entryArray[1]);

              if (indexAttr && funcSymbol) {
                unsigned index = indexAttr.getInt();
                StringRef funcName = funcSymbol.getValue();

                // Create a unique "function address" for this function
                // We use a simple scheme: high bits identify it as a function ptr
                uint64_t funcAddr = 0xF0000000 + addressToFunction.size();
                addressToFunction[funcAddr] = funcName.str();

                // Store the function address in the vtable memory
                // (little-endian)
                for (unsigned i = 0; i < 8 && (index * 8 + i) < block.data.size(); ++i) {
                  block.data[index * 8 + i] = (funcAddr >> (i * 8)) & 0xFF;
                }
                block.initialized = true;

                LLVM_DEBUG(llvm::dbgs() << "      Entry " << index << ": "
                                        << funcName << " -> 0x"
                                        << llvm::format_hex(funcAddr, 16) << "\n");
              }
            }
          }
        }
      }
    }

    globalMemoryBlocks[globalName] = std::move(block);
  }

  LLVM_DEBUG(llvm::dbgs() << "LLHDProcessInterpreter: Initialized "
                          << globalMemoryBlocks.size() << " globals, "
                          << addressToFunction.size() << " vtable entries\n");

  return success();
}

LogicalResult LLHDProcessInterpreter::executeGlobalConstructors(
    const DiscoveredGlobalOps &globalOps) {
  if (!rootModule)
    return success();

  LLVM_DEBUG(llvm::dbgs()
             << "LLHDProcessInterpreter: Executing global constructors\n");

  // Collect all constructor entries with their priorities from pre-discovered ops
  SmallVector<std::pair<int32_t, StringRef>, 4> ctorEntries;

  for (LLVM::GlobalCtorsOp ctorsOp : globalOps.ctors) {
    ArrayAttr ctors = ctorsOp.getCtors();
    ArrayAttr priorities = ctorsOp.getPriorities();

    for (auto [ctorAttr, priorityAttr] : llvm::zip(ctors, priorities)) {
      auto ctorRef = cast<FlatSymbolRefAttr>(ctorAttr);
      auto priority = cast<IntegerAttr>(priorityAttr).getInt();
      ctorEntries.emplace_back(priority, ctorRef.getValue());
      LLVM_DEBUG(llvm::dbgs() << "  Found constructor: " << ctorRef.getValue()
                              << " (priority " << priority << ")\n");
    }
  }

  if (ctorEntries.empty()) {
    LLVM_DEBUG(llvm::dbgs() << "  No global constructors found\n");
    return success();
  }

  // Sort by priority (lower priority values execute first)
  llvm::sort(ctorEntries,
             [](const auto &a, const auto &b) { return a.first < b.first; });

  // Create a temporary process state for executing constructors.
  // Must use a non-zero ID because InvalidProcessId == 0 and
  // findMemoryBlockByAddress's walk loop skips process ID 0.
  ProcessExecutionState tempState;
  ProcessId tempProcId = nextTempProcId++;
  while (processStates.count(tempProcId) || tempProcId == InvalidProcessId)
    tempProcId = nextTempProcId++;
  processStates[tempProcId] = std::move(tempState);

  // Execute each constructor in priority order
  for (auto &[priority, ctorName] : ctorEntries) {
    LLVM_DEBUG(llvm::dbgs() << "  Calling constructor: " << ctorName
                            << " (priority " << priority << ")\n");

    // Reset the temporary process state between constructors.
    // Global constructors are independent; if one sets halted/waiting
    // (e.g., due to an X vtable dispatch that triggers llvm.unreachable),
    // subsequent constructors must not inherit that state.
    {
      auto &ts = processStates[tempProcId];
      ts.halted = false;
      ts.waiting = false;
    }

    // Look up the LLVM function
    auto funcOp = rootModule.lookupSymbol<LLVM::LLVMFuncOp>(ctorName);
    if (!funcOp) {
      LLVM_DEBUG(llvm::dbgs() << "    Warning: constructor function '"
                              << ctorName << "' not found\n");
      continue;
    }

    // Call the constructor with no arguments
    SmallVector<InterpretedValue, 2> results;
    if (failed(interpretLLVMFuncBody(tempProcId, funcOp, {}, results))) {
      LLVM_DEBUG(llvm::dbgs()
                 << "    Warning: failed to execute constructor '" << ctorName
                 << "'\n");
      // Continue with other constructors even if one fails
    }
  }

  // Clean up the temporary process state
  processStates.erase(tempProcId);

  LLVM_DEBUG(llvm::dbgs() << "LLHDProcessInterpreter: Executed "
                          << ctorEntries.size() << " global constructors\n");

  return success();
}

LogicalResult LLHDProcessInterpreter::executeModuleLevelLLVMOps(
    hw::HWModuleOp hwModule) {
  LLVM_DEBUG(llvm::dbgs()
             << "LLHDProcessInterpreter: Executing module-level LLVM ops\n");

  // Create a temporary process state for executing module-level ops.
  // Must use a non-zero ID because InvalidProcessId == 0 and
  // findMemoryBlockByAddress's walk loop skips process ID 0.
  ProcessExecutionState tempState;
  ProcessId tempProcId = nextTempProcId++;
  while (processStates.count(tempProcId) || tempProcId == InvalidProcessId)
    tempProcId = nextTempProcId++;
  processStates[tempProcId] = std::move(tempState);

  unsigned opsExecuted = 0;

  // Walk the module body (but not inside processes) and execute LLVM ops
  // We need to execute them in order, so iterate through the block directly.
  for (Operation &op : hwModule.getBody().front()) {
    // Skip llhd.process and seq.initial - those have their own execution
    if (isa<llhd::ProcessOp, seq::InitialOp, llhd::CombinationalOp>(&op))
      continue;

    // Execute LLVM operations that need initialization
    if (auto allocaOp = dyn_cast<LLVM::AllocaOp>(&op)) {
      (void)interpretLLVMAlloca(tempProcId, allocaOp);
      ++opsExecuted;
    } else if (auto storeOp = dyn_cast<LLVM::StoreOp>(&op)) {
      (void)interpretLLVMStore(tempProcId, storeOp);
      ++opsExecuted;
    } else if (auto callOp = dyn_cast<LLVM::CallOp>(&op)) {
      (void)interpretLLVMCall(tempProcId, callOp);
      ++opsExecuted;
    } else if (auto constOp = dyn_cast<LLVM::ConstantOp>(&op)) {
      // Evaluate LLVM constants so they're in the value map
      if (auto intAttr = dyn_cast<IntegerAttr>(constOp.getValue())) {
        setValue(tempProcId, constOp.getResult(),
                 InterpretedValue(intAttr.getValue()));
        ++opsExecuted;
      }
    } else if (auto hwConstOp = dyn_cast<hw::ConstantOp>(&op)) {
      // Evaluate HW constants (used as arguments to LLVM calls)
      setValue(tempProcId, hwConstOp.getResult(),
               InterpretedValue(hwConstOp.getValue()));
      ++opsExecuted;
    } else if (auto undefOp = dyn_cast<LLVM::UndefOp>(&op)) {
      unsigned width = getTypeWidth(undefOp.getType());
      setValue(tempProcId, undefOp.getResult(),
               InterpretedValue(APInt::getZero(width)));
      ++opsExecuted;
    } else if (auto zeroOp = dyn_cast<LLVM::ZeroOp>(&op)) {
      setValue(tempProcId, zeroOp.getResult(), InterpretedValue(0, 64));
      ++opsExecuted;
    } else if (auto addrOfOp = dyn_cast<LLVM::AddressOfOp>(&op)) {
      (void)interpretLLVMAddressOf(tempProcId, addrOfOp);
      ++opsExecuted;
    } else if (auto loadOp = dyn_cast<LLVM::LoadOp>(&op)) {
      (void)interpretLLVMLoad(tempProcId, loadOp);
      ++opsExecuted;
    } else if (isa<LLVM::InsertValueOp>(&op)) {
      (void)interpretOperation(tempProcId, &op);
      ++opsExecuted;
    }
  }

  // Update signal initial values for llhd.sig ops whose init was computed
  // by module-level LLVM ops (e.g., covergroup handles loaded from globals).
  // registerSignals runs before this function, so signals whose init value
  // comes from an llvm.load or llvm.call result still have their default
  // value (0). Now that the LLVM ops have executed, we can update them.
  for (Operation &op : hwModule.getBody().front()) {
    auto sigOp = dyn_cast<llhd::SignalOp>(&op);
    if (!sigOp)
      continue;
    auto it = processStates[tempProcId].valueMap.find(sigOp.getInit());
    if (it == processStates[tempProcId].valueMap.end())
      continue;
    InterpretedValue initVal = it->second;
    if (initVal.isX() || initVal.getUInt64() == 0)
      continue;
    SignalId sigId = valueToSignal.lookup(sigOp.getResult());
    if (sigId == 0)
      continue;
    scheduler.updateSignal(sigId, initVal.toSignalValue());
    LLVM_DEBUG(llvm::dbgs()
               << "  Updated signal " << sigId << " initial value from "
               << "module-level LLVM op result\n");
  }

  // Copy the module-level value map to a special "module init" state
  // that processes can access for module-level values
  moduleInitValueMap = std::move(processStates[tempProcId].valueMap);

  // Copy module-level memory blocks too
  for (auto &[value, block] : processStates[tempProcId].memoryBlocks) {
    moduleLevelAllocas[value] = std::move(block);
  }

  // Clean up the temporary process state
  processStates.erase(tempProcId);

  LLVM_DEBUG(llvm::dbgs() << "LLHDProcessInterpreter: Executed " << opsExecuted
                          << " module-level LLVM ops\n");

  return success();
}

void LLHDProcessInterpreter::executeChildModuleLevelOps() {
  for (auto &deferred : deferredChildModuleOps) {
    hw::HWModuleOp childModule = deferred.childModule;
    InstanceId instanceId = deferred.instanceId;
    const InstanceInputMapping &instanceInputMap = deferred.inputMap;
    const DiscoveredOps &childOps = deferred.childOps;
    hw::InstanceOp instOp = deferred.instOp;

    ProcessExecutionState childTempState;
    ProcessId childTempProcId = nextTempProcId++;
    while (processStates.count(childTempProcId) ||
           childTempProcId == InvalidProcessId)
      childTempProcId = nextTempProcId++;
    processStates[childTempProcId] = std::move(childTempState);

    // Set instance context so getSignalId resolves child signals
    ScopedInstanceContext instScope(*this, instanceId);
    ScopedInputValueMap inputScope(*this, instanceInputMap);

    unsigned childOpsExecuted = 0;
    for (Operation &op : childModule.getBody().front()) {
      if (isa<llhd::ProcessOp, seq::InitialOp, llhd::CombinationalOp,
              llhd::SignalOp, hw::InstanceOp, hw::OutputOp>(&op))
        continue;

      if (auto allocaOp = dyn_cast<LLVM::AllocaOp>(&op)) {
        (void)interpretLLVMAlloca(childTempProcId, allocaOp);
        ++childOpsExecuted;
      } else if (auto storeOp = dyn_cast<LLVM::StoreOp>(&op)) {
        (void)interpretLLVMStore(childTempProcId, storeOp);
        ++childOpsExecuted;
        // Record interface field copy pairs for propagation links.
        InterpretedValue destAddr =
            getValue(childTempProcId, storeOp.getAddr());
        if (!destAddr.isX() && destAddr.getUInt64() != 0) {
          auto getChildOrParentValue = [&](Value v) -> uint64_t {
            InterpretedValue val = getValue(childTempProcId, v);
            if (!val.isX() && val.getUInt64() != 0)
              return val.getUInt64();
            auto it = moduleInitValueMap.find(v);
            if (it != moduleInitValueMap.end() && !it->second.isX())
              return it->second.getUInt64();
            return 0;
          };
          std::function<uint64_t(Value)> traceSrcLoadAddr =
              [&](Value v) -> uint64_t {
            if (auto *defOp = v.getDefiningOp()) {
              LLVM_DEBUG(llvm::dbgs()
                         << "traceSrcLoadAddr op="
                         << defOp->getName().getStringRef() << "\n");
              if (auto extractOp = dyn_cast<LLVM::ExtractValueOp>(defOp))
                return traceSrcLoadAddr(extractOp.getContainer());
              if (auto insertOp = dyn_cast<LLVM::InsertValueOp>(defOp)) {
                uint64_t addr = traceSrcLoadAddr(insertOp.getValue());
                if (addr != 0)
                  return addr;
                return traceSrcLoadAddr(insertOp.getContainer());
              }
              if (auto loadOp = dyn_cast<LLVM::LoadOp>(defOp)) {
                Value loadAddr = loadOp.getAddr();
                uint64_t addr = getChildOrParentValue(loadAddr);
                LLVM_DEBUG(llvm::dbgs()
                           << "traceSrcLoadAddr load addr=0x"
                           << llvm::format_hex(addr, 10));
                if (auto *addrOp = loadAddr.getDefiningOp())
                  LLVM_DEBUG(llvm::dbgs()
                             << " addrOp="
                             << addrOp->getName().getStringRef());
                else
                  LLVM_DEBUG(llvm::dbgs() << " addrOp=<blockarg>");
                LLVM_DEBUG(llvm::dbgs() << "\n");
                if (addr != 0)
                  return addr;
              }
            } else {
              LLVM_DEBUG(llvm::dbgs() << "traceSrcLoadAddr <blockarg>\n");
            }
            return 0;
          };
          uint64_t srcAddr = traceSrcLoadAddr(storeOp.getValue());
          LLVM_DEBUG({
            llvm::dbgs() << "child store: destAddr=0x"
                         << llvm::format_hex(destAddr.getUInt64(), 10)
                         << " srcAddr=0x" << llvm::format_hex(srcAddr, 10);
            if (auto *defOp = storeOp.getValue().getDefiningOp())
              llvm::dbgs() << " storeVal=" << defOp->getName().getStringRef();
            else
              llvm::dbgs() << " storeVal=<blockarg>";
            llvm::dbgs() << "\n";
          });
          // Check if it's a load (after canonicalization simplified away insert/extract)
          if (auto loadOp = storeOp.getValue().getDefiningOp<LLVM::LoadOp>()) {
            Value loadAddr = loadOp.getAddr();
            InterpretedValue addrVal = getValue(childTempProcId, loadAddr);
            LLVM_DEBUG(llvm::dbgs() << "  direct load addr=0x"
                                    << llvm::format_hex(addrVal.isX() ? 0ULL : addrVal.getUInt64(), 10)
                                    << " isX=" << addrVal.isX() << "\n");
          }
          if (srcAddr != 0)
            childModuleCopyPairs.push_back({srcAddr, destAddr.getUInt64()});
        }
      } else if (auto callOp = dyn_cast<LLVM::CallOp>(&op)) {
        (void)interpretLLVMCall(childTempProcId, callOp);
        ++childOpsExecuted;
      } else if (auto constOp = dyn_cast<LLVM::ConstantOp>(&op)) {
        if (auto intAttr = dyn_cast<IntegerAttr>(constOp.getValue())) {
          setValue(childTempProcId, constOp.getResult(),
                   InterpretedValue(intAttr.getValue()));
          ++childOpsExecuted;
        }
      } else if (auto hwConstOp = dyn_cast<hw::ConstantOp>(&op)) {
        setValue(childTempProcId, hwConstOp.getResult(),
                 InterpretedValue(hwConstOp.getValue()));
        ++childOpsExecuted;
      } else if (auto undefOp = dyn_cast<LLVM::UndefOp>(&op)) {
        unsigned width = getTypeWidth(undefOp.getType());
        setValue(childTempProcId, undefOp.getResult(),
                 InterpretedValue(APInt::getZero(width)));
        ++childOpsExecuted;
      } else if (auto zeroOp = dyn_cast<LLVM::ZeroOp>(&op)) {
        setValue(childTempProcId, zeroOp.getResult(), InterpretedValue(0, 64));
        ++childOpsExecuted;
      } else if (auto addrOfOp = dyn_cast<LLVM::AddressOfOp>(&op)) {
        (void)interpretLLVMAddressOf(childTempProcId, addrOfOp);
        ++childOpsExecuted;
      } else if (auto loadOp = dyn_cast<LLVM::LoadOp>(&op)) {
        (void)interpretLLVMLoad(childTempProcId, loadOp);
        ++childOpsExecuted;
      } else if (isa<LLVM::InsertValueOp, LLVM::ExtractValueOp>(&op)) {
        (void)interpretOperation(childTempProcId, &op);
        ++childOpsExecuted;
      } else if (auto gepOp = dyn_cast<LLVM::GEPOp>(&op)) {
        (void)interpretOperation(childTempProcId, &op);
        ++childOpsExecuted;
      } else if (auto probeOp = dyn_cast<llhd::ProbeOp>(&op)) {
        // For child signal probes, try the temp valueMap for computed init
        // values first. For parent signal probes (via ScopedInputValueMap),
        // the scheduler now has correct values since executeModuleLevelLLVMOps
        // ran first.
        Value sig = probeOp.getSignal();
        bool handled = false;
        for (auto &[sigVal, sigId] : instanceValueToSignal[instanceId]) {
          if (sigVal == sig) {
            auto sigOp = sigVal.getDefiningOp<llhd::SignalOp>();
            if (sigOp) {
              auto initIt =
                  processStates[childTempProcId].valueMap.find(sigOp.getInit());
              if (initIt != processStates[childTempProcId].valueMap.end() &&
                  !initIt->second.isX()) {
                setValue(childTempProcId, probeOp.getResult(), initIt->second);
                handled = true;
                break;
              }
            }
            break;
          }
        }
        if (!handled)
          (void)interpretOperation(childTempProcId, &op);
        ++childOpsExecuted;
      }
    }

    // Update child signal initial values from computed results
    for (llhd::SignalOp sigOp : childOps.signals) {
      auto it =
          processStates[childTempProcId].valueMap.find(sigOp.getInit());
      if (it == processStates[childTempProcId].valueMap.end())
        continue;
      InterpretedValue initVal = it->second;
      if (initVal.isX() || initVal.getUInt64() == 0)
        continue;
      auto sigIt = instanceValueToSignal[instanceId].find(sigOp.getResult());
      if (sigIt == instanceValueToSignal[instanceId].end())
        continue;
      SignalId sigId = sigIt->second;
      scheduler.updateSignal(sigId, initVal.toSignalValue());
      LLVM_DEBUG(llvm::dbgs()
                 << "    Updated child signal " << sigId
                 << " from module-level op result\n");
    }

    // Copy child module-level values into moduleInitValueMap
    for (auto &[val, intVal] : processStates[childTempProcId].valueMap)
      moduleInitValueMap.try_emplace(val, intVal);

    // Copy child module-level memory blocks to moduleLevelAllocas
    for (auto &[val, block] : processStates[childTempProcId].memoryBlocks)
      moduleLevelAllocas.try_emplace(val, std::move(block));

    processStates.erase(childTempProcId);

    if (childOpsExecuted > 0) {
      LLVM_DEBUG(llvm::dbgs()
                 << "    Executed " << childOpsExecuted
                 << " deferred child module-level LLVM ops for '"
                 << instOp.getInstanceName() << "'\n");
    }
  }
  deferredChildModuleOps.clear();
}

LogicalResult LLHDProcessInterpreter::interpretLLVMAddressOf(
    ProcessId procId, LLVM::AddressOfOp addrOfOp) {
  StringRef globalName = addrOfOp.getGlobalName();

  // Look up the global's address
  auto it = globalAddresses.find(globalName);
  if (it == globalAddresses.end()) {
    LLVM_DEBUG(llvm::dbgs() << "  llvm.addressof: global '" << globalName
                            << "' not found, returning X\n");
    setValue(procId, addrOfOp.getResult(),
             InterpretedValue::makeX(64));
    return success();
  }

  uint64_t addr = it->second;
  setValue(procId, addrOfOp.getResult(), InterpretedValue(addr, 64));

  LLVM_DEBUG(llvm::dbgs() << "  llvm.addressof: " << globalName << " = 0x"
                          << llvm::format_hex(addr, 16) << "\n");

  return success();
}
