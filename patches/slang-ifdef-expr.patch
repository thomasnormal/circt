diff --git a/source/parsing/Preprocessor.cpp b/source/parsing/Preprocessor.cpp
index a324b67..9d181a7 100644
--- a/source/parsing/Preprocessor.cpp
+++ b/source/parsing/Preprocessor.cpp
@@ -16,6 +16,8 @@
 #include "slang/util/String.h"
 #include "slang/util/VersionInfo.h"
 
+#include <optional>
+
 namespace slang::parsing {
 
 using namespace syntax;
@@ -1151,15 +1153,20 @@ Trivia Preprocessor::handleDefaultTriregStrengthDirective(Token directive) {
 }
 
 ConditionalDirectiveExpressionSyntax* Preprocessor::parseConditionalExpr() {
-    auto isBinaryOp = [](TokenKind kind) {
+    auto getPrecedence = [](TokenKind kind) {
         switch (kind) {
+            case TokenKind::DoubleEquals:
+            case TokenKind::ExclamationEquals:
+                return 30;
             case TokenKind::DoubleAnd:
+                return 20;
             case TokenKind::DoubleOr:
+                return 10;
             case TokenKind::MinusArrow:
             case TokenKind::LessThanMinusArrow:
-                return true;
+                return 5;
             default:
-                return false;
+                return -1;
         }
     };
 
@@ -1173,54 +1180,85 @@ ConditionalDirectiveExpressionSyntax* Preprocessor::parseConditionalExpr() {
                                                                                     *operand,
                                                                                     closeParen);
         }
-        else {
-            auto id = expect(TokenKind::Identifier);
-            return alloc.emplace<NamedConditionalDirectiveExpressionSyntax>(id);
+        if (token.kind == TokenKind::IntegerLiteral) {
+            return alloc.emplace<NamedConditionalDirectiveExpressionSyntax>(consume());
         }
+        auto id = expect(TokenKind::Identifier);
+        return alloc.emplace<NamedConditionalDirectiveExpressionSyntax>(id);
     };
 
-    ConditionalDirectiveExpressionSyntax* left;
-    if (peek(TokenKind::Exclamation)) {
-        auto op = consume();
-        auto operand = parsePrimary();
-        left = alloc.emplace<UnaryConditionalDirectiveExpressionSyntax>(op, *operand);
-    }
-    else {
-        left = parsePrimary();
-    }
-
-    while (true) {
-        if (!isBinaryOp(peek().kind))
-            break;
+    auto parseExpr = [&](auto&& self, int minPrecedence)
+        -> ConditionalDirectiveExpressionSyntax* {
+        auto parseUnary = [&](auto&& unarySelf) -> ConditionalDirectiveExpressionSyntax* {
+            if (peek(TokenKind::Exclamation)) {
+                auto op = consume();
+                auto operand = unarySelf(unarySelf);
+                return alloc.emplace<UnaryConditionalDirectiveExpressionSyntax>(op, *operand);
+            }
+            return parsePrimary();
+        };
 
-        auto op = consume();
-        auto right = parseConditionalExpr();
-        left = alloc.emplace<BinaryConditionalDirectiveExpressionSyntax>(*left, op, *right);
-    }
+        auto left = parseUnary(parseUnary);
+        while (true) {
+            if (!peekSameLine())
+                break;
+            int prec = getPrecedence(peek().kind);
+            if (prec < minPrecedence)
+                break;
+            auto op = consume();
+            auto right = self(self, prec + 1);
+            left = alloc.emplace<BinaryConditionalDirectiveExpressionSyntax>(*left, op, *right);
+        }
+        return left;
+    };
 
-    return left;
+    return parseExpr(parseExpr, 0);
 }
 
 ConditionalDirectiveExpressionSyntax& Preprocessor::parseConditionalExprTop() {
-    SLANG_ASSERT(!inIfDefCondition);
-    auto guard = ScopeGuard([this] { inIfDefCondition = false; });
+    bool prevIfDefCondition = inIfDefCondition;
+    auto guard = ScopeGuard([this, prevIfDefCondition] { inIfDefCondition = prevIfDefCondition; });
     inIfDefCondition = true;
 
-    if (peek(TokenKind::OpenParenthesis)) {
-        auto result = parseConditionalExpr();
-        if (options.languageVersion < LanguageVersion::v1800_2023) {
-            addDiag(diag::WrongLanguageVersion, result->sourceRange())
-                << toString(options.languageVersion);
-        }
-        return *result;
+    bool startsWithParen = peek(TokenKind::OpenParenthesis);
+    auto result = parseConditionalExpr();
+    if (startsWithParen && options.languageVersion < LanguageVersion::v1800_2023) {
+        addDiag(diag::WrongLanguageVersion, result->sourceRange())
+            << toString(options.languageVersion);
     }
-
-    auto id = expect(TokenKind::Identifier);
-    return *alloc.emplace<NamedConditionalDirectiveExpressionSyntax>(id);
+    return *result;
 }
 
 bool Preprocessor::evalConditionalExpr(
     const syntax::ConditionalDirectiveExpressionSyntax& expr) const {
+    auto evalValue = [&](auto&& self,
+                         const syntax::ConditionalDirectiveExpressionSyntax& node)
+        -> std::optional<SVInt> {
+        switch (node.kind) {
+            case SyntaxKind::ParenthesizedConditionalDirectiveExpression:
+                return self(self,
+                            *node.as<ParenthesizedConditionalDirectiveExpressionSyntax>().operand);
+            case SyntaxKind::NamedConditionalDirectiveExpression: {
+                auto nameToken = node.as<NamedConditionalDirectiveExpressionSyntax>().name;
+                if (nameToken.kind == TokenKind::IntegerLiteral)
+                    return nameToken.intValue();
+                if (nameToken.kind != TokenKind::Identifier)
+                    return std::nullopt;
+
+                auto it = macros.find(nameToken.valueText());
+                if (it == macros.end())
+                    return std::nullopt;
+                if (!it->second.syntax)
+                    return std::nullopt;
+                auto& body = it->second.syntax->body;
+                if (body.size() != 1 || body[0].kind != TokenKind::IntegerLiteral)
+                    return std::nullopt;
+                return body[0].intValue();
+            }
+            default:
+                return std::nullopt;
+        }
+    };
 
     switch (expr.kind) {
         case SyntaxKind::ParenthesizedConditionalDirectiveExpression:
@@ -1232,22 +1270,42 @@ bool Preprocessor::evalConditionalExpr(
                 *expr.as<UnaryConditionalDirectiveExpressionSyntax>().operand);
         case SyntaxKind::BinaryConditionalDirectiveExpression: {
             auto& bcde = expr.as<BinaryConditionalDirectiveExpressionSyntax>();
-            const bool l = evalConditionalExpr(*bcde.left);
-            const bool r = evalConditionalExpr(*bcde.right);
             switch (bcde.op.kind) {
+                case TokenKind::DoubleEquals:
+                case TokenKind::ExclamationEquals: {
+                    auto lhs = evalValue(evalValue, *bcde.left);
+                    auto rhs = evalValue(evalValue, *bcde.right);
+                    bool equal = false;
+                    if (lhs && rhs)
+                        equal = static_cast<bool>(*lhs == *rhs);
+                    else
+                        equal = evalConditionalExpr(*bcde.left) ==
+                                evalConditionalExpr(*bcde.right);
+                    return bcde.op.kind == TokenKind::ExclamationEquals ? !equal : equal;
+                }
                 case TokenKind::DoubleAnd:
-                    return l && r;
+                    return evalConditionalExpr(*bcde.left) &&
+                           evalConditionalExpr(*bcde.right);
                 case TokenKind::DoubleOr:
-                    return l || r;
+                    return evalConditionalExpr(*bcde.left) ||
+                           evalConditionalExpr(*bcde.right);
                 case TokenKind::MinusArrow:
-                    return !l || r;
+                    return !evalConditionalExpr(*bcde.left) ||
+                           evalConditionalExpr(*bcde.right);
                 case TokenKind::LessThanMinusArrow:
-                    return l == r;
+                    return evalConditionalExpr(*bcde.left) ==
+                           evalConditionalExpr(*bcde.right);
                 default:
                     SLANG_UNREACHABLE;
             }
         }
         case SyntaxKind::NamedConditionalDirectiveExpression:
+            if (expr.as<NamedConditionalDirectiveExpressionSyntax>().name.kind ==
+                TokenKind::IntegerLiteral) {
+                return static_cast<bool>(
+                    expr.as<NamedConditionalDirectiveExpressionSyntax>().name.intValue() !=
+                    SVInt::Zero);
+            }
             return macros.find(
                        expr.as<NamedConditionalDirectiveExpressionSyntax>().name.valueText()) !=
                    macros.end();
