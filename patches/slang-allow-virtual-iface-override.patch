diff --git a/include/slang/ast/Compilation.h b/include/slang/ast/Compilation.h
index 927a4db..483831c 100644
--- a/include/slang/ast/Compilation.h
+++ b/include/slang/ast/Compilation.h
@@ -114,9 +114,14 @@ enum class SLANG_EXPORT CompilationFlags {
     DisallowRefsToUnknownInstances = 1 << 12,
 
     /// Allow unnamed generate blocks (e.g. genblk) to be referenced
-    AllowUnnamedGenerate = 1 << 13
+    AllowUnnamedGenerate = 1 << 13,
+
+    /// Allow interface instances that are bind/defparam targets to be assigned
+    /// to virtual interfaces. This violates IEEE 1800-2017 but matches behavior
+    /// of some commercial tools like Cadence Xcelium.
+    AllowVirtualIfaceWithOverride = 1 << 14
 };
-SLANG_BITMASK(CompilationFlags, AllowUnnamedGenerate)
+SLANG_BITMASK(CompilationFlags, AllowVirtualIfaceWithOverride)
 
 /// Contains various options that can control compilation behavior.
 struct SLANG_EXPORT CompilationOptions {
diff --git a/include/slang/parsing/ParserBase.h b/include/slang/parsing/ParserBase.h
index 2c6595f..6e7a916 100644
--- a/include/slang/parsing/ParserBase.h
+++ b/include/slang/parsing/ParserBase.h
@@ -106,6 +106,7 @@ protected:
     }
 
     enum class AllowEmpty { False, True };
+    enum class AllowTrailingSeparator { False, True };
     enum class RequireItems { False, True };
 
     /// This is a generalized method for parsing a delimiter separated list of things
@@ -114,7 +115,8 @@ protected:
     void parseList(TokenKind openKind, TokenKind closeKind, TokenKind separatorKind,
                    Token& openToken, std::span<syntax::TokenOrSyntax>& list, Token& closeToken,
                    RequireItems requireItems, DiagCode code, TParserFunc&& parseItem,
-                   AllowEmpty allowEmpty = {}) {
+                   AllowEmpty allowEmpty = {},
+                   AllowTrailingSeparator allowTrailingSeparator = {}) {
         openToken = expect(openKind);
         if (openToken.isMissing()) {
             closeToken = missingToken(closeKind, openToken.location());
@@ -125,14 +127,16 @@ protected:
         SmallVector<syntax::TokenOrSyntax, 16> buffer;
         parseList<IsExpected, IsEnd, TParserFunc>(buffer, closeKind, separatorKind, closeToken,
                                                   requireItems, code,
-                                                  std::forward<TParserFunc>(parseItem), allowEmpty);
+                                                  std::forward<TParserFunc>(parseItem), allowEmpty,
+                                                  allowTrailingSeparator);
         list = buffer.copy(alloc);
     }
 
     template<bool (*IsExpected)(TokenKind), bool (*IsEnd)(TokenKind), typename TParserFunc>
     void parseList(SmallVectorBase<syntax::TokenOrSyntax>& buffer, TokenKind closeKind,
                    TokenKind separatorKind, Token& closeToken, RequireItems requireItems,
-                   DiagCode code, TParserFunc&& parseItem, AllowEmpty allowEmpty = {}) {
+                   DiagCode code, TParserFunc&& parseItem, AllowEmpty allowEmpty = {},
+                   AllowTrailingSeparator allowTrailingSeparator = {}) {
         auto current = peek();
         if (IsEnd(current.kind)) {
             if (requireItems == RequireItems::True && !haveDiagAtCurrentLoc())
@@ -192,8 +196,7 @@ protected:
                     // Empty items are allowed, so call the parse function
                     // to get one here and then we're finished.
                     buffer.push_back(parseItem());
-                }
-                else {
+                } else if (allowTrailingSeparator == AllowTrailingSeparator::False) {
                     // Specific check for misplaced trailing separators here.
                     reportMisplacedSeparator();
                 }
diff --git a/source/ast/Expression.cpp b/source/ast/Expression.cpp
index c787a84..e880d64 100644
--- a/source/ast/Expression.cpp
+++ b/source/ast/Expression.cpp
@@ -1442,7 +1442,8 @@ Expression* Expression::tryBindInterfaceRef(const ASTContext& context,
     }
 
     if (!isInterfacePort) {
-        if (iface->hierarchyOverrideNode) {
+        if (iface->hierarchyOverrideNode &&
+            !context.getCompilation().hasFlag(CompilationFlags::AllowVirtualIfaceWithOverride)) {
             auto& diag = context.addDiag(diag::VirtualIfaceDefparam, sourceRange);
             if (auto source = findOverrideNodeSource(*iface->hierarchyOverrideNode))
                 diag.addNote(diag::NoteDeclarationHere, source->sourceRange());
diff --git a/source/ast/expressions/OperatorExpressions.cpp b/source/ast/expressions/OperatorExpressions.cpp
index c2961dd..b8eb00f 100644
--- a/source/ast/expressions/OperatorExpressions.cpp
+++ b/source/ast/expressions/OperatorExpressions.cpp
@@ -818,7 +818,8 @@ Expression& BinaryExpression::fromComponents(Expression& lhs, Expression& rhs, B
         case BinaryOperator::LogicalImplication:
         case BinaryOperator::LogicalEquivalence:
             // Result is always a single bit.
-            good = bothNumeric;
+            // Allow any boolean-convertible types (numeric, class handles, etc.)
+            good = lt->isBooleanConvertible() && rt->isBooleanConvertible();
             result->type = singleBitType(compilation, lt, rt);
             selfDetermined(context, result->left_);
             selfDetermined(context, result->right_);
diff --git a/source/parsing/Parser.cpp b/source/parsing/Parser.cpp
index a9ecf0b..eae5dc2 100644
--- a/source/parsing/Parser.cpp
+++ b/source/parsing/Parser.cpp
@@ -84,7 +84,9 @@ AnsiPortListSyntax& Parser::parseAnsiPortList(Token openParen) {
     parseList<isPossibleAnsiPort, isEndOfParenList>(buffer, TokenKind::CloseParenthesis,
                                                     TokenKind::Comma, closeParen,
                                                     RequireItems::False, diag::ExpectedAnsiPort,
-                                                    [this] { return &parseAnsiPort(); });
+                                                    [this] { return &parseAnsiPort(); },
+                                                    AllowEmpty::False,
+                                                    AllowTrailingSeparator::True);
 
     auto& result = factory.ansiPortList(openParen, buffer.copy(alloc), closeParen);
     result.previewNode = std::exchange(previewNode, nullptr);
diff --git a/source/parsing/Preprocessor.cpp b/source/parsing/Preprocessor.cpp
index f0fd95f..cbaad37 100644
--- a/source/parsing/Preprocessor.cpp
+++ b/source/parsing/Preprocessor.cpp
@@ -17,6 +17,8 @@
 #include "slang/util/String.h"
 #include "slang/util/VersionInfo.h"
 
+#include <optional>
+
 namespace slang::parsing {
 
 using namespace syntax;
@@ -1212,15 +1214,20 @@ Trivia Preprocessor::handleDefaultTriregStrengthDirective(Token directive) {
 }
 
 ConditionalDirectiveExpressionSyntax* Preprocessor::parseConditionalExpr() {
-    auto isBinaryOp = [](TokenKind kind) {
+    auto getPrecedence = [](TokenKind kind) {
         switch (kind) {
+            case TokenKind::DoubleEquals:
+            case TokenKind::ExclamationEquals:
+                return 30;
             case TokenKind::DoubleAnd:
+                return 20;
             case TokenKind::DoubleOr:
+                return 10;
             case TokenKind::MinusArrow:
             case TokenKind::LessThanMinusArrow:
-                return true;
+                return 5;
             default:
-                return false;
+                return -1;
         }
     };
 
@@ -1234,54 +1241,85 @@ ConditionalDirectiveExpressionSyntax* Preprocessor::parseConditionalExpr() {
                                                                                     *operand,
                                                                                     closeParen);
         }
-        else {
-            auto id = expect(TokenKind::Identifier);
-            return alloc.emplace<NamedConditionalDirectiveExpressionSyntax>(id);
+        if (token.kind == TokenKind::IntegerLiteral) {
+            return alloc.emplace<NamedConditionalDirectiveExpressionSyntax>(consume());
         }
+        auto id = expect(TokenKind::Identifier);
+        return alloc.emplace<NamedConditionalDirectiveExpressionSyntax>(id);
     };
 
-    ConditionalDirectiveExpressionSyntax* left;
-    if (peek(TokenKind::Exclamation)) {
-        auto op = consume();
-        auto operand = parsePrimary();
-        left = alloc.emplace<UnaryConditionalDirectiveExpressionSyntax>(op, *operand);
-    }
-    else {
-        left = parsePrimary();
-    }
-
-    while (true) {
-        if (!isBinaryOp(peek().kind))
-            break;
+    auto parseExpr = [&](auto&& self, int minPrecedence)
+        -> ConditionalDirectiveExpressionSyntax* {
+        auto parseUnary = [&](auto&& unarySelf) -> ConditionalDirectiveExpressionSyntax* {
+            if (peek(TokenKind::Exclamation)) {
+                auto op = consume();
+                auto operand = unarySelf(unarySelf);
+                return alloc.emplace<UnaryConditionalDirectiveExpressionSyntax>(op, *operand);
+            }
+            return parsePrimary();
+        };
 
-        auto op = consume();
-        auto right = parseConditionalExpr();
-        left = alloc.emplace<BinaryConditionalDirectiveExpressionSyntax>(*left, op, *right);
-    }
+        auto left = parseUnary(parseUnary);
+        while (true) {
+            if (!peekSameLine())
+                break;
+            int prec = getPrecedence(peek().kind);
+            if (prec < minPrecedence)
+                break;
+            auto op = consume();
+            auto right = self(self, prec + 1);
+            left = alloc.emplace<BinaryConditionalDirectiveExpressionSyntax>(*left, op, *right);
+        }
+        return left;
+    };
 
-    return left;
+    return parseExpr(parseExpr, 0);
 }
 
 ConditionalDirectiveExpressionSyntax& Preprocessor::parseConditionalExprTop() {
-    SLANG_ASSERT(!inIfDefCondition);
-    auto guard = ScopeGuard([this] { inIfDefCondition = false; });
+    bool prevIfDefCondition = inIfDefCondition;
+    auto guard = ScopeGuard([this, prevIfDefCondition] { inIfDefCondition = prevIfDefCondition; });
     inIfDefCondition = true;
 
-    if (peek(TokenKind::OpenParenthesis)) {
-        auto result = parseConditionalExpr();
-        if (options.languageVersion < LanguageVersion::v1800_2023) {
-            addDiag(diag::WrongLanguageVersion, result->sourceRange())
-                << toString(options.languageVersion);
-        }
-        return *result;
+    bool startsWithParen = peek(TokenKind::OpenParenthesis);
+    auto result = parseConditionalExpr();
+    if (startsWithParen && options.languageVersion < LanguageVersion::v1800_2023) {
+        addDiag(diag::WrongLanguageVersion, result->sourceRange())
+            << toString(options.languageVersion);
     }
-
-    auto id = expect(TokenKind::Identifier);
-    return *alloc.emplace<NamedConditionalDirectiveExpressionSyntax>(id);
+    return *result;
 }
 
 bool Preprocessor::evalConditionalExpr(
     const syntax::ConditionalDirectiveExpressionSyntax& expr) const {
+    auto evalValue = [&](auto&& self,
+                         const syntax::ConditionalDirectiveExpressionSyntax& node)
+        -> std::optional<SVInt> {
+        switch (node.kind) {
+            case SyntaxKind::ParenthesizedConditionalDirectiveExpression:
+                return self(self,
+                            *node.as<ParenthesizedConditionalDirectiveExpressionSyntax>().operand);
+            case SyntaxKind::NamedConditionalDirectiveExpression: {
+                auto nameToken = node.as<NamedConditionalDirectiveExpressionSyntax>().name;
+                if (nameToken.kind == TokenKind::IntegerLiteral)
+                    return nameToken.intValue();
+                if (nameToken.kind != TokenKind::Identifier)
+                    return std::nullopt;
+
+                auto it = macros.find(nameToken.valueText());
+                if (it == macros.end())
+                    return std::nullopt;
+                if (!it->second.syntax)
+                    return std::nullopt;
+                auto& body = it->second.syntax->body;
+                if (body.size() != 1 || body[0].kind != TokenKind::IntegerLiteral)
+                    return std::nullopt;
+                return body[0].intValue();
+            }
+            default:
+                return std::nullopt;
+        }
+    };
 
     switch (expr.kind) {
         case SyntaxKind::ParenthesizedConditionalDirectiveExpression:
@@ -1293,22 +1331,42 @@ bool Preprocessor::evalConditionalExpr(
                 *expr.as<UnaryConditionalDirectiveExpressionSyntax>().operand);
         case SyntaxKind::BinaryConditionalDirectiveExpression: {
             auto& bcde = expr.as<BinaryConditionalDirectiveExpressionSyntax>();
-            const bool l = evalConditionalExpr(*bcde.left);
-            const bool r = evalConditionalExpr(*bcde.right);
             switch (bcde.op.kind) {
+                case TokenKind::DoubleEquals:
+                case TokenKind::ExclamationEquals: {
+                    auto lhs = evalValue(evalValue, *bcde.left);
+                    auto rhs = evalValue(evalValue, *bcde.right);
+                    bool equal = false;
+                    if (lhs && rhs)
+                        equal = static_cast<bool>(*lhs == *rhs);
+                    else
+                        equal = evalConditionalExpr(*bcde.left) ==
+                                evalConditionalExpr(*bcde.right);
+                    return bcde.op.kind == TokenKind::ExclamationEquals ? !equal : equal;
+                }
                 case TokenKind::DoubleAnd:
-                    return l && r;
+                    return evalConditionalExpr(*bcde.left) &&
+                           evalConditionalExpr(*bcde.right);
                 case TokenKind::DoubleOr:
-                    return l || r;
+                    return evalConditionalExpr(*bcde.left) ||
+                           evalConditionalExpr(*bcde.right);
                 case TokenKind::MinusArrow:
-                    return !l || r;
+                    return !evalConditionalExpr(*bcde.left) ||
+                           evalConditionalExpr(*bcde.right);
                 case TokenKind::LessThanMinusArrow:
-                    return l == r;
+                    return evalConditionalExpr(*bcde.left) ==
+                           evalConditionalExpr(*bcde.right);
                 default:
                     SLANG_UNREACHABLE;
             }
         }
         case SyntaxKind::NamedConditionalDirectiveExpression:
+            if (expr.as<NamedConditionalDirectiveExpressionSyntax>().name.kind ==
+                TokenKind::IntegerLiteral) {
+                return static_cast<bool>(
+                    expr.as<NamedConditionalDirectiveExpressionSyntax>().name.intValue() !=
+                    SVInt::Zero);
+            }
             return macros.find(
                        expr.as<NamedConditionalDirectiveExpressionSyntax>().name.valueText()) !=
                    macros.end();
