From: CIRCT Team <circt@llvm.org>
Subject: [PATCH] Fix bind directive lookup for nested definitions

When resolving a bind directive's instantiation definition, handle the case
where the definition is nested inside a module. The problem is that:
1. Nested definitions are registered with their containing DefinitionSymbol
   as the scope
2. Bind directives are recorded with their containing InstanceBodySymbol
   as the scope
3. These are different scope objects, so the scope-based lookup fails

The fix tries multiple lookup strategies:
1. First try using the bind scope (where the bind directive was written)
2. Then try using the target scope (the bind target instance's scope)
3. Finally, since the syntax uniquely identifies the definition, look up
   any definition registered for that syntax

This ensures that for code like:
  module Top;
    TargetIf t();
    interface BindIf; endinterface  // nested definition
    bind t BindIf bind_inst();
  endmodule

The local BindIf interface is found correctly even though the scopes
differ between definition registration and bind resolution.

diff --git a/source/ast/Compilation.cpp b/source/ast/Compilation.cpp
index 83af0fe..a967cef 100644
--- a/source/ast/Compilation.cpp
+++ b/source/ast/Compilation.cpp
@@ -659,7 +659,22 @@ Compilation::DefinitionLookupResult Compilation::getDefinition(
             case SyntaxKind::InterfaceDeclaration:
             case SyntaxKind::ProgramDeclaration: {
                 auto& mds = bindInfo.instantiationDefSyntax->as<ModuleDeclarationSyntax>();
-                result.definition = getDefinition(scope, mds);
+                // Try bind scope first (where the bind directive was written), then target scope.
+                // For nested definitions, the scope where the bind is written may differ from
+                // the scope where the definition was registered (InstanceBody vs Definition).
+                if (bindInfo.bindScope)
+                    result.definition = getDefinition(*bindInfo.bindScope, mds);
+                if (!result.definition)
+                    result.definition = getDefinition(scope, mds);
+                // If still not found, the syntax uniquely identifies the definition,
+                // so pick any definition for that syntax (handles nested definitions
+                // where the registering scope differs from both bind and target scopes).
+                if (!result.definition) {
+                    if (auto it = definitionFromSyntax.find(&mds);
+                        it != definitionFromSyntax.end() && !it->second.empty()) {
+                        result.definition = it->second.begin()->second;
+                    }
+                }
                 if (!result.definition)
                     errorMissingDef(name, scope, sourceRange, diag::UnknownModule);
                 break;
